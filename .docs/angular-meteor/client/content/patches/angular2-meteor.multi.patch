From 7c682b25c883bfe89dbe1f56a3e8a7a2cc8b1719 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 10:59:46 +0900
Subject: [PATCH 01/95] tutorial renamed

---
 packages/ng2-socially-tutorial/client/registerTutorial.js | 2 +-
 packages/ng2-socially-tutorial/package.js                 | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/packages/ng2-socially-tutorial/client/registerTutorial.js b/packages/ng2-socially-tutorial/client/registerTutorial.js
index 4f9633a..ff69a6a 100644
--- a/packages/ng2-socially-tutorial/client/registerTutorial.js
+++ b/packages/ng2-socially-tutorial/client/registerTutorial.js
@@ -1,6 +1,6 @@
 Diffbox.registerTutorial('tutorialAngular2', {
   githubRepoName: 'shmck/ng2-socially-tutorial',
-  patchFilename: 'angular2Tutorial.multi.patch'
+  patchFilename: 'angular-meteor2.multi.patch'
 });
 
 //TutorialRegistry.registerTutorial({
diff --git a/packages/ng2-socially-tutorial/package.js b/packages/ng2-socially-tutorial/package.js
index d97c1f3..20936b0 100644
--- a/packages/ng2-socially-tutorial/package.js
+++ b/packages/ng2-socially-tutorial/package.js
@@ -14,7 +14,7 @@ Package.onUse(function(api) {
     'mdg:tutorial-registry'
   ]);
   api.addFiles([
-    'angular2Tutorial.multi.patch'
+    'angular-meteor2.multi.patch'
   ]);
 });
 
-- 
2.3.5


From 206924ba42aa74f5147f0a13f5b39eaf7660d367 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 11:00:49 +0900
Subject: [PATCH 02/95] tutorial setup

---
 packages/ng2-socially-tutorial/client/registerTutorial.js | 9 +--------
 1 file changed, 1 insertion(+), 8 deletions(-)

diff --git a/packages/ng2-socially-tutorial/client/registerTutorial.js b/packages/ng2-socially-tutorial/client/registerTutorial.js
index ff69a6a..51fb898 100644
--- a/packages/ng2-socially-tutorial/client/registerTutorial.js
+++ b/packages/ng2-socially-tutorial/client/registerTutorial.js
@@ -1,11 +1,4 @@
 Diffbox.registerTutorial('tutorialAngular2', {
   githubRepoName: 'shmck/ng2-socially-tutorial',
   patchFilename: 'angular-meteor2.multi.patch'
-});
-
-//TutorialRegistry.registerTutorial({
-//  title: 'Meteor Angular2 Tutorial',
-//  subtitle: 'Socially',
-//  tutorialSourceLink: 'angular-meteor.com/tutorials/angular2/bootstrapping',
-//  steps: []
-//});
\ No newline at end of file
+});
\ No newline at end of file
-- 
2.3.5


From 2d45f952cbf93ca2054bfcfeca3ba3ca19224f22 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 15:49:01 +0900
Subject: [PATCH 03/95] setup. .gitignore .meteor/versions

---
 .gitignore                                         |  1 +
 .meteor/packages                                   |  1 -
 .meteor/versions                                   |  1 -
 packages/ng2-socially-tutorial/README.md           |  0
 .../client/registerTutorial.js                     |  4 ----
 packages/ng2-socially-tutorial/package.js          | 25 ----------------------
 6 files changed, 1 insertion(+), 31 deletions(-)
 create mode 100644 .gitignore
 delete mode 100644 packages/ng2-socially-tutorial/README.md
 delete mode 100644 packages/ng2-socially-tutorial/client/registerTutorial.js
 delete mode 100644 packages/ng2-socially-tutorial/package.js

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..084bad7
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+.meteor/versions
diff --git a/.meteor/packages b/.meteor/packages
index fd37458..99704e0 100644
--- a/.meteor/packages
+++ b/.meteor/packages
@@ -7,4 +7,3 @@
 meteor-platform
 autopublish
 insecure
-mdg:tutorial-step-diff-compiler
diff --git a/.meteor/versions b/.meteor/versions
index 09061f3..410e1d9 100644
--- a/.meteor/versions
+++ b/.meteor/versions
@@ -22,7 +22,6 @@ json@1.0.3
 launch-screen@1.0.2
 livedata@1.0.13
 logging@1.0.7
-mdg:tutorial-step-diff-compiler@0.2.0
 meteor@1.1.6
 meteor-platform@1.2.2
 minifiers@1.1.5
diff --git a/packages/ng2-socially-tutorial/README.md b/packages/ng2-socially-tutorial/README.md
deleted file mode 100644
index e69de29..0000000
diff --git a/packages/ng2-socially-tutorial/client/registerTutorial.js b/packages/ng2-socially-tutorial/client/registerTutorial.js
deleted file mode 100644
index 51fb898..0000000
--- a/packages/ng2-socially-tutorial/client/registerTutorial.js
+++ /dev/null
@@ -1,4 +0,0 @@
-Diffbox.registerTutorial('tutorialAngular2', {
-  githubRepoName: 'shmck/ng2-socially-tutorial',
-  patchFilename: 'angular-meteor2.multi.patch'
-});
\ No newline at end of file
diff --git a/packages/ng2-socially-tutorial/package.js b/packages/ng2-socially-tutorial/package.js
deleted file mode 100644
index 20936b0..0000000
--- a/packages/ng2-socially-tutorial/package.js
+++ /dev/null
@@ -1,25 +0,0 @@
-Package.describe({
-  name: 'shmck:ng2-socially-tutorial',
-  version: '0.0.1',
-  summary: 'Meteor-Angular2 tutorial: Socially',
-  git: 'https://github.com/shmck/ng2-socially-tutorial',
-  documentation: 'README.md'
-});
-
-Package.onUse(function(api) {
-  api.versionsFrom('1.1.0.3');
-  api.use([
-    'mdg:tutorial-step-diff-compiler',
-    'mdg:tutorial-diff-box',
-    'mdg:tutorial-registry'
-  ]);
-  api.addFiles([
-    'angular-meteor2.multi.patch'
-  ]);
-});
-
-Package.onTest(function(api) {
-  api.use('tinytest');
-  api.use('shmck:ng2-socially-tutorial');
-  api.addFiles('ng2-socially-tutorial-tests.js');
-});
-- 
2.3.5


From ddf560b3750f019bc9538dc2ebbe4d4ce7272984 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 16:04:34 +0900
Subject: [PATCH 04/95] Step 0.1: Create empty index.html file in client folder

---
 .meteor/packages  | 2 ++
 client/index.html | 3 +++
 2 files changed, 5 insertions(+)
 create mode 100644 client/index.html

diff --git a/.meteor/packages b/.meteor/packages
index 99704e0..2e62fc5 100644
--- a/.meteor/packages
+++ b/.meteor/packages
@@ -7,3 +7,5 @@
 meteor-platform
 autopublish
 insecure
+shmck:angular2
+netanelgilad:angular2-typescript
diff --git a/client/index.html b/client/index.html
new file mode 100644
index 0000000..b65138f
--- /dev/null
+++ b/client/index.html
@@ -0,0 +1,3 @@
+<body>
+  <p>Nothing here</p>
+</body>
\ No newline at end of file
-- 
2.3.5


From 515a64aa5ab351a77a7b5cf0e3fa8f257e3ffaa6 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Wed, 2 Sep 2015 23:04:51 +0900
Subject: [PATCH 05/95] meteor versions

---
 .meteor/versions | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/.meteor/versions b/.meteor/versions
index 410e1d9..4960c40 100644
--- a/.meteor/versions
+++ b/.meteor/versions
@@ -28,6 +28,7 @@ minifiers@1.1.5
 minimongo@1.0.8
 mobile-status-bar@1.0.3
 mongo@1.1.0
+netanelgilad:angular2-typescript@0.0.3
 observe-sequence@1.0.6
 ordered-dict@1.0.3
 random@1.0.3
@@ -37,6 +38,7 @@ reload@1.1.3
 retry@1.0.3
 routepolicy@1.0.5
 session@1.1.0
+shmck:angular2@2.0.6
 spacebars@1.0.6
 spacebars-compiler@1.0.6
 templating@1.1.1
-- 
2.3.5


From 75d044b5a1c9e98c18b9d803a13714addf07b0a4 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Wed, 2 Sep 2015 23:05:24 +0900
Subject: [PATCH 06/95] Step 0.3: Import bootstrap component with System.js

---
 client/index.html | 1 +
 1 file changed, 1 insertion(+)

diff --git a/client/index.html b/client/index.html
index b65138f..d8daf11 100644
--- a/client/index.html
+++ b/client/index.html
@@ -1,3 +1,4 @@
 <body>
   <p>Nothing here</p>
+  <script>System.import("client/app");</script>
 </body>
\ No newline at end of file
-- 
2.3.5


From 4457e5f431d2245a4750e1d5a623986c52154193 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 16:12:36 +0900
Subject: [PATCH 07/95] Step 0.4: Create Angular2 root component

---
 client/index.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/client/index.html b/client/index.html
index d8daf11..b3cd76e 100644
--- a/client/index.html
+++ b/client/index.html
@@ -1,4 +1,4 @@
 <body>
-  <p>Nothing here</p>
+  <app></app>
   <script>System.import("client/app");</script>
 </body>
\ No newline at end of file
-- 
2.3.5


From cb57c9c1d044b4ef1a1f642dac37787ca3211e99 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 16:13:57 +0900
Subject: [PATCH 08/95] Step 0.5: Create root component, app.ts

---
 client/app.ts | 11 +++++++++++
 1 file changed, 11 insertions(+)
 create mode 100644 client/app.ts

diff --git a/client/app.ts b/client/app.ts
new file mode 100644
index 0000000..e989752
--- /dev/null
+++ b/client/app.ts
@@ -0,0 +1,11 @@
+import {Component, View, bootstrap} from 'angular2/angular2';
+
+@Component({
+  selector: 'app'
+})
+@View({
+  template: "<p>Hello World!</p>"
+})
+class Socially {}
+
+bootstrap(Socially);
\ No newline at end of file
-- 
2.3.5


From 2b4cc04354f07bfb606fb8d09773d6dabd2c2283 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Wed, 2 Sep 2015 23:08:53 +0900
Subject: [PATCH 09/95] Step 0.6: change inline template to templateUrl

---
 client/app.ts | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/client/app.ts b/client/app.ts
index e989752..b793e6a 100644
--- a/client/app.ts
+++ b/client/app.ts
@@ -4,7 +4,7 @@ import {Component, View, bootstrap} from 'angular2/angular2';
   selector: 'app'
 })
 @View({
-  template: "<p>Hello World!</p>"
+  templateUrl: 'client/index.ng.html'
 })
 class Socially {}
 
-- 
2.3.5


From ab3c8ab5da2eccfbc3af37fe18195403ecdc5c5b Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Wed, 2 Sep 2015 23:09:19 +0900
Subject: [PATCH 10/95] Step 0.7: create index.ng.html template

---
 client/index.ng.html | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 client/index.ng.html

diff --git a/client/index.ng.html b/client/index.ng.html
new file mode 100644
index 0000000..ff611cc
--- /dev/null
+++ b/client/index.ng.html
@@ -0,0 +1 @@
+<p>Nothing here {{ 'yet' + '!' }}</p>
\ No newline at end of file
-- 
2.3.5


From 43b8fcc91aa4005b2f3e93327eaa53a443539fca Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 18:46:13 +0900
Subject: [PATCH 11/95] Step 1.1: Add static HTML to the template

---
 client/index.ng.html | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/client/index.ng.html b/client/index.ng.html
index ff611cc..9ea318e 100644
--- a/client/index.ng.html
+++ b/client/index.ng.html
@@ -1 +1,14 @@
-<p>Nothing here {{ 'yet' + '!' }}</p>
\ No newline at end of file
+<ul>
+  <li>
+    <span>Dubstep-Free Zone</span>
+    <p>
+      Can we please just for an evening not listen to dubstep.
+    </p>
+  </li>
+  <li>
+    <span>All dubstep all the time</span>
+    <p>
+      Get it on!
+    </p>
+  </li>
+</ul>
\ No newline at end of file
-- 
2.3.5


From 528bcd32ac1604b61ea72ac9ce8e3c1e8af372fa Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 18:47:42 +0900
Subject: [PATCH 12/95] Step 2.1: Use dynamic template with NgFor

---
 client/index.ng.html | 22 ++++++++--------------
 1 file changed, 8 insertions(+), 14 deletions(-)

diff --git a/client/index.ng.html b/client/index.ng.html
index 9ea318e..79a13be 100644
--- a/client/index.ng.html
+++ b/client/index.ng.html
@@ -1,14 +1,8 @@
-<ul>
-  <li>
-    <span>Dubstep-Free Zone</span>
-    <p>
-      Can we please just for an evening not listen to dubstep.
-    </p>
-  </li>
-  <li>
-    <span>All dubstep all the time</span>
-    <p>
-      Get it on!
-    </p>
-  </li>
-</ul>
\ No newline at end of file
+<div>
+  <ul>
+    <li *ng-for="#party of parties">
+      {{party.name}}
+      <p>{{party.description}}</p>
+    </li>
+  </ul>
+</div>
\ No newline at end of file
-- 
2.3.5


From 736f05c841e429a983bfe652bb7a8feea4f08176 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 18:51:01 +0900
Subject: [PATCH 13/95] Step 2.2: Load NgFor dependency, add to View directives
 list

---
 client/app.ts | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/client/app.ts b/client/app.ts
index b793e6a..afbfbca 100644
--- a/client/app.ts
+++ b/client/app.ts
@@ -1,10 +1,11 @@
-import {Component, View, bootstrap} from 'angular2/angular2';
+import {Component, View, NgFor, bootstrap} from 'angular2/angular2';
 
 @Component({
   selector: 'app'
 })
 @View({
-  templateUrl: 'client/index.ng.html'
+  templateUrl: 'client/index.ng.html',
+  directives: [NgFor]
 })
 class Socially {}
 
-- 
2.3.5


From ab1b86d1b1cbc4d48cd399a78645271c00338d68 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 18:52:11 +0900
Subject: [PATCH 14/95] Step 2.3: Load parties data into Socially

---
 client/app.ts | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/client/app.ts b/client/app.ts
index afbfbca..c5ceff3 100644
--- a/client/app.ts
+++ b/client/app.ts
@@ -7,6 +7,17 @@ import {Component, View, NgFor, bootstrap} from 'angular2/angular2';
   templateUrl: 'client/index.ng.html',
   directives: [NgFor]
 })
-class Socially {}
+class Socially {
+  constructor () {
+    this.parties = [
+      {'name': 'Dubstep-Free Zone',
+        'description': 'Can we please just for an evening not listen to dubstep.'},
+      {'name': 'All dubstep all the time',
+        'description': 'Get it on!'},
+      {'name': 'Savage lounging',
+        'description': 'Leisure suit required. And only fiercest manners.'}
+    ];
+  }
+}
 
 bootstrap(Socially);
\ No newline at end of file
-- 
2.3.5


From 000b9a74a7d0bba1d8c8f4e6e8f35a4ad2cc3eee Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 18:53:48 +0900
Subject: [PATCH 15/95] Step 3.1: Add the parties collection

---
 model/parties.ts | 1 +
 1 file changed, 1 insertion(+)
 create mode 100644 model/parties.ts

diff --git a/model/parties.ts b/model/parties.ts
new file mode 100644
index 0000000..f9329b3
--- /dev/null
+++ b/model/parties.ts
@@ -0,0 +1 @@
+Parties = new Mongo.Collection('parties');
\ No newline at end of file
-- 
2.3.5


From d92c3420bf62b364ebf4e54d4635eebf36a9f397 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 18:55:48 +0900
Subject: [PATCH 16/95] Step 3.2: Fetch parties reactively

---
 client/app.ts | 11 +++--------
 1 file changed, 3 insertions(+), 8 deletions(-)

diff --git a/client/app.ts b/client/app.ts
index c5ceff3..94f0af6 100644
--- a/client/app.ts
+++ b/client/app.ts
@@ -9,14 +9,9 @@ import {Component, View, NgFor, bootstrap} from 'angular2/angular2';
 })
 class Socially {
   constructor () {
-    this.parties = [
-      {'name': 'Dubstep-Free Zone',
-        'description': 'Can we please just for an evening not listen to dubstep.'},
-      {'name': 'All dubstep all the time',
-        'description': 'Get it on!'},
-      {'name': 'Savage lounging',
-        'description': 'Leisure suit required. And only fiercest manners.'}
-    ];
+    Tracker.autorun(zone.bind(() => {
+      this.parties = Parties.find().fetch();
+    }));
   }
 }
 
-- 
2.3.5


From d3cd46c2ee4d92ec79e5c6fa1f12f7b055da3ea0 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 18:58:55 +0900
Subject: [PATCH 17/95] Step 3.3: Load initial parties data if none exists

---
 server/loadParties.ts | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)
 create mode 100644 server/loadParties.ts

diff --git a/server/loadParties.ts b/server/loadParties.ts
new file mode 100644
index 0000000..a2a6e3d
--- /dev/null
+++ b/server/loadParties.ts
@@ -0,0 +1,16 @@
+Meteor.startup(function () {
+  if (Parties.find().count() === 0) {
+
+    var parties = [
+      {'name': 'Dubstep-Free Zone',
+        'description': 'Can we please just for an evening not listen to dubstep.'},
+      {'name': 'All dubstep all the time',
+        'description': 'Get it on!'},
+      {'name': 'Savage lounging',
+        'description': 'Leisure suit required. And only fiercest manners.'}
+    ];
+
+    for (var i = 0; i < parties.length; i++)
+      Parties.insert(parties[i]);
+  }
+});
\ No newline at end of file
-- 
2.3.5


From a33b47c0c705de68a79641cf369b072b97d0eee1 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 19:01:03 +0900
Subject: [PATCH 18/95] Step 4.1: Create parties-form component

---
 client/parties-form/parties-form.ts | 9 +++++++++
 1 file changed, 9 insertions(+)
 create mode 100644 client/parties-form/parties-form.ts

diff --git a/client/parties-form/parties-form.ts b/client/parties-form/parties-form.ts
new file mode 100644
index 0000000..c541876
--- /dev/null
+++ b/client/parties-form/parties-form.ts
@@ -0,0 +1,9 @@
+import {Component, View} from 'angular2/angular2';
+
+@Component({
+  selector: 'parties-form'
+})
+@View({
+  templateUrl: 'client/parties-form/parties-form.ng.html'
+})
+export class PartiesForm {}
\ No newline at end of file
-- 
2.3.5


From 1bd0d81218ab9a566474476e71299a74d4f6d94a Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 19:02:11 +0900
Subject: [PATCH 19/95] Step 4.2: Initialize the parties-form view

---
 client/parties-form/parties-form.ng.html | 7 +++++++
 1 file changed, 7 insertions(+)
 create mode 100644 client/parties-form/parties-form.ng.html

diff --git a/client/parties-form/parties-form.ng.html b/client/parties-form/parties-form.ng.html
new file mode 100644
index 0000000..c81e1cf
--- /dev/null
+++ b/client/parties-form/parties-form.ng.html
@@ -0,0 +1,7 @@
+<form>
+  <label>Name</label>
+  <input type="text">
+  <label>Description</label>
+  <input type="text">
+  <button>Add</button>
+</form>
\ No newline at end of file
-- 
2.3.5


From ace6b1a0b239776a2322c474eec069f77c5e22b1 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 19:03:11 +0900
Subject: [PATCH 20/95] Step 4.3: Load the parties-form component

---
 client/index.ng.html | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/client/index.ng.html b/client/index.ng.html
index 79a13be..9a6b4e2 100644
--- a/client/index.ng.html
+++ b/client/index.ng.html
@@ -1,4 +1,7 @@
 <div>
+
+  <parties-form></parties-form>
+
   <ul>
     <li *ng-for="#party of parties">
       {{party.name}}
-- 
2.3.5


From 41421ef569c373ba29c2633d54fe27f43366ea77 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 19:05:10 +0900
Subject: [PATCH 21/95] Step 4.4: Import the Parties form and add it to the App
 View directives list

---
 client/app.ts | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/client/app.ts b/client/app.ts
index 94f0af6..c6be929 100644
--- a/client/app.ts
+++ b/client/app.ts
@@ -1,11 +1,12 @@
 import {Component, View, NgFor, bootstrap} from 'angular2/angular2';
+import {PartiesForm} from 'client/parties-form/parties-form';
 
 @Component({
   selector: 'app'
 })
 @View({
   templateUrl: 'client/index.ng.html',
-  directives: [NgFor]
+  directives: [NgFor, PartiesForm]
 })
 class Socially {
   constructor () {
-- 
2.3.5


From 6eedb99cf90d35f05628eddf00d0d9b6d5a9bed2 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 19:07:53 +0900
Subject: [PATCH 22/95] Step 4.5: Import form directives and add them to the
 list of parties-form view directives

---
 client/parties-form/parties-form.ts | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/client/parties-form/parties-form.ts b/client/parties-form/parties-form.ts
index c541876..3c356a8 100644
--- a/client/parties-form/parties-form.ts
+++ b/client/parties-form/parties-form.ts
@@ -1,9 +1,11 @@
 import {Component, View} from 'angular2/angular2';
+import {FORM_DIRECTIVES, Control, ControlGroup, Validators} from 'angular2/angular2';
 
 @Component({
   selector: 'parties-form'
 })
 @View({
-  templateUrl: 'client/parties-form/parties-form.ng.html'
+  templateUrl: 'client/parties-form/parties-form.ng.html',
+  directives: [FORM_DIRECTIVES]
 })
 export class PartiesForm {}
\ No newline at end of file
-- 
2.3.5


From d622bbbf950f3921d52ee27259f0509db6e811ca Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 19:11:26 +0900
Subject: [PATCH 23/95] Step 4.6: Create a partiesForm control group

---
 client/parties-form/parties-form.ts | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/client/parties-form/parties-form.ts b/client/parties-form/parties-form.ts
index 3c356a8..e170216 100644
--- a/client/parties-form/parties-form.ts
+++ b/client/parties-form/parties-form.ts
@@ -8,4 +8,11 @@ import {FORM_DIRECTIVES, Control, ControlGroup, Validators} from 'angular2/angul
   templateUrl: 'client/parties-form/parties-form.ng.html',
   directives: [FORM_DIRECTIVES]
 })
-export class PartiesForm {}
\ No newline at end of file
+export class PartiesForm {
+  constructor() {
+    this.partiesForm = new ControlGroup({
+      name: new Control(''),
+      description: new Control('')
+    });
+  }
+}
\ No newline at end of file
-- 
2.3.5


From 1681e54bb2f13ab25ec25b116fda1e8777a22c36 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 19:12:50 +0900
Subject: [PATCH 24/95] Step 4.7: Add 'required' form validators

---
 client/parties-form/parties-form.ts | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/client/parties-form/parties-form.ts b/client/parties-form/parties-form.ts
index e170216..5263602 100644
--- a/client/parties-form/parties-form.ts
+++ b/client/parties-form/parties-form.ts
@@ -11,8 +11,8 @@ import {FORM_DIRECTIVES, Control, ControlGroup, Validators} from 'angular2/angul
 export class PartiesForm {
   constructor() {
     this.partiesForm = new ControlGroup({
-      name: new Control(''),
-      description: new Control('')
+      name: new Control('', Validators.required),
+      description: new Control('', Validators.required)
     });
   }
 }
\ No newline at end of file
-- 
2.3.5


From c51b0dccde800256e4b30808d73f1c1ee7c1d4f5 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 19:14:06 +0900
Subject: [PATCH 25/95] Step 4.8: Add ng-form-model & ng-control's to the
 parties-form template

---
 client/parties-form/parties-form.ng.html | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/client/parties-form/parties-form.ng.html b/client/parties-form/parties-form.ng.html
index c81e1cf..57ec6da 100644
--- a/client/parties-form/parties-form.ng.html
+++ b/client/parties-form/parties-form.ng.html
@@ -1,7 +1,7 @@
-<form>
+<form [ng-form-model]="partiesForm">
   <label>Name</label>
-  <input type="text">
+  <input type="text" ng-control="name">
   <label>Description</label>
-  <input type="text">
+  <input type="text" ng-control="description">
   <button>Add</button>
 </form>
\ No newline at end of file
-- 
2.3.5


From 14631e2304fca30b968677ae4a139cac61be5053 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 19:15:34 +0900
Subject: [PATCH 26/95] Step 4.9: Add local variable for form & submit event to
 parties-form template

---
 client/parties-form/parties-form.ng.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/client/parties-form/parties-form.ng.html b/client/parties-form/parties-form.ng.html
index 57ec6da..15b84df 100644
--- a/client/parties-form/parties-form.ng.html
+++ b/client/parties-form/parties-form.ng.html
@@ -1,4 +1,4 @@
-<form [ng-form-model]="partiesForm">
+<form [ng-form-model]="partiesForm" #f="form" (submit)="add(f.value)">
   <label>Name</label>
   <input type="text" ng-control="name">
   <label>Description</label>
-- 
2.3.5


From b0026b4efe602def98a8daec52c9a804006620e3 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 19:17:26 +0900
Subject: [PATCH 27/95] Step 4.10: create an add party method on the
 PartiesForm class

---
 client/parties-form/parties-form.ts | 15 +++++++++++++++
 1 file changed, 15 insertions(+)

diff --git a/client/parties-form/parties-form.ts b/client/parties-form/parties-form.ts
index 5263602..ca69373 100644
--- a/client/parties-form/parties-form.ts
+++ b/client/parties-form/parties-form.ts
@@ -15,4 +15,19 @@ export class PartiesForm {
       description: new Control('', Validators.required)
     });
   }
+  add(party) {
+    // validate if the form is valid
+    if (this.partiesForm.valid) {
+
+      // insert parties (insecure way)
+      Parties.insert({
+        name: party.name,
+        description: party.description
+      });
+
+      //reset input values to empty strings
+      this.partiesForm.controls.name.updateValue('');
+      this.partiesForm.controls.description.updateValue('');
+    }
+  }
 }
\ No newline at end of file
-- 
2.3.5


From 2cd6fd21a7303d2dda96db0a734efa3b73e8fbed Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 19:18:34 +0900
Subject: [PATCH 28/95] Step 4.11: Add a remove party button and click event to
 the parties list

---
 client/index.ng.html | 1 +
 1 file changed, 1 insertion(+)

diff --git a/client/index.ng.html b/client/index.ng.html
index 9a6b4e2..08d720a 100644
--- a/client/index.ng.html
+++ b/client/index.ng.html
@@ -6,6 +6,7 @@
     <li *ng-for="#party of parties">
       {{party.name}}
       <p>{{party.description}}</p>
+      <button (click)="remove(party)">X</button>
     </li>
   </ul>
 </div>
\ No newline at end of file
-- 
2.3.5


From 88174804ab406772afdea3e5f6b35405ac7a578d Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Sun, 23 Aug 2015 19:19:36 +0900
Subject: [PATCH 29/95] Step 4.12: Add a remove party method to the parties
 list

---
 client/app.ts | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/client/app.ts b/client/app.ts
index c6be929..57e190f 100644
--- a/client/app.ts
+++ b/client/app.ts
@@ -14,6 +14,9 @@ class Socially {
       this.parties = Parties.find().fetch();
     }));
   }
+  remove(party) {
+    Parties.remove(party._id);
+  }
 }
 
 bootstrap(Socially);
\ No newline at end of file
-- 
2.3.5


From cb99b0aea090a464dcb9d89cce3f08c269e157c1 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 3 Sep 2015 13:49:18 +0900
Subject: [PATCH 30/95] Step 5.1: Add Angular2 Router package

---
 .meteor/packages | 1 +
 1 file changed, 1 insertion(+)

diff --git a/.meteor/packages b/.meteor/packages
index 2e62fc5..3babd15 100644
--- a/.meteor/packages
+++ b/.meteor/packages
@@ -9,3 +9,4 @@ autopublish
 insecure
 shmck:angular2
 netanelgilad:angular2-typescript
+shmck:angular2-router
-- 
2.3.5


From 83ccb8a6ca9d647c1b4363a7ec458b4809d4e832 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 3 Sep 2015 13:50:12 +0900
Subject: [PATCH 31/95] update version of angular2-router

---
 .meteor/versions | 1 +
 1 file changed, 1 insertion(+)

diff --git a/.meteor/versions b/.meteor/versions
index 4960c40..9f1d2ad 100644
--- a/.meteor/versions
+++ b/.meteor/versions
@@ -39,6 +39,7 @@ retry@1.0.3
 routepolicy@1.0.5
 session@1.1.0
 shmck:angular2@2.0.6
+shmck:angular2-router@2.0.5
 spacebars@1.0.6
 spacebars-compiler@1.0.6
 templating@1.1.1
-- 
2.3.5


From dc4c3f27a6c185bc6b45e3ab2552dde431160050 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 3 Sep 2015 13:51:27 +0900
Subject: [PATCH 32/95] Step 5.2: Import Router dependencies, add them to View
 directives, and init RouteConfig

---
 client/app.ts | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)

diff --git a/client/app.ts b/client/app.ts
index 57e190f..ad04f9b 100644
--- a/client/app.ts
+++ b/client/app.ts
@@ -1,4 +1,5 @@
 import {Component, View, NgFor, bootstrap} from 'angular2/angular2';
+import {ROUTER_BINDINGS, ROUTER_DIRECTIVES, RouteConfig} from 'angular2/router';
 import {PartiesForm} from 'client/parties-form/parties-form';
 
 @Component({
@@ -6,8 +7,9 @@ import {PartiesForm} from 'client/parties-form/parties-form';
 })
 @View({
   templateUrl: 'client/index.ng.html',
-  directives: [NgFor, PartiesForm]
+  directives: [NgFor, PartiesForm, ROUTER_DIRECTIVES]
 })
+@RouteConfig()
 class Socially {
   constructor () {
     Tracker.autorun(zone.bind(() => {
@@ -19,4 +21,4 @@ class Socially {
   }
 }
 
-bootstrap(Socially);
\ No newline at end of file
+bootstrap(Socially, [ROUTER_BINDINGS]);
\ No newline at end of file
-- 
2.3.5


From 9009438a62702894ade3dc8a94f213e8134cf99b Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 08:37:04 +0900
Subject: [PATCH 33/95] Step 5.3: Add base href

---
 client/index.html | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/client/index.html b/client/index.html
index b3cd76e..9956097 100644
--- a/client/index.html
+++ b/client/index.html
@@ -1,3 +1,6 @@
+<head>
+  <base href="/">
+</head>
 <body>
   <app></app>
   <script>System.import("client/app");</script>
-- 
2.3.5


From 94f1920b373f18a364b30c584655a5ad2beaeb46 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 08:39:15 +0900
Subject: [PATCH 34/95] Step 5.4: Move root app into a parties-list component

---
 client/app.ts                       | 11 +----------
 client/parties-list/parties-list.ts | 20 ++++++++++++++++++++
 2 files changed, 21 insertions(+), 10 deletions(-)
 create mode 100644 client/parties-list/parties-list.ts

diff --git a/client/app.ts b/client/app.ts
index ad04f9b..5f07ea7 100644
--- a/client/app.ts
+++ b/client/app.ts
@@ -10,15 +10,6 @@ import {PartiesForm} from 'client/parties-form/parties-form';
   directives: [NgFor, PartiesForm, ROUTER_DIRECTIVES]
 })
 @RouteConfig()
-class Socially {
-  constructor () {
-    Tracker.autorun(zone.bind(() => {
-      this.parties = Parties.find().fetch();
-    }));
-  }
-  remove(party) {
-    Parties.remove(party._id);
-  }
-}
+class Socially {}
 
 bootstrap(Socially, [ROUTER_BINDINGS]);
\ No newline at end of file
diff --git a/client/parties-list/parties-list.ts b/client/parties-list/parties-list.ts
new file mode 100644
index 0000000..87a5c7c
--- /dev/null
+++ b/client/parties-list/parties-list.ts
@@ -0,0 +1,20 @@
+import {Component, View, NgFor, bootstrap} from 'angular2/angular2';
+import {PartiesForm} from 'client/parties-form/parties-form';
+
+@Component({
+  selector: 'parties-list'
+})
+@View({
+  templateUrl: 'client/parties-list/parties-list.ng.html',
+  directives: [NgFor, PartiesForm]
+})
+export class PartiesList {
+  constructor () {
+    Tracker.autorun(zone.bind(() => {
+      this.parties = Parties.find().fetch();
+    }));
+  }
+  remove(party) {
+    Parties.remove(party._id);
+  }
+}
\ No newline at end of file
-- 
2.3.5


From 2004897df21b1a2fad2cb4b5d74325fb8c83683c Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 3 Sep 2015 14:32:52 +0900
Subject: [PATCH 35/95] Step 5.6: Move index.ng.html into parties-list.ng.html

---
 client/parties-list/parties-list.ng.html | 12 ++++++++++++
 1 file changed, 12 insertions(+)
 create mode 100644 client/parties-list/parties-list.ng.html

diff --git a/client/parties-list/parties-list.ng.html b/client/parties-list/parties-list.ng.html
new file mode 100644
index 0000000..08d720a
--- /dev/null
+++ b/client/parties-list/parties-list.ng.html
@@ -0,0 +1,12 @@
+<div>
+
+  <parties-form></parties-form>
+
+  <ul>
+    <li *ng-for="#party of parties">
+      {{party.name}}
+      <p>{{party.description}}</p>
+      <button (click)="remove(party)">X</button>
+    </li>
+  </ul>
+</div>
\ No newline at end of file
-- 
2.3.5


From a075446dfce48eaad06a3977b02b91c05dc2836a Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 3 Sep 2015 14:33:21 +0900
Subject: [PATCH 36/95] Step 5.7: Cleanup index.ng.html

---
 client/index.ng.html | 12 ------------
 1 file changed, 12 deletions(-)
 delete mode 100644 client/index.ng.html

diff --git a/client/index.ng.html b/client/index.ng.html
deleted file mode 100644
index 08d720a..0000000
--- a/client/index.ng.html
+++ /dev/null
@@ -1,12 +0,0 @@
-<div>
-
-  <parties-form></parties-form>
-
-  <ul>
-    <li *ng-for="#party of parties">
-      {{party.name}}
-      <p>{{party.description}}</p>
-      <button (click)="remove(party)">X</button>
-    </li>
-  </ul>
-</div>
\ No newline at end of file
-- 
2.3.5


From adab17b1db2472555341a9badc5f0db545e6100c Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 08:49:20 +0900
Subject: [PATCH 37/95] Step 5.8: Create PartyDetails component

---
 client/party-details/party-details.ts | 9 +++++++++
 1 file changed, 9 insertions(+)
 create mode 100644 client/party-details/party-details.ts

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
new file mode 100644
index 0000000..d0f37b5
--- /dev/null
+++ b/client/party-details/party-details.ts
@@ -0,0 +1,9 @@
+import {Component, View} from 'angular2/angular2';
+
+@Component({
+  selector: 'party-details'
+})
+@View({
+  templateUrl: 'client/party-details/party-details.ng.html'
+})
+export class PartyDetails {}
\ No newline at end of file
-- 
2.3.5


From 568883bfa993f220128e292a0a42b5d646942592 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 08:50:35 +0900
Subject: [PATCH 38/95] Step 5.9: Add party-details template with placeholder
 info

---
 client/party-details/party-details.ng.html | 5 +++++
 1 file changed, 5 insertions(+)
 create mode 100644 client/party-details/party-details.ng.html

diff --git a/client/party-details/party-details.ng.html b/client/party-details/party-details.ng.html
new file mode 100644
index 0000000..f36ae3c
--- /dev/null
+++ b/client/party-details/party-details.ng.html
@@ -0,0 +1,5 @@
+<header>
+  <h2>NAME</h2>
+
+  <p>DESCRIPTION</p>
+</header>
\ No newline at end of file
-- 
2.3.5


From 8a91807326bbf3239e92e0f5881de37da5b69c17 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 09:03:27 +0900
Subject: [PATCH 39/95] Step 5.10: Configure routes in app.ts

---
 client/app.ts | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/client/app.ts b/client/app.ts
index 5f07ea7..433d202 100644
--- a/client/app.ts
+++ b/client/app.ts
@@ -2,6 +2,10 @@ import {Component, View, NgFor, bootstrap} from 'angular2/angular2';
 import {ROUTER_BINDINGS, ROUTER_DIRECTIVES, RouteConfig} from 'angular2/router';
 import {PartiesForm} from 'client/parties-form/parties-form';
 
+// Components
+import {PartiesList} from 'client/parties-list/parties-list';
+import {PartyDetails} from 'client/party-details/party-details';
+
 @Component({
   selector: 'app'
 })
@@ -9,7 +13,11 @@ import {PartiesForm} from 'client/parties-form/parties-form';
   templateUrl: 'client/index.ng.html',
   directives: [NgFor, PartiesForm, ROUTER_DIRECTIVES]
 })
-@RouteConfig()
+@RouteConfig([
+  {path: '/', redirectTo: '/parties'},
+  {path: '/parties',  as: 'parties-list', component: PartiesList},
+  {path: '/party/:partyId', as: 'party-details', component: PartyDetails}
+])
 class Socially {}
 
 bootstrap(Socially, [ROUTER_BINDINGS]);
\ No newline at end of file
-- 
2.3.5


From 830ee2fad8ce61582882c3654d619a83da60f937 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 3 Sep 2015 14:34:58 +0900
Subject: [PATCH 40/95] Step 5.11: Create parties-list template

---
 client/parties-list/parties-list.ng.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/client/parties-list/parties-list.ng.html b/client/parties-list/parties-list.ng.html
index 08d720a..13693eb 100644
--- a/client/parties-list/parties-list.ng.html
+++ b/client/parties-list/parties-list.ng.html
@@ -4,7 +4,7 @@
 
   <ul>
     <li *ng-for="#party of parties">
-      {{party.name}}
+      <a [router-link]="['/party-details', {partyId: party._id}]">{{party.name}}</a>
       <p>{{party.description}}</p>
       <button (click)="remove(party)">X</button>
     </li>
-- 
2.3.5


From 21417a1da648d83d78df490e72fe4b460253d3be Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 3 Sep 2015 14:35:44 +0900
Subject: [PATCH 41/95] Step 5.12: create parties-list component

---
 client/parties-list/parties-list.ts | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/client/parties-list/parties-list.ts b/client/parties-list/parties-list.ts
index 87a5c7c..81cebec 100644
--- a/client/parties-list/parties-list.ts
+++ b/client/parties-list/parties-list.ts
@@ -1,4 +1,5 @@
 import {Component, View, NgFor, bootstrap} from 'angular2/angular2';
+import {RouterLink} from 'angular2/router';
 import {PartiesForm} from 'client/parties-form/parties-form';
 
 @Component({
@@ -6,7 +7,7 @@ import {PartiesForm} from 'client/parties-form/parties-form';
 })
 @View({
   templateUrl: 'client/parties-list/parties-list.ng.html',
-  directives: [NgFor, PartiesForm]
+  directives: [NgFor, PartiesForm, RouterLink]
 })
 export class PartiesList {
   constructor () {
-- 
2.3.5


From 8587aa94983d779d10f998f2479c9742478852e4 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 09:23:41 +0900
Subject: [PATCH 42/95] Step 5.13: Create dynamic party name & description
 bindings

---
 client/party-details/party-details.ng.html | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/client/party-details/party-details.ng.html b/client/party-details/party-details.ng.html
index f36ae3c..9e3ead7 100644
--- a/client/party-details/party-details.ng.html
+++ b/client/party-details/party-details.ng.html
@@ -1,5 +1,5 @@
 <header>
-  <h2>NAME</h2>
+  <h2>{{party.name}}</h2>
 
-  <p>DESCRIPTION</p>
+  <p>{{party.description}}</p>
 </header>
\ No newline at end of file
-- 
2.3.5


From 50c908d903804857d562c38bd9f03bd2e63b6004 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 09:25:06 +0900
Subject: [PATCH 43/95] Step 5.14: Import RouteParams & Inject, catch specific
 party data

---
 client/party-details/party-details.ts | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index d0f37b5..a580f03 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -1,4 +1,5 @@
-import {Component, View} from 'angular2/angular2';
+import {Component, View, Inject} from 'angular2/angular2';
+import {RouteParams} from 'angular2/router';
 
 @Component({
   selector: 'party-details'
@@ -6,4 +7,12 @@ import {Component, View} from 'angular2/angular2';
 @View({
   templateUrl: 'client/party-details/party-details.ng.html'
 })
-export class PartyDetails {}
\ No newline at end of file
+export class PartyDetails {
+  constructor(@Inject(RouteParams) routeParams:RouteParams) {
+    this.partyId = routeParams.params.partyId;
+
+    Tracker.autorun(zone.bind(() => {
+      this.party = Parties.find(this.partyId).fetch()[0];
+    }));
+  }
+}
\ No newline at end of file
-- 
2.3.5


From 7c68ac7977161c270554a36de237f9d542730814 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 09:38:17 +0900
Subject: [PATCH 44/95] Step 5.15: Challenge -- create a link back to the
 parties-list from party-details

---
 client/party-details/party-details.ng.html | 2 ++
 client/party-details/party-details.ts      | 5 +++--
 2 files changed, 5 insertions(+), 2 deletions(-)

diff --git a/client/party-details/party-details.ng.html b/client/party-details/party-details.ng.html
index 9e3ead7..999312d 100644
--- a/client/party-details/party-details.ng.html
+++ b/client/party-details/party-details.ng.html
@@ -2,4 +2,6 @@
   <h2>{{party.name}}</h2>
 
   <p>{{party.description}}</p>
+
+  <a [router-link]="['/parties-list']">Back</a>
 </header>
\ No newline at end of file
diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index a580f03..f6828cd 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -1,11 +1,12 @@
 import {Component, View, Inject} from 'angular2/angular2';
-import {RouteParams} from 'angular2/router';
+import {RouteParams, RouterLink} from 'angular2/router';
 
 @Component({
   selector: 'party-details'
 })
 @View({
-  templateUrl: 'client/party-details/party-details.ng.html'
+  templateUrl: 'client/party-details/party-details.ng.html',
+  directives: [RouterLink]
 })
 export class PartyDetails {
   constructor(@Inject(RouteParams) routeParams:RouteParams) {
-- 
2.3.5


From 3751401f25dafd422173a57d6c6323e7d84e2bfe Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 09:45:19 +0900
Subject: [PATCH 45/95] Step 6.1: Use the router hook onActivate to load
 PartyDetails data

---
 client/party-details/party-details.ts | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index f6828cd..b16fe33 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -11,9 +11,11 @@ import {RouteParams, RouterLink} from 'angular2/router';
 export class PartyDetails {
   constructor(@Inject(RouteParams) routeParams:RouteParams) {
     this.partyId = routeParams.params.partyId;
-
-    Tracker.autorun(zone.bind(() => {
-      this.party = Parties.find(this.partyId).fetch()[0];
-    }));
+  }
+  onActivate() {
+    this.party = Parties.find(this.partyId).fetch()[0];
+    if (this.party) {
+      return true;
+    }
   }
 }
\ No newline at end of file
-- 
2.3.5


From 67cff233b1bfbfd70fef91a0e6039d962ce15ce4 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 09:48:54 +0900
Subject: [PATCH 46/95] Step 6.2: Change party-details.ng.html to a form

---
 client/party-details/party-details.ng.html | 14 +++++++++-----
 1 file changed, 9 insertions(+), 5 deletions(-)

diff --git a/client/party-details/party-details.ng.html b/client/party-details/party-details.ng.html
index 999312d..baecbbe 100644
--- a/client/party-details/party-details.ng.html
+++ b/client/party-details/party-details.ng.html
@@ -1,7 +1,11 @@
-<header>
-  <h2>{{party.name}}</h2>
+<form>
+  <label>Name</label>
+  <input type="text">
 
-  <p>{{party.description}}</p>
+  <label>Description</label>
+  <input type="text">
 
-  <a [router-link]="['/parties-list']">Back</a>
-</header>
\ No newline at end of file
+  <button type="submit">Save</button>
+  <button>Reset form</button>
+  <button [router-link]="['/parties-list']">Cancel</button>
+</form>
\ No newline at end of file
-- 
2.3.5


From ab716c0459023cd5e04ca8cb8b4ed65d2fd3be14 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 09:50:38 +0900
Subject: [PATCH 47/95] Step 6.3: import FORM_DIRECTIVES into party-details and
 add it to the directive view

---
 client/party-details/party-details.ts | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index b16fe33..4d3c7d3 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -1,12 +1,13 @@
 import {Component, View, Inject} from 'angular2/angular2';
 import {RouteParams, RouterLink} from 'angular2/router';
+import {FORM_DIRECTIVES} from 'angular2/angular2';
 
 @Component({
   selector: 'party-details'
 })
 @View({
   templateUrl: 'client/party-details/party-details.ng.html',
-  directives: [RouterLink]
+  directives: [RouterLink, FORM_DIRECTIVES]
 })
 export class PartyDetails {
   constructor(@Inject(RouteParams) routeParams:RouteParams) {
-- 
2.3.5


From 8cb39c1f81b06740c7e01f0d3296f70227a4f4bc Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 09:53:06 +0900
Subject: [PATCH 48/95] Step 6.4: Use ng-model in our party-details form

---
 client/party-details/party-details.ng.html | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/client/party-details/party-details.ng.html b/client/party-details/party-details.ng.html
index baecbbe..82c782f 100644
--- a/client/party-details/party-details.ng.html
+++ b/client/party-details/party-details.ng.html
@@ -1,9 +1,9 @@
 <form>
   <label>Name</label>
-  <input type="text">
+  <input type="text" [(ng-model)]="party.name">
 
   <label>Description</label>
-  <input type="text">
+  <input type="text" [(ng-model)]="party.description">
 
   <button type="submit">Save</button>
   <button>Reset form</button>
-- 
2.3.5


From 8e1e278b4ea77bf04068bcd660f1297bd1a14e13 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 3 Sep 2015 21:14:55 +0900
Subject: [PATCH 49/95] Step 6.5: Save party-details on submit from template

---
 client/party-details/party-details.ng.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/client/party-details/party-details.ng.html b/client/party-details/party-details.ng.html
index 82c782f..4d74675 100644
--- a/client/party-details/party-details.ng.html
+++ b/client/party-details/party-details.ng.html
@@ -1,4 +1,4 @@
-<form>
+<form (submit)="save($event)">
   <label>Name</label>
   <input type="text" [(ng-model)]="party.name">
 
-- 
2.3.5


From 333a709ec0bd5a70300e599124c9e63d4232912f Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 3 Sep 2015 21:15:15 +0900
Subject: [PATCH 50/95] Step 6.6: Save party-details on submit from component,
 update db

---
 client/party-details/party-details.ts | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index 4d3c7d3..5d8007d 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -13,6 +13,15 @@ export class PartyDetails {
   constructor(@Inject(RouteParams) routeParams:RouteParams) {
     this.partyId = routeParams.params.partyId;
   }
+  save(event) {
+    event.preventDefault();
+    var party = this.party;
+
+    Parties.update(party._id, {
+        name: party.name,
+        description: party.description
+    });
+  }
   onActivate() {
     this.party = Parties.find(this.partyId).fetch()[0];
     if (this.party) {
-- 
2.3.5


From 175fdae0629eae29d683ccd74f78da254851d21b Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 10:16:52 +0900
Subject: [PATCH 51/95] Step 6.7: Validateparty fields to be strings with at
 least one character before saving

---
 client/party-details/party-details.ts | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index 5d8007d..3e80ee0 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -17,10 +17,13 @@ export class PartyDetails {
     event.preventDefault();
     var party = this.party;
 
-    Parties.update(party._id, {
+    if (_.isString(party.name) && party.name.length &&
+      _.isString(party.description) && party.description.length) {
+      Parties.update(party._id, {
         name: party.name,
         description: party.description
-    });
+      });
+    }
   }
   onActivate() {
     this.party = Parties.find(this.partyId).fetch()[0];
-- 
2.3.5


From d0cf5e3305591cbc8987876c254dbef16dc5ebf6 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 3 Sep 2015 21:16:30 +0900
Subject: [PATCH 52/95] Step 6.8: form reset button

---
 client/party-details/party-details.ng.html | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/client/party-details/party-details.ng.html b/client/party-details/party-details.ng.html
index 4d74675..ae6bfb6 100644
--- a/client/party-details/party-details.ng.html
+++ b/client/party-details/party-details.ng.html
@@ -6,6 +6,6 @@
   <input type="text" [(ng-model)]="party.description">
 
   <button type="submit">Save</button>
-  <button>Reset form</button>
+  <button (click)="reset($event)">Reset form</button>
   <button [router-link]="['/parties-list']">Cancel</button>
 </form>
\ No newline at end of file
-- 
2.3.5


From 3109a25837d65ee3947f4b086c2edd9afce5de3f Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 3 Sep 2015 21:16:51 +0900
Subject: [PATCH 53/95] Step 6.9: reset button triggers earlier saved state

---
 client/party-details/party-details.ts | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index 3e80ee0..55215a3 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -23,11 +23,18 @@ export class PartyDetails {
         name: party.name,
         description: party.description
       });
+      this.resetToParty = _.clone(party);
     }
   }
+  reset(event) {
+    event.preventDefault();
+    this.party = this.resetToParty;
+  }
   onActivate() {
     this.party = Parties.find(this.partyId).fetch()[0];
     if (this.party) {
+      console.log('loading...');
+      this.resetToParty = _.clone(this.party);
       return true;
     }
   }
-- 
2.3.5


From 23e89b842acce29d48a29399694a66e257611029 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 10:28:00 +0900
Subject: [PATCH 54/95] Step 6.10: use router canDeactivate hook to check if a
 user wants to leave without saving

---
 client/party-details/party-details.ts | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index 55215a3..a1bfe0a 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -38,4 +38,9 @@ export class PartyDetails {
       return true;
     }
   }
+  canDeactivate() {
+    if (!_.isEqual(this.party, this.resetToParty)) {
+      return confirm('Are you sure you want to leave without saving?');
+    }
+  }
 }
\ No newline at end of file
-- 
2.3.5


From f0d08ec487e2e895c2eb3f7fff06bffca2021de5 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 13:16:41 +0900
Subject: [PATCH 55/95] Step 7.1: Specified partyId string type

---
 client/party-details/party-details.ts | 1 +
 1 file changed, 1 insertion(+)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index a1bfe0a..c7ea24b 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -10,6 +10,7 @@ import {FORM_DIRECTIVES} from 'angular2/angular2';
   directives: [RouterLink, FORM_DIRECTIVES]
 })
 export class PartyDetails {
+  partyId: string;
   constructor(@Inject(RouteParams) routeParams:RouteParams) {
     this.partyId = routeParams.params.partyId;
   }
-- 
2.3.5


From f581dc5258b697bc15a3fd450dd69fb3df55c611 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 13:18:05 +0900
Subject: [PATCH 56/95] Step 7.2: Declared IParty interface

---
 typings/socially/socially.d.ts | 5 +++++
 1 file changed, 5 insertions(+)
 create mode 100644 typings/socially/socially.d.ts

diff --git a/typings/socially/socially.d.ts b/typings/socially/socially.d.ts
new file mode 100644
index 0000000..98cd875
--- /dev/null
+++ b/typings/socially/socially.d.ts
@@ -0,0 +1,5 @@
+interface IParty {
+  _id?: string;
+  name: string;
+  description: string;
+}
\ No newline at end of file
-- 
2.3.5


From ee0bba3621162fc2c744997bd73034126fdf2b73 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 13:19:42 +0900
Subject: [PATCH 57/95] Step 7.3: use IParty type in PartyDetails

---
 client/party-details/party-details.ts | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index c7ea24b..e641735 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -11,6 +11,8 @@ import {FORM_DIRECTIVES} from 'angular2/angular2';
 })
 export class PartyDetails {
   partyId: string;
+  party: IParty;
+  resetToParty: IParty;
   constructor(@Inject(RouteParams) routeParams:RouteParams) {
     this.partyId = routeParams.params.partyId;
   }
-- 
2.3.5


From e7c320fe5eec83b3d9ac4fd2b67080fcd0b12d0e Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 13:21:19 +0900
Subject: [PATCH 58/95] Step 7.4: Added type of IParty array to parties in
 PartiesList

---
 client/parties-list/parties-list.ts | 1 +
 1 file changed, 1 insertion(+)

diff --git a/client/parties-list/parties-list.ts b/client/parties-list/parties-list.ts
index 81cebec..c80ee8c 100644
--- a/client/parties-list/parties-list.ts
+++ b/client/parties-list/parties-list.ts
@@ -10,6 +10,7 @@ import {PartiesForm} from 'client/parties-form/parties-form';
   directives: [NgFor, PartiesForm, RouterLink]
 })
 export class PartiesList {
+  parties: IParty[];
   constructor () {
     Tracker.autorun(zone.bind(() => {
       this.parties = Parties.find().fetch();
-- 
2.3.5


From afddeb15d56a8f96b626bc768b9d43272054b137 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 13:23:35 +0900
Subject: [PATCH 59/95] Step 7.5: Declared IParty array type of parties in
 loadParties.ts

---
 server/loadParties.ts | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/loadParties.ts b/server/loadParties.ts
index a2a6e3d..9dd05e7 100644
--- a/server/loadParties.ts
+++ b/server/loadParties.ts
@@ -1,7 +1,7 @@
 Meteor.startup(function () {
   if (Parties.find().count() === 0) {
 
-    var parties = [
+    var parties:IParty[] = [
       {'name': 'Dubstep-Free Zone',
         'description': 'Can we please just for an evening not listen to dubstep.'},
       {'name': 'All dubstep all the time',
-- 
2.3.5


From a52aab820b552071d03ac50991f6d33ed4fe671c Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 13:24:53 +0900
Subject: [PATCH 60/95] Step 7.6: declare var Parties in socially.d.ts

---
 typings/socially/socially.d.ts | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/typings/socially/socially.d.ts b/typings/socially/socially.d.ts
index 98cd875..a01ea81 100644
--- a/typings/socially/socially.d.ts
+++ b/typings/socially/socially.d.ts
@@ -1,3 +1,5 @@
+declare var Parties;
+
 interface IParty {
   _id?: string;
   name: string;
-- 
2.3.5


From 039d4bcbecfe74ae13bafb0fbe64466fd7839d7c Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 13:26:53 +0900
Subject: [PATCH 61/95] Step 7.7: tsd install angular2 meteor

---
 typings/angular2/angular2.d.ts       | 6043 ++++++++++++++++++++++++++++++++++
 typings/es6-promise/es6-promise.d.ts |   73 +
 typings/meteor/meteor.d.ts           |  781 +++++
 typings/rx/rx-lite.d.ts              |  647 ++++
 typings/rx/rx.d.ts                   |   67 +
 5 files changed, 7611 insertions(+)
 create mode 100644 typings/angular2/angular2.d.ts
 create mode 100644 typings/es6-promise/es6-promise.d.ts
 create mode 100644 typings/meteor/meteor.d.ts
 create mode 100644 typings/rx/rx-lite.d.ts
 create mode 100644 typings/rx/rx.d.ts

diff --git a/typings/angular2/angular2.d.ts b/typings/angular2/angular2.d.ts
new file mode 100644
index 0000000..ff56616
--- /dev/null
+++ b/typings/angular2/angular2.d.ts
@@ -0,0 +1,6043 @@
+// Type definitions for Angular v2.0.0-alpha.32
+// Project: http://angular.io/
+// Definitions by: angular team <https://github.com/angular/>
+// Definitions: https://github.com/borisyankov/DefinitelyTyped
+
+// ***********************************************************
+// This file is generated by the Angular build process.
+// Please do not create manual edits or send pull requests
+// modifying this file.
+// ***********************************************************
+
+// Angular depends transitively on these libraries.
+// If you don't have them installed you can run
+// $ tsd query es6-promise rx rx-lite --action install --save
+///<reference path="../es6-promise/es6-promise.d.ts"/>
+///<reference path="../rx/rx.d.ts"/>
+
+interface List<T> extends Array<T> {}
+interface Map<K,V> {}
+interface StringMap<K,V> extends Map<K,V> {}
+
+declare module ng {
+  type SetterFn = typeof Function;
+  type int = number;
+  interface Type extends Function {
+    new (...args: any[]): any;
+  }
+
+  // See https://github.com/Microsoft/TypeScript/issues/1168
+  class BaseException /* extends Error */ {
+    message: string;
+    stack: string;
+    toString(): string;
+  }
+  interface InjectableReference {}
+}
+
+
+
+
+/**
+ * The `angular2` is the single place to import all of the individual types.
+ */
+declare module ng {
+
+  /**
+   * Bootstrapping for Angular applications.
+   * 
+   * You instantiate an Angular application by explicitly specifying a component to use as the root
+   * component for your
+   * application via the `bootstrap()` method.
+   * 
+   * ## Simple Example
+   * 
+   * Assuming this `index.html`:
+   * 
+   * ```html
+   * <html>
+   *   <!-- load Angular script tags here. -->
+   *   <body>
+   *     <my-app>loading...</my-app>
+   *   </body>
+   * </html>
+   * ```
+   * 
+   * An application is bootstrapped inside an existing browser DOM, typically `index.html`. Unlike
+   * Angular 1, Angular 2
+   * does not compile/process bindings in `index.html`. This is mainly for security reasons, as well
+   * as architectural
+   * changes in Angular 2. This means that `index.html` can safely be processed using server-side
+   * technologies such as
+   * bindings. Bindings can thus use double-curly `{{ syntax }}` without collision from Angular 2
+   * component double-curly
+   * `{{ syntax }}`.
+   * 
+   * We can use this script code:
+   * 
+   * ```
+   * @Component({
+   *    selector: 'my-app'
+   * })
+   * @View({
+   *    template: 'Hello {{ name }}!'
+   * })
+   * class MyApp {
+   *   name:string;
+   * 
+   *   constructor() {
+   *     this.name = 'World';
+   *   }
+   * }
+   * 
+   * main() {
+   *   return bootstrap(MyApp);
+   * }
+   * ```
+   * 
+   * When the app developer invokes `bootstrap()` with the root component `MyApp` as its argument,
+   * Angular performs the
+   * following tasks:
+   * 
+   *  1. It uses the component's `selector` property to locate the DOM element which needs to be
+   * upgraded into
+   *     the angular component.
+   *  2. It creates a new child injector (from the platform injector). Optionally, you can also
+   * override the injector configuration for an app by
+   * invoking `bootstrap` with the `componentInjectableBindings` argument.
+   *  3. It creates a new `Zone` and connects it to the angular application's change detection domain
+   * instance.
+   *  4. It creates a shadow DOM on the selected component's host element and loads the template into
+   * it.
+   *  5. It instantiates the specified component.
+   *  6. Finally, Angular performs change detection to apply the initial data bindings for the
+   * application.
+   * 
+   * 
+   * ## Instantiating Multiple Applications on a Single Page
+   * 
+   * There are two ways to do this.
+   * 
+   * 
+   * ### Isolated Applications
+   * 
+   * Angular creates a new application each time that the `bootstrap()` method is invoked. When
+   * multiple applications
+   * are created for a page, Angular treats each application as independent within an isolated change
+   * detection and
+   * `Zone` domain. If you need to share data between applications, use the strategy described in the
+   * next
+   * section, "Applications That Share Change Detection."
+   * 
+   * 
+   * ### Applications That Share Change Detection
+   * 
+   * If you need to bootstrap multiple applications that share common data, the applications must
+   * share a common
+   * change detection and zone. To do that, create a meta-component that lists the application
+   * components in its template.
+   * By only invoking the `bootstrap()` method once, with the meta-component as its argument, you
+   * ensure that only a
+   * single change detection zone is created and therefore data can be shared across the applications.
+   * 
+   * 
+   * ## Platform Injector
+   * 
+   * When working within a browser window, there are many singleton resources: cookies, title,
+   * location, and others.
+   * Angular services that represent these resources must likewise be shared across all Angular
+   * applications that
+   * occupy the same browser window.  For this reason, Angular creates exactly one global platform
+   * injector which stores
+   * all shared services, and each angular application injector has the platform injector as its
+   * parent.
+   * 
+   * Each application has its own private injector as well. When there are multiple applications on a
+   * page, Angular treats
+   * each application injector's services as private to that application.
+   * 
+   * 
+   * # API
+   * - `appComponentType`: The root component which should act as the application. This is a reference
+   * to a `Type`
+   *   which is annotated with `@Component(...)`.
+   * - `componentInjectableBindings`: An additional set of bindings that can be added to the app
+   * injector
+   * to override default injection behavior.
+   * - `errorReporter`: `function(exception:any, stackTrace:string)` a default error reporter for
+   * unhandled exceptions.
+   * 
+   * Returns a `Promise` of {@link ApplicationRef}.
+   */
+  function bootstrap(appComponentType: /*Type*/ any, componentInjectableBindings?: List<Type | Binding | List<any>>) : Promise<ApplicationRef> ;
+  
+  class DehydratedException extends BaseException {
+  }
+  
+  class ExpressionChangedAfterItHasBeenChecked extends BaseException {
+  }
+  
+  class ChangeDetectionError extends BaseException {
+    
+     location: string;
+  }
+  
+
+  /**
+   * ON_PUSH means that the change detector's mode will be set to CHECK_ONCE during hydration.
+   */
+  const ON_PUSH : string ;
+  
+
+  /**
+   * DEFAULT means that the change detector's mode will be set to CHECK_ALWAYS during hydration.
+   */
+  const DEFAULT : string ;
+  
+
+  /**
+   * Controls change detection.
+   * 
+   * {@link ChangeDetectorRef} allows requesting checks for detectors that rely on observables. It
+   * also allows detaching and
+   * attaching change detector subtrees.
+   */
+  class ChangeDetectorRef {
+    
+
+    /**
+     * Request to check all ON_PUSH ancestors.
+     */
+     requestCheck(): void;
+    
+
+    /**
+     * Detaches the change detector from the change detector tree.
+     * 
+     * The detached change detector will not be checked until it is reattached.
+     */
+     detach(): void;
+    
+
+    /**
+     * Reattach the change detector to the change detector tree.
+     * 
+     * This also requests a check of this change detector. This reattached change detector will be
+     * checked during the
+     * next change detection run.
+     */
+     reattach(): void;
+  }
+  
+  class Pipes {
+    
+
+    /**
+     * Map of {@link Pipe} names to {@link PipeFactory} lists used to configure the
+     * {@link Pipes} registry.
+     * 
+     * #Example
+     * 
+     * ```
+     * var pipesConfig = {
+     *   'json': [jsonPipeFactory]
+     * }
+     * @Component({
+     *   viewInjector: [
+     *     bind(Pipes).toValue(new Pipes(pipesConfig))
+     *   ]
+     * })
+     * ```
+     */
+     config: StringMap<string, PipeFactory[]>;
+    
+     get(type: string, obj: any, cdRef?: ChangeDetectorRef, existingPipe?: Pipe): Pipe;
+  }
+  
+
+  /**
+   * Indicates that the result of a {@link Pipe} transformation has changed even though the reference
+   * has not changed.
+   * 
+   * The wrapped value will be unwrapped by change detection, and the unwrapped value will be stored.
+   */
+  class WrappedValue {
+    
+     wrapped: any;
+  }
+  
+
+  /**
+   * An interface for extending the list of pipes known to Angular.
+   * 
+   * If you are writing a custom {@link Pipe}, you must extend this interface.
+   * 
+   * #Example
+   * 
+   * ```
+   * class DoublePipe implements Pipe {
+   *  supports(obj) {
+   *    return true;
+   *  }
+   * 
+   *  onDestroy() {}
+   * 
+   *  transform(value, args = []) {
+   *    return `${value}${value}`;
+   *  }
+   * }
+   * ```
+   */
+  interface Pipe {
+    
+     supports(obj: any): boolean;
+    
+     onDestroy(): void;
+    
+     transform(value: any, args: List<any>): any;
+  }
+  
+  interface PipeFactory {
+    
+     supports(obs: any): boolean;
+    
+     create(cdRef: ChangeDetectorRef): Pipe;
+  }
+  
+  class NullPipe extends BasePipe {
+    
+     called: boolean;
+    
+     supports(obj: any): boolean;
+    
+     transform(value: any, args?: List<any>): WrappedValue;
+  }
+  
+  class NullPipeFactory implements PipeFactory {
+    
+     supports(obj: any): boolean;
+    
+     create(cdRef: ChangeDetectorRef): Pipe;
+  }
+  
+  const defaultPipes : Pipes ;
+  
+
+  /**
+   * Provides default implementation of supports and onDestroy.
+   * 
+   * #Example
+   * 
+   * ```
+   * class DoublePipe extends BasePipe {*
+   *  transform(value) {
+   *    return `${value}${value}`;
+   *  }
+   * }
+   * ```
+   */
+  class BasePipe implements Pipe {
+    
+     supports(obj: any): boolean;
+    
+     onDestroy(): void;
+    
+     transform(value: any, args: List<any>): any;
+  }
+  
+  class Locals {
+    
+     parent: Locals;
+    
+     current: Map<any, any>;
+    
+     contains(name: string): boolean;
+    
+     get(name: string): any;
+    
+     set(name: string, value: any): void;
+    
+     clearValues(): void;
+  }
+  
+
+  /**
+   * A dispatcher for all events happening in a view.
+   */
+  interface RenderEventDispatcher {
+    
+
+    /**
+     * Called when an event was triggered for a on-* attribute on an element.
+     * @param {Map<string, any>} locals Locals to be used to evaluate the
+     *   event expressions
+     */
+     dispatchRenderEvent(elementIndex: number, eventName: string, locals: Map<string, any>): void;
+  }
+  
+  class Renderer {
+    
+
+    /**
+     * Creates a root host view that includes the given element.
+     * Note that the fragmentCount needs to be passed in so that we can create a result
+     * synchronously even when dealing with webworkers!
+     * 
+     * @param {RenderProtoViewRef} hostProtoViewRef a RenderProtoViewRef of type
+     * ProtoViewDto.HOST_VIEW_TYPE
+     * @param {any} hostElementSelector css selector for the host element (will be queried against the
+     * main document)
+     * @return {RenderViewWithFragments} the created view including fragments
+     */
+     createRootHostView(hostProtoViewRef: RenderProtoViewRef, fragmentCount: number, hostElementSelector: string): RenderViewWithFragments;
+    
+
+    /**
+     * Creates a regular view out of the given ProtoView.
+     * Note that the fragmentCount needs to be passed in so that we can create a result
+     * synchronously even when dealing with webworkers!
+     */
+     createView(protoViewRef: RenderProtoViewRef, fragmentCount: number): RenderViewWithFragments;
+    
+
+    /**
+     * Destroys the given view after it has been dehydrated and detached
+     */
+     destroyView(viewRef: RenderViewRef): void;
+    
+
+    /**
+     * Attaches a fragment after another fragment.
+     */
+     attachFragmentAfterFragment(previousFragmentRef: RenderFragmentRef, fragmentRef: RenderFragmentRef): void;
+    
+
+    /**
+     * Attaches a fragment after an element.
+     */
+     attachFragmentAfterElement(elementRef: RenderElementRef, fragmentRef: RenderFragmentRef): void;
+    
+
+    /**
+     * Detaches a fragment.
+     */
+     detachFragment(fragmentRef: RenderFragmentRef): void;
+    
+
+    /**
+     * Hydrates a view after it has been attached. Hydration/dehydration is used for reusing views
+     * inside of the view pool.
+     */
+     hydrateView(viewRef: RenderViewRef): void;
+    
+
+    /**
+     * Dehydrates a view after it has been attached. Hydration/dehydration is used for reusing views
+     * inside of the view pool.
+     */
+     dehydrateView(viewRef: RenderViewRef): void;
+    
+
+    /**
+     * Returns the native element at the given location.
+     * Attention: In a WebWorker scenario, this should always return null!
+     */
+     getNativeElementSync(location: RenderElementRef): any;
+    
+
+    /**
+     * Sets a property on an element.
+     */
+     setElementProperty(location: RenderElementRef, propertyName: string, propertyValue: any): void;
+    
+
+    /**
+     * Sets an attribute on an element.
+     */
+     setElementAttribute(location: RenderElementRef, attributeName: string, attributeValue: string): void;
+    
+
+    /**
+     * Sets a class on an element.
+     */
+     setElementClass(location: RenderElementRef, className: string, isAdd: boolean): void;
+    
+
+    /**
+     * Sets a style on an element.
+     */
+     setElementStyle(location: RenderElementRef, styleName: string, styleValue: string): void;
+    
+
+    /**
+     * Calls a method on an element.
+     */
+     invokeElementMethod(location: RenderElementRef, methodName: string, args: List<any>): void;
+    
+
+    /**
+     * Sets the value of a text node.
+     */
+     setText(viewRef: RenderViewRef, textNodeIndex: number, text: string): void;
+    
+
+    /**
+     * Sets the dispatcher for all events of the given view
+     */
+     setEventDispatcher(viewRef: RenderViewRef, dispatcher: RenderEventDispatcher): void;
+  }
+  
+
+  /**
+   * Abstract reference to the element which can be marshaled across web-worker boundry.
+   * 
+   * This interface is used by the Renderer API.
+   */
+  interface RenderElementRef {
+    
+
+    /**
+     * Reference to the `RenderViewRef` where the `RenderElementRef` is inside of.
+     */
+     renderView: RenderViewRef;
+    
+
+    /**
+     * Index of the element inside the `RenderViewRef`.
+     * 
+     * This is used internally by the Angular framework to locate elements.
+     */
+     renderBoundElementIndex: number;
+  }
+  
+  class RenderViewRef {
+  }
+  
+  class RenderProtoViewRef {
+  }
+  
+  class RenderFragmentRef {
+  }
+  
+  class RenderViewWithFragments {
+    
+     viewRef: RenderViewRef;
+    
+     fragmentRefs: RenderFragmentRef[];
+  }
+  
+  class DomRenderer extends Renderer {
+    
+     createRootHostView(hostProtoViewRef: RenderProtoViewRef, fragmentCount: number, hostElementSelector: string): RenderViewWithFragments;
+    
+     createView(protoViewRef: RenderProtoViewRef, fragmentCount: number): RenderViewWithFragments;
+    
+     destroyView(viewRef: RenderViewRef): void;
+    
+     getNativeElementSync(location: RenderElementRef): any;
+    
+     getRootNodes(fragment: RenderFragmentRef): List<Node>;
+    
+     attachFragmentAfterFragment(previousFragmentRef: RenderFragmentRef, fragmentRef: RenderFragmentRef): void;
+    
+     attachFragmentAfterElement(elementRef: RenderElementRef, fragmentRef: RenderFragmentRef): void;
+    
+     detachFragment(fragmentRef: RenderFragmentRef): void;
+    
+     hydrateView(viewRef: RenderViewRef): void;
+    
+     dehydrateView(viewRef: RenderViewRef): void;
+    
+     setElementProperty(location: RenderElementRef, propertyName: string, propertyValue: any): void;
+    
+     setElementAttribute(location: RenderElementRef, attributeName: string, attributeValue: string): void;
+    
+     setElementClass(location: RenderElementRef, className: string, isAdd: boolean): void;
+    
+     setElementStyle(location: RenderElementRef, styleName: string, styleValue: string): void;
+    
+     invokeElementMethod(location: RenderElementRef, methodName: string, args: List<any>): void;
+    
+     setText(viewRef: RenderViewRef, textNodeIndex: number, text: string): void;
+    
+     setEventDispatcher(viewRef: RenderViewRef, dispatcher: any): void;
+  }
+  
+  const DOCUMENT_TOKEN : OpaqueToken ;
+  
+  const DOM_REFLECT_PROPERTIES_AS_ATTRIBUTES : OpaqueToken ;
+  
+
+  /**
+   * Declare reusable UI building blocks for an application.
+   * 
+   * Each Angular component requires a single `@Component` and at least one `@View` annotation. The
+   * `@Component`
+   * annotation specifies when a component is instantiated, and which properties and hostListeners it
+   * binds to.
+   * 
+   * When a component is instantiated, Angular
+   * - creates a shadow DOM for the component.
+   * - loads the selected template into the shadow DOM.
+   * - creates all the injectable objects configured with `hostInjector` and `viewInjector`.
+   * 
+   * All template expressions and statements are then evaluated against the component instance.
+   * 
+   * For details on the `@View` annotation, see {@link View}.
+   * 
+   * ## Example
+   * 
+   * ```
+   * @Component({
+   *   selector: 'greet'
+   * })
+   * @View({
+   *   template: 'Hello {{name}}!'
+   * })
+   * class Greet {
+   *   name: string;
+   * 
+   *   constructor() {
+   *     this.name = 'World';
+   *   }
+   * }
+   * ```
+   */
+  class ComponentAnnotation extends DirectiveAnnotation {
+    
+
+    /**
+     * Defines the used change detection strategy.
+     * 
+     * When a component is instantiated, Angular creates a change detector, which is responsible for
+     * propagating
+     * the component's bindings.
+     * 
+     * The `changeDetection` property defines, whether the change detection will be checked every time
+     * or only when the component
+     * tells it to do so.
+     */
+     changeDetection: string;
+    
+
+    /**
+     * Defines the set of injectable objects that are visible to its view dom children.
+     * 
+     * ## Simple Example
+     * 
+     * Here is an example of a class that can be injected:
+     * 
+     * ```
+     * class Greeter {
+     *    greet(name:string) {
+     *      return 'Hello ' + name + '!';
+     *    }
+     * }
+     * 
+     * @Directive({
+     *   selector: 'needs-greeter'
+     * })
+     * class NeedsGreeter {
+     *   greeter:Greeter;
+     * 
+     *   constructor(greeter:Greeter) {
+     *     this.greeter = greeter;
+     *   }
+     * }
+     * 
+     * @Component({
+     *   selector: 'greet',
+     *   viewInjector: [
+     *     Greeter
+     *   ]
+     * })
+     * @View({
+     *   template: `<needs-greeter></needs-greeter>`,
+     *   directives: [NeedsGreeter]
+     * })
+     * class HelloWorld {
+     * }
+     * 
+     * ```
+     */
+     viewInjector: List<any>;
+  }
+  
+
+  /**
+   * Directives allow you to attach behavior to elements in the DOM.
+   * 
+   * {@link Directive}s with an embedded view are called {@link Component}s.
+   * 
+   * A directive consists of a single directive annotation and a controller class. When the
+   * directive's `selector` matches
+   * elements in the DOM, the following steps occur:
+   * 
+   * 1. For each directive, the `ElementInjector` attempts to resolve the directive's constructor
+   * arguments.
+   * 2. Angular instantiates directives for each matched element using `ElementInjector` in a
+   * depth-first order,
+   *    as declared in the HTML.
+   * 
+   * ## Understanding How Injection Works
+   * 
+   * There are three stages of injection resolution.
+   * - *Pre-existing Injectors*:
+   *   - The terminal {@link Injector} cannot resolve dependencies. It either throws an error or, if
+   * the dependency was
+   *     specified as `@Optional`, returns `null`.
+   *   - The platform injector resolves browser singleton resources, such as: cookies, title,
+   * location, and others.
+   * - *Component Injectors*: Each component instance has its own {@link Injector}, and they follow
+   * the same parent-child hierarchy
+   *     as the component instances in the DOM.
+   * - *Element Injectors*: Each component instance has a Shadow DOM. Within the Shadow DOM each
+   * element has an `ElementInjector`
+   *     which follow the same parent-child hierarchy as the DOM elements themselves.
+   * 
+   * When a template is instantiated, it also must instantiate the corresponding directives in a
+   * depth-first order. The
+   * current `ElementInjector` resolves the constructor dependencies for each directive.
+   * 
+   * Angular then resolves dependencies as follows, according to the order in which they appear in the
+   * {@link View}:
+   * 
+   * 1. Dependencies on the current element
+   * 2. Dependencies on element injectors and their parents until it encounters a Shadow DOM boundary
+   * 3. Dependencies on component injectors and their parents until it encounters the root component
+   * 4. Dependencies on pre-existing injectors
+   * 
+   * 
+   * The `ElementInjector` can inject other directives, element-specific special objects, or it can
+   * delegate to the parent
+   * injector.
+   * 
+   * To inject other directives, declare the constructor parameter as:
+   * - `directive:DirectiveType`: a directive on the current element only
+   * - `@Ancestor() directive:DirectiveType`: any directive that matches the type between the current
+   * element and the
+   *    Shadow DOM root. Current element is not included in the resolution, therefore even if it could
+   * resolve it, it will
+   *    be ignored.
+   * - `@Query(DirectiveType) query:QueryList<DirectiveType>`: A live collection of direct child
+   * directives.
+   * - `@QueryDescendants(DirectiveType) query:QueryList<DirectiveType>`: A live collection of any
+   * child directives.
+   * 
+   * To inject element-specific special objects, declare the constructor parameter as:
+   * - `element: ElementRef` to obtain a reference to logical element in the view.
+   * - `viewContainer: ViewContainerRef` to control child template instantiation, for
+   * {@link Directive} directives only
+   * - `bindingPropagation: BindingPropagation` to control change detection in a more granular way.
+   * 
+   * ## Example
+   * 
+   * The following example demonstrates how dependency injection resolves constructor arguments in
+   * practice.
+   * 
+   * 
+   * Assume this HTML template:
+   * 
+   * ```
+   * <div dependency="1">
+   *   <div dependency="2">
+   *     <div dependency="3" my-directive>
+   *       <div dependency="4">
+   *         <div dependency="5"></div>
+   *       </div>
+   *       <div dependency="6"></div>
+   *     </div>
+   *   </div>
+   * </div>
+   * ```
+   * 
+   * With the following `dependency` decorator and `SomeService` injectable class.
+   * 
+   * ```
+   * @Injectable()
+   * class SomeService {
+   * }
+   * 
+   * @Directive({
+   *   selector: '[dependency]',
+   *   properties: [
+   *     'id: dependency'
+   *   ]
+   * })
+   * class Dependency {
+   *   id:string;
+   * }
+   * ```
+   * 
+   * Let's step through the different ways in which `MyDirective` could be declared...
+   * 
+   * 
+   * ### No injection
+   * 
+   * Here the constructor is declared with no arguments, therefore nothing is injected into
+   * `MyDirective`.
+   * 
+   * ```
+   * @Directive({ selector: '[my-directive]' })
+   * class MyDirective {
+   *   constructor() {
+   *   }
+   * }
+   * ```
+   * 
+   * This directive would be instantiated with no dependencies.
+   * 
+   * 
+   * ### Component-level injection
+   * 
+   * Directives can inject any injectable instance from the closest component injector or any of its
+   * parents.
+   * 
+   * Here, the constructor declares a parameter, `someService`, and injects the `SomeService` type
+   * from the parent
+   * component's injector.
+   * ```
+   * @Directive({ selector: '[my-directive]' })
+   * class MyDirective {
+   *   constructor(someService: SomeService) {
+   *   }
+   * }
+   * ```
+   * 
+   * This directive would be instantiated with a dependency on `SomeService`.
+   * 
+   * 
+   * ### Injecting a directive from the current element
+   * 
+   * Directives can inject other directives declared on the current element.
+   * 
+   * ```
+   * @Directive({ selector: '[my-directive]' })
+   * class MyDirective {
+   *   constructor(dependency: Dependency) {
+   *     expect(dependency.id).toEqual(3);
+   *   }
+   * }
+   * ```
+   * This directive would be instantiated with `Dependency` declared at the same element, in this case
+   * `dependency="3"`.
+   * 
+   * ### Injecting a directive from any ancestor elements
+   * 
+   * Directives can inject other directives declared on any ancestor element (in the current Shadow
+   * DOM), i.e. on the
+   * parent element and its parents. By definition, a directive with an `@Ancestor` annotation does
+   * not attempt to
+   * resolve dependencies for the current element, even if this would satisfy the dependency.
+   * 
+   * ```
+   * @Directive({ selector: '[my-directive]' })
+   * class MyDirective {
+   *   constructor(@Ancestor() dependency: Dependency) {
+   *     expect(dependency.id).toEqual(2);
+   *   }
+   * }
+   * ```
+   * 
+   * `@Ancestor` checks the parent, as well as its parents recursively. If `dependency="2"` didn't
+   * exist on the direct parent, this injection would
+   * have returned
+   * `dependency="1"`.
+   * 
+   * 
+   * ### Injecting a live collection of direct child directives
+   * 
+   * 
+   * A directive can also query for other child directives. Since parent directives are instantiated
+   * before child directives, a directive can't simply inject the list of child directives. Instead,
+   * the directive injects a {@link QueryList}, which updates its contents as children are added,
+   * removed, or moved by a directive that uses a {@link ViewContainerRef} such as a `ng-for`, an
+   * `ng-if`, or an `ng-switch`.
+   * 
+   * ```
+   * @Directive({ selector: '[my-directive]' })
+   * class MyDirective {
+   *   constructor(@Query(Dependency) dependencies:QueryList<Dependency>) {
+   *   }
+   * }
+   * ```
+   * 
+   * This directive would be instantiated with a {@link QueryList} which contains `Dependency` 4 and
+   * 6. Here, `Dependency` 5 would not be included, because it is not a direct child.
+   * 
+   * ### Injecting a live collection of descendant directives
+   * 
+   * By passing the descendant flag to `@Query` above, we can include the children of the child
+   * elements.
+   * 
+   * ```
+   * @Directive({ selector: '[my-directive]' })
+   * class MyDirective {
+   *   constructor(@Query(Dependency, {descendants: true}) dependencies:QueryList<Dependency>) {
+   *   }
+   * }
+   * ```
+   * 
+   * This directive would be instantiated with a Query which would contain `Dependency` 4, 5 and 6.
+   * 
+   * ### Optional injection
+   * 
+   * The normal behavior of directives is to return an error when a specified dependency cannot be
+   * resolved. If you
+   * would like to inject `null` on unresolved dependency instead, you can annotate that dependency
+   * with `@Optional()`.
+   * This explicitly permits the author of a template to treat some of the surrounding directives as
+   * optional.
+   * 
+   * ```
+   * @Directive({ selector: '[my-directive]' })
+   * class MyDirective {
+   *   constructor(@Optional() dependency:Dependency) {
+   *   }
+   * }
+   * ```
+   * 
+   * This directive would be instantiated with a `Dependency` directive found on the current element.
+   * If none can be
+   * found, the injector supplies `null` instead of throwing an error.
+   * 
+   * ## Example
+   * 
+   * Here we use a decorator directive to simply define basic tool-tip behavior.
+   * 
+   * ```
+   * @Directive({
+   *   selector: '[tooltip]',
+   *   properties: [
+   *     'text: tooltip'
+   *   ],
+   *   hostListeners: {
+   *     'onmouseenter': 'onMouseEnter()',
+   *     'onmouseleave': 'onMouseLeave()'
+   *   }
+   * })
+   * class Tooltip{
+   *   text:string;
+   *   overlay:Overlay; // NOT YET IMPLEMENTED
+   *   overlayManager:OverlayManager; // NOT YET IMPLEMENTED
+   * 
+   *   constructor(overlayManager:OverlayManager) {
+   *     this.overlay = overlay;
+   *   }
+   * 
+   *   onMouseEnter() {
+   *     // exact signature to be determined
+   *     this.overlay = this.overlayManager.open(text, ...);
+   *   }
+   * 
+   *   onMouseLeave() {
+   *     this.overlay.close();
+   *     this.overlay = null;
+   *   }
+   * }
+   * ```
+   * In our HTML template, we can then add this behavior to a `<div>` or any other element with the
+   * `tooltip` selector,
+   * like so:
+   * 
+   * ```
+   * <div tooltip="some text here"></div>
+   * ```
+   * 
+   * Directives can also control the instantiation, destruction, and positioning of inline template
+   * elements:
+   * 
+   * A directive uses a {@link ViewContainerRef} to instantiate, insert, move, and destroy views at
+   * runtime.
+   * The {@link ViewContainerRef} is created as a result of `<template>` element, and represents a
+   * location in the current view
+   * where these actions are performed.
+   * 
+   * Views are always created as children of the current {@link View}, and as siblings of the
+   * `<template>` element. Thus a
+   * directive in a child view cannot inject the directive that created it.
+   * 
+   * Since directives that create views via ViewContainers are common in Angular, and using the full
+   * `<template>` element syntax is wordy, Angular
+   * also supports a shorthand notation: `<li *foo="bar">` and `<li template="foo: bar">` are
+   * equivalent.
+   * 
+   * Thus,
+   * 
+   * ```
+   * <ul>
+   *   <li *foo="bar" title="text"></li>
+   * </ul>
+   * ```
+   * 
+   * Expands in use to:
+   * 
+   * ```
+   * <ul>
+   *   <template [foo]="bar">
+   *     <li title="text"></li>
+   *   </template>
+   * </ul>
+   * ```
+   * 
+   * Notice that although the shorthand places `*foo="bar"` within the `<li>` element, the binding for
+   * the directive
+   * controller is correctly instantiated on the `<template>` element rather than the `<li>` element.
+   * 
+   * 
+   * ## Example
+   * 
+   * Let's suppose we want to implement the `unless` behavior, to conditionally include a template.
+   * 
+   * Here is a simple directive that triggers on an `unless` selector:
+   * 
+   * ```
+   * @Directive({
+   *   selector: '[unless]',
+   *   properties: ['unless']
+   * })
+   * export class Unless {
+   *   viewContainer: ViewContainerRef;
+   *   templateRef: TemplateRef;
+   *   prevCondition: boolean;
+   * 
+   *   constructor(viewContainer: ViewContainerRef, templateRef: TemplateRef) {
+   *     this.viewContainer = viewContainer;
+   *     this.templateRef = templateRef;
+   *     this.prevCondition = null;
+   *   }
+   * 
+   *   set unless(newCondition) {
+   *     if (newCondition && (isBlank(this.prevCondition) || !this.prevCondition)) {
+   *       this.prevCondition = true;
+   *       this.viewContainer.clear();
+   *     } else if (!newCondition && (isBlank(this.prevCondition) || this.prevCondition)) {
+   *       this.prevCondition = false;
+   *       this.viewContainer.create(this.templateRef);
+   *     }
+   *   }
+   * }
+   * ```
+   * 
+   * We can then use this `unless` selector in a template:
+   * ```
+   * <ul>
+   *   <li *unless="expr"></li>
+   * </ul>
+   * ```
+   * 
+   * Once the directive instantiates the child view, the shorthand notation for the template expands
+   * and the result is:
+   * 
+   * ```
+   * <ul>
+   *   <template [unless]="exp">
+   *     <li></li>
+   *   </template>
+   *   <li></li>
+   * </ul>
+   * ```
+   * 
+   * Note also that although the `<li></li>` template still exists inside the `<template></template>`,
+   * the instantiated
+   * view occurs on the second `<li></li>` which is a sibling to the `<template>` element.
+   */
+  class DirectiveAnnotation extends InjectableMetadata {
+    
+
+    /**
+     * The CSS selector that triggers the instantiation of a directive.
+     * 
+     * Angular only allows directives to trigger on CSS selectors that do not cross element
+     * boundaries.
+     * 
+     * `selector` may be declared as one of the following:
+     * 
+     * - `element-name`: select by element name.
+     * - `.class`: select by class name.
+     * - `[attribute]`: select by attribute name.
+     * - `[attribute=value]`: select by attribute name and value.
+     * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.
+     * - `selector1, selector2`: select if either `selector1` or `selector2` matches.
+     * 
+     * 
+     * ## Example
+     * 
+     * Suppose we have a directive with an `input[type=text]` selector.
+     * 
+     * And the following HTML:
+     * 
+     * ```html
+     * <form>
+     *   <input type="text">
+     *   <input type="radio">
+     * <form>
+     * ```
+     * 
+     * The directive would only be instantiated on the `<input type="text">` element.
+     */
+     selector: string;
+    
+
+    /**
+     * Enumerates the set of properties that accept data binding for a directive.
+     * 
+     * The `properties` property defines a set of `directiveProperty` to `bindingProperty`
+     * configuration:
+     * 
+     * - `directiveProperty` specifies the component property where the value is written.
+     * - `bindingProperty` specifies the DOM property where the value is read from.
+     * 
+     * You can include a {@link Pipe} when specifying a `bindingProperty` to allow for data
+     * transformation and structural change detection of the value. These pipes will be evaluated in
+     * the context of this component.
+     * 
+     * ## Syntax
+     * 
+     * There is no need to specify both `directiveProperty` and `bindingProperty` when they both have
+     * the same value.
+     * 
+     * ```
+     * @Directive({
+     *   properties: [
+     *     'propertyName', // shorthand notation for 'propertyName: propertyName'
+     *     'directiveProperty1: bindingProperty1',
+     *     'directiveProperty2: bindingProperty2 | pipe1 | ...',
+     *     ...
+     *   ]
+     * }
+     * ```
+     * 
+     * 
+     * ## Basic Property Binding
+     * 
+     * We can easily build a simple `Tooltip` directive that exposes a `tooltip` property, which can
+     * be used in templates with standard Angular syntax. For example:
+     * 
+     * ```
+     * @Directive({
+     *   selector: '[tooltip]',
+     *   properties: [
+     *     'text: tooltip'
+     *   ]
+     * })
+     * class Tooltip {
+     *   set text(value: string) {
+     *     // This will get called every time with the new value when the 'tooltip' property changes
+     *   }
+     * }
+     * ```
+     * 
+     * We can then bind to the `tooltip' property as either an expression (`someExpression`) or as a
+     * string literal, as shown in the HTML template below:
+     * 
+     * ```html
+     * <div [tooltip]="someExpression">...</div>
+     * <div tooltip="Some Text">...</div>
+     * ```
+     * 
+     * Whenever the `someExpression` expression changes, the `properties` declaration instructs
+     * Angular to update the `Tooltip`'s `text` property.
+     * 
+     * ## Bindings With Pipes
+     * 
+     * You can also use pipes when writing binding definitions for a directive.
+     * 
+     * For example, we could write a binding that updates the directive on structural changes, rather
+     * than on reference changes, as normally occurs in change detection.
+     * 
+     * See {@link Pipe} and {@link KeyValueChanges} documentation for more details.
+     * 
+     * ```
+     * @Directive({
+     *   selector: '[class-set]',
+     *   properties: [
+     *     'classChanges: classSet | keyValDiff'
+     *   ]
+     * })
+     * class ClassSet {
+     *   set classChanges(changes: KeyValueChanges) {
+     *     // This will get called every time the `class-set` expressions changes its structure.
+     *   }
+     * }
+     * ```
+     * 
+     * The template that this directive is used in may also contain its own pipes. For example:
+     * 
+     * ```html
+     * <div [class-set]="someExpression | somePipe">
+     * ```
+     * 
+     * In this case, the two pipes compose as if they were inlined: `someExpression | somePipe |
+     * keyValDiff`.
+     */
+     properties: List<string>;
+    
+
+    /**
+     * Enumerates the set of emitted events.
+     * 
+     * ## Syntax
+     * 
+     * ```
+     * @Component({
+     *   events: ['statusChange']
+     * })
+     * class TaskComponent {
+     *   statusChange: EventEmitter;
+     * 
+     *   constructor() {
+     *     this.statusChange = new EventEmitter();
+     *   }
+     * 
+     *   onComplete() {
+     *     this.statusChange.next('completed');
+     *   }
+     * }
+     * ```
+     * 
+     * Use `propertyName: eventName` when the event emitter property name is different from the name
+     * of the emitted event:
+     * 
+     * ```
+     * @Component({
+     *   events: ['status: statusChange']
+     * })
+     * class TaskComponent {
+     *   status: EventEmitter;
+     * 
+     *   constructor() {
+     *     this.status = new EventEmitter();
+     *   }
+     * 
+     *   onComplete() {
+     *     this.status.next('completed');
+     *   }
+     * }
+     * ```
+     */
+     events: List<string>;
+    
+
+    /**
+     * Specifiy the events, actions, properties and attributes related to the host element.
+     * 
+     * ## Events
+     * 
+     * Specifies which DOM hostListeners a directive listens to via a set of `(event)` to `method`
+     * key-value pairs:
+     * 
+     * - `event1`: the DOM event that the directive listens to.
+     * - `statement`: the statement to execute when the event occurs.
+     * If the evalutation of the statement returns `false`, then `preventDefault`is applied on the DOM
+     * event.
+     * 
+     * To listen to global events, a target must be added to the event name.
+     * The target can be `window`, `document` or `body`.
+     * 
+     * When writing a directive event binding, you can also refer to the following local variables:
+     * - `$event`: Current event object which triggered the event.
+     * - `$target`: The source of the event. This will be either a DOM element or an Angular
+     * directive. (will be implemented in later release)
+     * 
+     * ## Syntax
+     * 
+     * ```
+     * @Directive({
+     *   host: {
+     *     '(event1)': 'onMethod1(arguments)',
+     *     '(target:event2)': 'onMethod2(arguments)',
+     *     ...
+     *   }
+     * }
+     * ```
+     * 
+     * ## Basic Event Binding:
+     * 
+     * Suppose you want to write a directive that reacts to `change` events in the DOM and on
+     * `resize` events in window.
+     * You would define the event binding as follows:
+     * 
+     * ```
+     * @Directive({
+     *   selector: 'input',
+     *   host: {
+     *     '(change)': 'onChange($event)',
+     *     '(window:resize)': 'onResize($event)'
+     *   }
+     * })
+     * class InputDirective {
+     *   onChange(event:Event) {
+     *     // invoked when the input element fires the 'change' event
+     *   }
+     *   onResize(event:Event) {
+     *     // invoked when the window fires the 'resize' event
+     *   }
+     * }
+     * ```
+     * 
+     * ## Properties
+     * 
+     * Specifies which DOM properties a directives updates.
+     * 
+     * ## Syntax
+     * 
+     * ```
+     * @Directive({
+     *   selector: 'input',
+     *   host: {
+     *     '[prop]': 'expression'
+     *   }
+     * })
+     * class InputDirective {
+     *   value:string;
+     * }
+     * ```
+     * 
+     * In this example the prop property of the host element is updated with the expression value
+     * every time it changes.
+     * 
+     * ## Attributes
+     * 
+     * Specifies static attributes that should be propagated to a host element. Attributes specified
+     * in `hostAttributes` are propagated only if a given attribute is not present on a host element.
+     * 
+     * ## Syntax
+     * 
+     * ```
+     * @Directive({
+     *   selector: '[my-button]',
+     *   host: {
+     *     'role': 'button'
+     *   }
+     * })
+     * class MyButton {
+     * }
+     * ```
+     * 
+     * In this example using `my-button` directive (ex.: `<div my-button></div>`) on a host element
+     * (here: `<div>` ) will ensure that this element will get the "button" role.
+     * 
+     * ## Actions
+     * 
+     * Specifies which DOM methods a directive can invoke.
+     * 
+     * ## Syntax
+     * 
+     * ```
+     * @Directive({
+     *   selector: 'input',
+     *   host: {
+     *     '@emitFocus': 'focus()'
+     *   }
+     * })
+     * class InputDirective {
+     *   constructor() {
+     *     this.emitFocus = new EventEmitter();
+     *   }
+     * 
+     *   focus() {
+     *     this.emitFocus.next();
+     *   }
+     * }
+     * ```
+     * 
+     * In this example calling focus on InputDirective will result in calling focus on the input.
+     */
+     host: StringMap<string, string>;
+    
+
+    /**
+     * Specifies which lifecycle should be notified to the directive.
+     * 
+     * See {@link LifecycleEvent} for details.
+     */
+     lifecycle: List<LifecycleEvent>;
+    
+
+    /**
+     * If set to false the compiler does not compile the children of this directive.
+     */
+     compileChildren: boolean;
+    
+
+    /**
+     * Defines the set of injectable objects that are visible to a Directive and its light dom
+     * children.
+     * 
+     * ## Simple Example
+     * 
+     * Here is an example of a class that can be injected:
+     * 
+     * ```
+     * class Greeter {
+     *    greet(name:string) {
+     *      return 'Hello ' + name + '!';
+     *    }
+     * }
+     * 
+     * @Directive({
+     *   selector: 'greet',
+     *   hostInjector: [
+     *     Greeter
+     *   ]
+     * })
+     * class HelloWorld {
+     *   greeter:Greeter;
+     * 
+     *   constructor(greeter:Greeter) {
+     *     this.greeter = greeter;
+     *   }
+     * }
+     * ```
+     */
+     hostInjector: List<any>;
+    
+
+    /**
+     * Defines the name that can be used in the template to assign this directive to a variable.
+     * 
+     * ## Simple Example
+     * 
+     * ```
+     * @Directive({
+     *   selector: 'child-dir',
+     *   exportAs: 'child'
+     * })
+     * class ChildDir {
+     * }
+     * 
+     * @Component({
+     *   selector: 'main',
+     * })
+     * @View({
+     *   template: `<child-dir #c="child"></child-dir>`,
+     *   directives: [ChildDir]
+     * })
+     * class MainComponent {
+     * }
+     * 
+     * ```
+     */
+     exportAs: string;
+  }
+  
+
+  /**
+   * Lifecycle events are guaranteed to be called in the following order:
+   * - `onChange` (optional if any bindings have changed),
+   * - `onInit` (optional after the first check only),
+   * - `onCheck`,
+   * - `onAllChangesDone`
+   */
+  enum LifecycleEvent {
+    onDestroy,
+    onChange,
+    onCheck,
+    onInit,
+    onAllChangesDone
+  }
+  
+
+  /**
+   * Declares the available HTML templates for an application.
+   * 
+   * Each angular component requires a single `@Component` and at least one `@View` annotation. The
+   * `@View` annotation specifies the HTML template to use, and lists the directives that are active
+   * within the template.
+   * 
+   * When a component is instantiated, the template is loaded into the component's shadow root, and
+   * the expressions and statements in the template are evaluated against the component.
+   * 
+   * For details on the `@Component` annotation, see {@link Component}.
+   * 
+   * ## Example
+   * 
+   * ```
+   * @Component({
+   *   selector: 'greet'
+   * })
+   * @View({
+   *   template: 'Hello {{name}}!',
+   *   directives: [GreetUser, Bold]
+   * })
+   * class Greet {
+   *   name: string;
+   * 
+   *   constructor() {
+   *     this.name = 'World';
+   *   }
+   * }
+   * ```
+   */
+  class ViewAnnotation {
+    
+
+    /**
+     * Specifies an inline template for an angular component.
+     * 
+     * NOTE: either `templateUrl` or `template` should be used, but not both.
+     */
+     templateUrl: string;
+    
+
+    /**
+     * Specifies a template URL for an angular component.
+     * 
+     * NOTE: either `templateUrl` or `template` should be used, but not both.
+     */
+     template: string;
+    
+
+    /**
+     * Specifies stylesheet URLs for an angular component.
+     */
+     styleUrls: List<string>;
+    
+
+    /**
+     * Specifies an inline stylesheet for an angular component.
+     */
+     styles: List<string>;
+    
+
+    /**
+     * Specifies a list of directives that can be used within a template.
+     * 
+     * Directives must be listed explicitly to provide proper component encapsulation.
+     * 
+     * ## Example
+     * 
+     * ```javascript
+     * @Component({
+     *     selector: 'my-component'
+     *   })
+     * @View({
+     *   directives: [For]
+     *   template: '
+     *   <ul>
+     *     <li *ng-for="#item of items">{{item}}</li>
+     *   </ul>'
+     * })
+     * class MyComponent {
+     * }
+     * ```
+     */
+     directives: List<Type | any | List<any>>;
+    
+
+    /**
+     * Specify a custom renderer for this View.
+     * If this is set, neither `template`, `templateUrl`, `styles`, `styleUrls` nor `directives` are
+     * used.
+     */
+     renderer: string;
+  }
+  
+
+  /**
+   * Specifies that a {@link QueryList} should be injected.
+   * 
+   * See {@link QueryList} for usage and example.
+   */
+  class QueryAnnotation extends DependencyMetadata {
+    
+     descendants: boolean;
+    
+     isViewQuery: void;
+    
+     selector: void;
+    
+     isVarBindingQuery: boolean;
+    
+     varBindings: List<string>;
+    
+     toString(): string;
+  }
+  
+
+  /**
+   * Specifies that a constant attribute value should be injected.
+   * 
+   * The directive can inject constant string literals of host element attributes.
+   * 
+   * ## Example
+   * 
+   * Suppose we have an `<input>` element and want to know its `type`.
+   * 
+   * ```html
+   * <input type="text">
+   * ```
+   * 
+   * A decorator can inject string literal `text` like so:
+   * 
+   * ```javascript
+   * @Directive({
+   *   selector: `input'
+   * })
+   * class InputDirective {
+   *   constructor(@Attribute('type') type) {
+   *     // type would be `text` in this example
+   *   }
+   * }
+   * ```
+   */
+  class AttributeAnnotation extends DependencyMetadata {
+    
+     attributeName: string;
+    
+     token: void;
+    
+     toString(): string;
+  }
+  
+
+  /**
+   * Defines lifecycle method [onAllChangesDone ] called when the bindings of all its children have
+   * been changed.
+   */
+  interface OnAllChangesDone {
+    
+     onAllChangesDone(): void;
+  }
+  
+
+  /**
+   * Defines lifecycle method [onChange] called after all of component's bound
+   * properties are updated.
+   */
+  interface OnChange {
+    
+     onChange(changes: StringMap<string, any>): void;
+  }
+  
+
+  /**
+   * Defines lifecycle method [onDestroy] called when a directive is being destroyed.
+   */
+  interface OnDestroy {
+    
+     onDestroy(): void;
+  }
+  
+
+  /**
+   * Defines lifecycle method [onInit] called when a directive is being checked the first time.
+   */
+  interface OnInit {
+    
+     onInit(): void;
+  }
+  
+
+  /**
+   * Defines lifecycle method [onCheck] called when a directive is being checked.
+   */
+  interface OnCheck {
+    
+     onCheck(): void;
+  }
+  
+
+  /**
+   * Provides a way for expressing ES6 classes with parameter annotations in ES5.
+   * 
+   * ## Basic Example
+   * 
+   * ```
+   * var Greeter = ng.Class({
+   *   constructor: function(name) {
+   *     this.name = name;
+   *   },
+   * 
+   *   greet: function() {
+   *     alert('Hello ' + this.name + '!');
+   *   }
+   * });
+   * ```
+   * 
+   * is equivalent to ES6:
+   * 
+   * ```
+   * class Greeter {
+   *   constructor(name) {
+   *     this.name = name;
+   *   }
+   * 
+   *   greet() {
+   *     alert('Hello ' + this.name + '!');
+   *   }
+   * }
+   * ```
+   * 
+   * or equivalent to ES5:
+   * 
+   * ```
+   * var Greeter = function (name) {
+   *   this.name = name;
+   * }
+   * 
+   * Greeter.prototype.greet = function () {
+   *   alert('Hello ' + this.name + '!');
+   * }
+   * ```
+   * 
+   * ## Example with parameter annotations
+   * 
+   * ```
+   * var MyService = neg.Class({
+   *   constructor: [String, [new Query(), QueryList], function(name, queryList) {
+   *     ...
+   *   }];
+   * });
+   * ```
+   * 
+   * is equivalent to ES6:
+   * 
+   * ```
+   * class MyService {
+   *   constructor(name: string, @Query() queryList: QueryList) {
+   *     ...
+   *   }
+   * }
+   * ```
+   * 
+   * ## Example with inheritance
+   * 
+   * ```
+   * var Shape = ng.Class({
+   *   constructor: (color) {
+   *     this.color = color;
+   *   }
+   * });
+   * 
+   * var Square = ng.Class({
+   *   extends: Shape,
+   *   constructor: function(color, size) {
+   *     Shape.call(this, color);
+   *     this.size = size;
+   *   }
+   * });
+   * ```
+   */
+  function Class(clsDef: ClassDefinition) : Type ;
+  
+
+  /**
+   * Declares the interface to be used with {@link Class}.
+   */
+  interface ClassDefinition {
+    
+
+    /**
+     * Optional argument for specifying the superclass.
+     */
+     extends?: Type;
+    
+
+    /**
+     * Required constructor function for a class.
+     * 
+     * The function may be optionally wrapped in an `Array`, in which case additional parameter
+     * annotations may be specified.
+     * The number of arguments and the number of parameter annotations must match.
+     * 
+     * See {@link Class} for example of usage.
+     */
+     constructor: (Function | Array<any>);
+  }
+  
+
+  /**
+   * An interface implemented by all Angular parameter decorators, which allows them to be used as ES7
+   * decorators.
+   */
+  interface ParameterDecorator {
+    
+
+    /**
+     * Invoke as ES7 decorator.
+     */
+     (cls: Type, unusedKey: any, index: number): void;
+  
+  }
+  
+
+  /**
+   * An interface implemented by all Angular type decorators, which allows them to be used as ES7
+   * decorators as well as
+   * Angular DSL syntax.
+   * 
+   * DSL syntax:
+   * 
+   * ```
+   * var MyClass = ng
+   *   .Component({...})
+   *   .View({...})
+   *   .Class({...});
+   * ```
+   * 
+   * ES7 syntax:
+   * 
+   * ```
+   * @ng.Component({...})
+   * @ng.View({...})
+   * class MyClass {...}
+   * ```
+   */
+  interface TypeDecorator {
+    
+
+    /**
+     * Invoke as ES7 decorator.
+     */
+     <T extends Type>(type: T): T;
+  
+    
+
+    /**
+     * Storage for the accumulated annotations so far used by the DSL syntax.
+     * 
+     * Used by {@link Class} to annotate the generated class.
+     */
+     annotations: Array<any>;
+    
+
+    /**
+     * Generate a class from the definition and annotate it with {@link TypeDecorator#annotations}.
+     */
+     Class(obj: ClassDefinition): Type;
+  }
+  
+
+  /**
+   * {@link Attribute} factory function.
+   */
+  var Attribute : AttributeFactory ;
+  
+
+  /**
+   * {@link Attribute} factory for creating annotations, decorators or DSL.
+   * 
+   * ## Example as TypeScript Decorator
+   * 
+   * ```
+   * import {Attribute, Component, View} from "angular2/angular2";
+   * 
+   * @Component({...})
+   * @View({...})
+   * class MyComponent {
+   *   constructor(@Attribute('title') title: string) {
+   *     ...
+   *   }
+   * }
+   * ```
+   * 
+   * ## Example as ES5 DSL
+   * 
+   * ```
+   * var MyComponent = ng
+   *   .Component({...})
+   *   .View({...})
+   *   .Class({
+   *     constructor: [new ng.Attribute('title'), function(title) {
+   *       ...
+   *     }]
+   *   })
+   * ```
+   * 
+   * ## Example as ES5 annotation
+   * 
+   * ```
+   * var MyComponent = function(title) {
+   *   ...
+   * };
+   * 
+   * MyComponent.annotations = [
+   *   new ng.Component({...})
+   *   new ng.View({...})
+   * ]
+   * MyComponent.parameters = [
+   *   [new ng.Attribute('title')]
+   * ]
+   * ```
+   */
+  interface AttributeFactory {
+    
+     new(name: string): AttributeAnnotation;
+  
+    
+     (name: string): TypeDecorator;
+  
+  }
+  
+
+  /**
+   * {@link Component} factory function.
+   */
+  var Component : ComponentFactory ;
+  
+
+  /**
+   * Interface for the {@link Component} decorator function.
+   * 
+   * See {@link ComponentFactory}.
+   */
+  interface ComponentDecorator extends TypeDecorator {
+    
+
+    /**
+     * Chain {@link View} annotation.
+     */
+     View(obj: {
+    templateUrl?: string,
+    template?: string,
+    directives?: List<Type | any | List<any>>,
+    renderer?: string,
+    styles?: List<string>,
+    styleUrls?: List<string>,
+  }): ViewDecorator;
+  }
+  
+
+  /**
+   * {@link ComponentAnnotation} factory for creating annotations, decorators or DSL.
+   * 
+   * ## Example as TypeScript Decorator
+   * 
+   * ```
+   * import {Component, View} from "angular2/angular2";
+   * 
+   * @Component({...})
+   * @View({...})
+   * class MyComponent {
+   *   constructor() {
+   *     ...
+   *   }
+   * }
+   * ```
+   * 
+   * ## Example as ES5 DSL
+   * 
+   * ```
+   * var MyComponent = ng
+   *   .Component({...})
+   *   .View({...})
+   *   .Class({
+   *     constructor: function() {
+   *       ...
+   *     }
+   *   })
+   * ```
+   * 
+   * ## Example as ES5 annotation
+   * 
+   * ```
+   * var MyComponent = function() {
+   *   ...
+   * };
+   * 
+   * MyComponent.annotations = [
+   *   new ng.Component({...})
+   *   new ng.View({...})
+   * ]
+   * ```
+   */
+  interface ComponentFactory {
+    
+     new(obj: {
+    selector?: string,
+    properties?: List<string>,
+    events?: List<string>,
+    host?: StringMap<string, string>,
+    lifecycle?: List<LifecycleEvent>,
+    hostInjector?: List<any>,
+    exportAs?: string,
+    compileChildren?: boolean,
+    viewInjector?: List<any>,
+    changeDetection?: string,
+  }): ComponentAnnotation;
+  
+    
+     (obj: {
+    selector?: string,
+    properties?: List<string>,
+    events?: List<string>,
+    host?: StringMap<string, string>,
+    lifecycle?: List<LifecycleEvent>,
+    hostInjector?: List<any>,
+    exportAs?: string,
+    compileChildren?: boolean,
+    viewInjector?: List<any>,
+    changeDetection?: string,
+  }): ComponentDecorator;
+  
+  }
+  
+
+  /**
+   * {@link Directive} factory function.
+   */
+  var Directive : DirectiveFactory ;
+  
+
+  /**
+   * Interface for the {@link Directive} decorator function.
+   * 
+   * See {@link DirectiveFactory}.
+   */
+  interface DirectiveDecorator extends TypeDecorator {
+  }
+  
+
+  /**
+   * {@link Directive} factory for creating annotations, decorators or DSL.
+   * 
+   * ## Example as TypeScript Decorator
+   * 
+   * ```
+   * import {Directive} from "angular2/angular2";
+   * 
+   * @Directive({...})
+   * class MyDirective {
+   *   constructor() {
+   *     ...
+   *   }
+   * }
+   * ```
+   * 
+   * ## Example as ES5 DSL
+   * 
+   * ```
+   * var MyDirective = ng
+   *   .Directive({...})
+   *   .Class({
+   *     constructor: function() {
+   *       ...
+   *     }
+   *   })
+   * ```
+   * 
+   * ## Example as ES5 annotation
+   * 
+   * ```
+   * var MyDirective = function() {
+   *   ...
+   * };
+   * 
+   * MyDirective.annotations = [
+   *   new ng.Directive({...})
+   * ]
+   * ```
+   */
+  interface DirectiveFactory {
+    
+     new(obj: {
+    selector?: string, properties?: List<string>, events?: List<string>,
+        host?: StringMap<string, string>, lifecycle?: List<LifecycleEvent>,
+        hostInjector?: List<any>, exportAs?: string, compileChildren?: boolean;
+  }): DirectiveAnnotation;
+  
+    
+     (obj: {
+    selector?: string, properties?: List<string>, events?: List<string>,
+        host?: StringMap<string, string>, lifecycle?: List<LifecycleEvent>,
+        hostInjector?: List<any>, exportAs?: string, compileChildren?: boolean;
+  }): DirectiveDecorator;
+  
+  }
+  
+
+  /**
+   * {@link View} factory function.
+   */
+  var View : ViewFactory ;
+  
+
+  /**
+   * Interface for the {@link View} decorator function.
+   * 
+   * See {@link ViewFactory}.
+   */
+  interface ViewDecorator extends TypeDecorator {
+    
+
+    /**
+     * Chain {@link View} annotation.
+     */
+     View(obj: {
+    templateUrl?: string,
+    template?: string,
+    directives?: List<Type | any | List<any>>,
+    renderer?: string,
+    styles?: List<string>,
+    styleUrls?: List<string>,
+  }): ViewDecorator;
+  }
+  
+
+  /**
+   * {@link ViewAnnotation} factory for creating annotations, decorators or DSL.
+   * 
+   * ## Example as TypeScript Decorator
+   * 
+   * ```
+   * import {Component, View} from "angular2/angular2";
+   * 
+   * @Component({...})
+   * @View({...})
+   * class MyComponent {
+   *   constructor() {
+   *     ...
+   *   }
+   * }
+   * ```
+   * 
+   * ## Example as ES5 DSL
+   * 
+   * ```
+   * var MyComponent = ng
+   *   .Component({...})
+   *   .View({...})
+   *   .Class({
+   *     constructor: function() {
+   *       ...
+   *     }
+   *   })
+   * ```
+   * 
+   * ## Example as ES5 annotation
+   * 
+   * ```
+   * var MyComponent = function() {
+   *   ...
+   * };
+   * 
+   * MyComponent.annotations = [
+   *   new ng.Component({...})
+   *   new ng.View({...})
+   * ]
+   * ```
+   */
+  interface ViewFactory {
+    
+     new(obj: {
+    templateUrl?: string,
+    template?: string,
+    directives?: List<Type | any | List<any>>,
+    renderer?: string,
+    styles?: List<string>,
+    styleUrls?: List<string>,
+  }): ViewAnnotation;
+  
+    
+     (obj: {
+    templateUrl?: string,
+    template?: string,
+    directives?: List<Type | any | List<any>>,
+    renderer?: string,
+    styles?: List<string>,
+    styleUrls?: List<string>,
+  }): ViewDecorator;
+  
+  }
+  
+
+  /**
+   * {@link Query} factory function.
+   */
+  var Query : QueryFactory ;
+  
+
+  /**
+   * {@link Query} factory for creating annotations, decorators or DSL.
+   * 
+   * ## Example as TypeScript Decorator
+   * 
+   * ```
+   * import {Query, QueryList, Component, View} from "angular2/angular2";
+   * 
+   * @Component({...})
+   * @View({...})
+   * class MyComponent {
+   *   constructor(@Query(SomeType) queryList: QueryList) {
+   *     ...
+   *   }
+   * }
+   * ```
+   * 
+   * ## Example as ES5 DSL
+   * 
+   * ```
+   * var MyComponent = ng
+   *   .Component({...})
+   *   .View({...})
+   *   .Class({
+   *     constructor: [new ng.Query(SomeType), function(queryList) {
+   *       ...
+   *     }]
+   *   })
+   * ```
+   * 
+   * ## Example as ES5 annotation
+   * 
+   * ```
+   * var MyComponent = function(queryList) {
+   *   ...
+   * };
+   * 
+   * MyComponent.annotations = [
+   *   new ng.Component({...})
+   *   new ng.View({...})
+   * ]
+   * MyComponent.parameters = [
+   *   [new ng.Query(SomeType)]
+   * ]
+   * ```
+   */
+  interface QueryFactory {
+    
+     new(selector: Type | string, {descendants}?: {descendants?: boolean}): QueryAnnotation;
+  
+    
+     (selector: Type | string, {descendants}?: {descendants?: boolean}): ParameterDecorator;
+  
+  }
+  
+
+  /**
+   * {@link ViewQuery} factory function.
+   */
+  var ViewQuery : QueryFactory ;
+  
+
+  /**
+   * An opaque token representing the application root type in the {@link Injector}.
+   * 
+   * ```
+   * @Component(...)
+   * @View(...)
+   * class MyApp {
+   *   ...
+   * }
+   * 
+   * bootstrap(MyApp).then((appRef:ApplicationRef) {
+   *   expect(appRef.injector.get(appComponentTypeToken)).toEqual(MyApp);
+   * });
+   * 
+   * ```
+   */
+  const appComponentTypeToken : OpaqueToken ;
+  
+
+  /**
+   * Represents a Angular's representation of an Application.
+   * 
+   * `ApplicationRef` represents a running application instance. Use it to retrieve the host
+   * component, injector,
+   * or dispose of an application.
+   */
+  interface ApplicationRef {
+    
+
+    /**
+     * Returns the current {@link Component} type.
+     */
+     hostComponentType: Type;
+    
+
+    /**
+     * Returns the current {@link Component} instance.
+     */
+     hostComponent: any;
+    
+
+    /**
+     * Dispose (un-load) the application.
+     */
+     dispose(): void;
+    
+
+    /**
+     * Returns the root application {@link Injector}.
+     */
+     injector: Injector;
+  }
+  
+
+  /**
+   * Specifies app root url for the application.
+   * 
+   * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
+   * 
+   * This interface can be overridden by the application developer to create custom behavior.
+   * 
+   * See {@link Compiler}
+   */
+  class AppRootUrl {
+    
+
+    /**
+     * Returns the base URL of the currently running application.
+     */
+     value: void;
+  }
+  
+
+  /**
+   * Used by the {@link Compiler} when resolving HTML and CSS template URLs.
+   * 
+   * This interface can be overridden by the application developer to create custom behavior.
+   * 
+   * See {@link Compiler}
+   */
+  class UrlResolver {
+    
+
+    /**
+     * Resolves the `url` given the `baseUrl`:
+     * - when the `url` is null, the `baseUrl` is returned,
+     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of
+     * `baseUrl` and `url`,
+     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is
+     * returned as is (ignoring the `baseUrl`)
+     * 
+     * @param {string} baseUrl
+     * @param {string} url
+     * @returns {string} the resolved URL
+     */
+     resolve(baseUrl: string, url: string): string;
+  }
+  
+
+  /**
+   * Resolve a `Type` from a {@link Component} into a URL.
+   * 
+   * This interface can be overridden by the application developer to create custom behavior.
+   * 
+   * See {@link Compiler}
+   */
+  class ComponentUrlMapper {
+    
+
+    /**
+     * Returns the base URL to the component source file.
+     * The returned URL could be:
+     * - an absolute URL,
+     * - a path relative to the application
+     */
+     getUrl(component: Type): string;
+  }
+  
+
+  /**
+   * Resolve a `Type` for {@link Directive}.
+   * 
+   * This interface can be overridden by the application developer to create custom behavior.
+   * 
+   * See {@link Compiler}
+   */
+  class DirectiveResolver {
+    
+
+    /**
+     * Return {@link Directive} for a given `Type`.
+     */
+     resolve(type: Type): DirectiveAnnotation;
+  }
+  
+
+  /**
+   * ## URL Resolution
+   * 
+   * ```
+   * var appRootUrl: AppRootUrl = ...;
+   * var componentUrlMapper: ComponentUrlMapper = ...;
+   * var urlResolver: UrlResolver = ...;
+   * 
+   * var componentType: Type = ...;
+   * var componentAnnotation: ComponentAnnotation = ...;
+   * var viewAnnotation: ViewAnnotation = ...;
+   * 
+   * // Resolving a URL
+   * 
+   * var url = viewAnnotation.templateUrl;
+   * var componentUrl = componentUrlMapper.getUrl(componentType);
+   * var componentResolvedUrl = urlResolver.resolve(appRootUrl.value, componentUrl);
+   * var templateResolvedUrl = urlResolver.resolve(componetResolvedUrl, url);
+   * ```
+   */
+  interface Compiler {
+    
+     compileInHost(componentTypeOrBinding: Type | Binding): Promise<ProtoViewRef>;
+  }
+  
+
+  /**
+   * Entry point for creating, moving views in the view hierarchy and destroying views.
+   * This manager contains all recursion and delegates to helper methods
+   * in AppViewManagerUtils and the Renderer, so unit tests get simpler.
+   */
+  interface AppViewManager {
+    
+
+    /**
+     * Returns a {@link ViewContainerRef} at the {@link ElementRef} location.
+     */
+     getViewContainer(location: ElementRef): ViewContainerRef;
+    
+
+    /**
+     * Return the first child element of the host element view.
+     */
+     getHostElement(hostViewRef: ViewRef): ElementRef;
+    
+
+    /**
+     * Returns an ElementRef for the element with the given variable name
+     * in the current view.
+     * 
+     * - `hostLocation`: {@link ElementRef} of any element in the View which defines the scope of
+     *   search.
+     * - `variableName`: Name of the variable to locate.
+     * - Returns {@link ElementRef} of the found element or null. (Throws if not found.)
+     */
+     getNamedElementInComponentView(hostLocation: ElementRef, variableName: string): ElementRef;
+    
+
+    /**
+     * Returns the component instance for a given element.
+     * 
+     * The component is the execution context as seen by an expression at that {@link ElementRef}
+     * location.
+     */
+     getComponent(hostLocation: ElementRef): any;
+    
+
+    /**
+     * Load component view into existing element.
+     * 
+     * Use this if a host element is already in the DOM and it is necessary to upgrade
+     * the element into Angular component by attaching a view but reusing the existing element.
+     * 
+     * - `hostProtoViewRef`: {@link ProtoViewRef} Proto view to use in creating a view for this
+     *   component.
+     * - `overrideSelector`: (optional) selector to use in locating the existing element to load
+     *   the view into. If not specified use the selector in the component definition of the
+     *   `hostProtoView`.
+     * - injector: {@link Injector} to use as parent injector for the view.
+     * 
+     * See {@link AppViewManager#destroyRootHostView}.
+     * 
+     * ## Example
+     * 
+     * ```
+     * @ng.Component({
+     *   selector: 'child-component'
+     * })
+     * @ng.View({
+     *   template: 'Child'
+     * })
+     * class ChildComponent {
+     * 
+     * }
+     * 
+     * @ng.Component({
+     *   selector: 'my-app'
+     * })
+     * @ng.View({
+     *   template: `
+     *     Parent (<some-component></some-component>)
+     *   `
+     * })
+     * class MyApp {
+     *   viewRef: ng.ViewRef;
+     * 
+     *   constructor(public appViewManager: ng.AppViewManager, compiler: ng.Compiler) {
+     *     compiler.compileInHost(ChildComponent).then((protoView: ng.ProtoViewRef) => {
+     *       this.viewRef = appViewManager.createRootHostView(protoView, 'some-component', null);
+     *     })
+     *   }
+     * 
+     *   onDestroy() {
+     *     this.appViewManager.destroyRootHostView(this.viewRef);
+     *     this.viewRef = null;
+     *   }
+     * }
+     * 
+     * ng.bootstrap(MyApp);
+     * ```
+     */
+     createRootHostView(hostProtoViewRef: ProtoViewRef, overrideSelector: string, injector: Injector): ViewRef;
+    
+
+    /**
+     * Remove the View created with {@link AppViewManager#createRootHostView}.
+     */
+     destroyRootHostView(hostViewRef: ViewRef): void;
+    
+
+    /**
+     * See {@link AppViewManager#destroyViewInContainer}.
+     */
+     createEmbeddedViewInContainer(viewContainerLocation: ElementRef, atIndex: number, templateRef: TemplateRef): ViewRef;
+    
+
+    /**
+     * See {@link AppViewManager#destroyViewInContainer}.
+     */
+     createHostViewInContainer(viewContainerLocation: ElementRef, atIndex: number, protoViewRef: ProtoViewRef, imperativelyCreatedInjector: ResolvedBinding[]): ViewRef;
+    
+
+    /**
+     * See {@link AppViewManager#createViewInContainer}.
+     */
+     destroyViewInContainer(viewContainerLocation: ElementRef, atIndex: number): void;
+    
+
+    /**
+     * See {@link AppViewManager#detachViewInContainer}.
+     */
+     attachViewInContainer(viewContainerLocation: ElementRef, atIndex: number, viewRef: ViewRef): ViewRef;
+    
+
+    /**
+     * See {@link AppViewManager#attachViewInContainer}.
+     */
+     detachViewInContainer(viewContainerLocation: ElementRef, atIndex: number): ViewRef;
+  }
+  
+
+  /**
+   * An iterable live list of components in the Light DOM.
+   * 
+   * Injectable Objects that contains a live list of child directives in the light DOM of a directive.
+   * The directives are kept in depth-first pre-order traversal of the DOM.
+   * 
+   * The `QueryList` is iterable, therefore it can be used in both javascript code with `for..of` loop
+   * as well as in
+   * template with `*ng-for="of"` directive.
+   * 
+   * NOTE: In the future this class will implement an `Observable` interface. For now it uses a plain
+   * list of observable
+   * callbacks.
+   * 
+   * # Example:
+   * 
+   * Assume that `<tabs>` component would like to get a list its children which are `<pane>`
+   * components as shown in this
+   * example:
+   * 
+   * ```html
+   * <tabs>
+   *   <pane title="Overview">...</pane>
+   *   <pane *ng-for="#o of objects" [title]="o.title">{{o.text}}</pane>
+   * </tabs>
+   * ```
+   * 
+   * In the above example the list of `<tabs>` elements needs to get a list of `<pane>` elements so
+   * that it could render
+   * tabs with the correct titles and in the correct order.
+   * 
+   * A possible solution would be for a `<pane>` to inject `<tabs>` component and then register itself
+   * with `<tabs>`
+   * component's on `hydrate` and deregister on `dehydrate` event. While a reasonable approach, this
+   * would only work
+   * partialy since `*ng-for` could rearrange the list of `<pane>` components which would not be
+   * reported to `<tabs>`
+   * component and thus the list of `<pane>` components would be out of sync with respect to the list
+   * of `<pane>` elements.
+   * 
+   * A preferred solution is to inject a `QueryList` which is a live list of directives in the
+   * component`s light DOM.
+   * 
+   * ```javascript
+   * @Component({
+   *   selector: 'tabs'
+   * })
+   * @View({
+   *  template: `
+   *    <ul>
+   *      <li *ng-for="#pane of panes">{{pane.title}}</li>
+   *    </ul>
+   *    <content></content>
+   *  `
+   * })
+   * class Tabs {
+   *   panes: QueryList<Pane>
+   * 
+   *   constructor(@Query(Pane) panes:QueryList<Pane>) {
+   *     this.panes = panes;
+   *   }
+   * }
+   * 
+   * @Component({
+   *   selector: 'pane',
+   *   properties: ['title']
+   * })
+   * @View(...)
+   * class Pane {
+   *   title:string;
+   * }
+   * ```
+   */
+  interface IQueryList<T> {
+  }
+  
+
+  /**
+   * Injectable Objects that contains a live list of child directives in the light Dom of a directive.
+   * The directives are kept in depth-first pre-order traversal of the DOM.
+   * 
+   * In the future this class will implement an Observable interface.
+   * For now it uses a plain list of observable callbacks.
+   */
+  class QueryList<T> implements IQueryList<T> {
+    
+     reset(newList: List<T>): void;
+    
+     add(obj: T): void;
+    
+     fireCallbacks(): void;
+    
+     onChange(callback: () => void): void;
+    
+     removeCallback(callback: () => void): void;
+    
+     length: number;
+    
+     first: T;
+    
+     last: T;
+    
+     map<U>(fn: (item: T) => U): U[];
+  }
+  
+
+  /**
+   * Reference to the element.
+   * 
+   * Represents an opaque reference to the underlying element. The element is a DOM ELement in
+   * a Browser, but may represent other types on other rendering platforms. In the browser the
+   * `ElementRef` can be sent to the web-worker. Web Workers can not have references to the
+   * DOM Elements.
+   */
+  class ElementRef implements RenderElementRef {
+    
+
+    /**
+     * Reference to the {@link ViewRef} where the `ElementRef` is inside of.
+     */
+     parentView: ViewRef;
+    
+
+    /**
+     * Index of the element inside the {@link ViewRef}.
+     * 
+     * This is used internally by the Angular framework to locate elements.
+     */
+     boundElementIndex: number;
+    
+
+    /**
+     * Index of the element inside the `RenderViewRef`.
+     * 
+     * This is used internally by the Angular framework to locate elements.
+     */
+     renderBoundElementIndex: number;
+    
+     renderView: RenderViewRef;
+    
+
+    /**
+     * Returns the native Element implementation.
+     * 
+     * In the browser this represents the DOM Element.
+     * 
+     * The `nativeElement` can be used as an escape hatch when direct DOM manipulation is needed. Use
+     * this with caution, as it creates tight coupling between your application and the Browser, which
+     * will not work in WebWorkers.
+     * 
+     * NOTE: This method will return null in the webworker scenario!
+     */
+     nativeElement: any;
+  }
+  
+
+  /**
+   * Reference to a template within a component.
+   * 
+   * Represents an opaque reference to the underlying template that can
+   * be instantiated using the {@link ViewContainerRef}.
+   */
+  class TemplateRef {
+    
+
+    /**
+     * The location of the template
+     */
+     elementRef: ElementRef;
+    
+     protoViewRef: ProtoViewRef;
+    
+
+    /**
+     * Whether this template has a local variable with the given name
+     */
+     hasLocal(name: string): boolean;
+  }
+  
+
+  /**
+   * A reference to an Angular View.
+   * 
+   * A View is a fundamental building block of Application UI. A View is the smallest set of
+   * elements which are created and destroyed together. A View can change properties on the elements
+   * within the view, but it can not change the structure of those elements.
+   * 
+   * To change structure of the elements, the Views can contain zero or more {@link ViewContainerRef}s
+   * which allow the views to be nested.
+   * 
+   * ## Example
+   * 
+   * Given this template
+   * 
+   * ```
+   * Count: {{items.length}}
+   * <ul>
+   *   <li *ng-for="var item of items">{{item}}</li>
+   * </ul>
+   * ```
+   * 
+   * The above example we have two {@link ProtoViewRef}s:
+   * 
+   * Outter {@link ProtoViewRef}:
+   * ```
+   * Count: {{items.length}}
+   * <ul>
+   *   <template ng-for var-item [ng-for-of]="items"></template>
+   * </ul>
+   * ```
+   * 
+   * Inner {@link ProtoViewRef}:
+   * ```
+   *   <li>{{item}}</li>
+   * ```
+   * 
+   * Notice that the original template is broken down into two separate {@link ProtoViewRef}s.
+   * 
+   * The outter/inner {@link ProtoViewRef}s are then assembled into views like so:
+   * 
+   * ```
+   * <!-- ViewRef: outter-0 -->
+   * Count: 2
+   * <ul>
+   *   <template view-container-ref></template>
+   *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
+   *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
+   * </ul>
+   * <!-- /ViewRef: outter-0 -->
+   * ```
+   */
+  class ViewRef {
+    
+
+    /**
+     * Return `RenderViewRef`
+     */
+     render: RenderViewRef;
+    
+
+    /**
+     * Return `RenderFragmentRef`
+     */
+     renderFragment: RenderFragmentRef;
+    
+
+    /**
+     * Set local variable for a view.
+     */
+     setLocal(contextName: string, value: any): void;
+  }
+  
+
+  /**
+   * A reference to an Angular ProtoView.
+   * 
+   * A ProtoView is a reference to a template for easy creation of views.
+   * (See {@link AppViewManager#createViewInContainer} and {@link AppViewManager#createRootHostView}).
+   * 
+   * A `ProtoView` is a foctary for creating `View`s.
+   * 
+   * ## Example
+   * 
+   * Given this template
+   * 
+   * ```
+   * Count: {{items.length}}
+   * <ul>
+   *   <li *ng-for="var item of items">{{item}}</li>
+   * </ul>
+   * ```
+   * 
+   * The above example we have two {@link ProtoViewRef}s:
+   * 
+   * Outter {@link ProtoViewRef}:
+   * ```
+   * Count: {{items.length}}
+   * <ul>
+   *   <template ng-for var-item [ng-for-of]="items"></template>
+   * </ul>
+   * ```
+   * 
+   * Inner {@link ProtoViewRef}:
+   * ```
+   *   <li>{{item}}</li>
+   * ```
+   * 
+   * Notice that the original template is broken down into two separate {@link ProtoViewRef}s.
+   */
+  interface ProtoViewRef {
+  }
+  
+  class ViewContainerRef {
+    
+     viewManager: AppViewManager;
+    
+     element: ElementRef;
+    
+     clear(): void;
+    
+     get(index: number): ViewRef;
+    
+     length: number;
+    
+     createEmbeddedView(templateRef: TemplateRef, atIndex?: number): ViewRef;
+    
+     createHostView(protoViewRef?: ProtoViewRef, atIndex?: number, dynamicallyCreatedBindings?: ResolvedBinding[]): ViewRef;
+    
+     insert(viewRef: ViewRef, atIndex?: number): ViewRef;
+    
+     indexOf(viewRef: ViewRef): number;
+    
+     remove(atIndex?: number): void;
+    
+
+    /**
+     * The method can be used together with insert to implement a view move, i.e.
+     * moving the dom nodes while the directives in the view stay intact.
+     */
+     detach(atIndex?: number): ViewRef;
+  }
+  
+
+  /**
+   * Service for dynamically loading a Component into an arbitrary position in the internal Angular
+   * application tree.
+   */
+  class DynamicComponentLoader {
+    
+
+    /**
+     * Loads a root component that is placed at the first element that matches the component's
+     * selector.
+     * 
+     * The loaded component receives injection normally as a hosted view.
+     */
+     loadAsRoot(typeOrBinding: Type | Binding, overrideSelector: string, injector: Injector): Promise<ComponentRef>;
+    
+
+    /**
+     * Loads a component into the component view of the provided ElementRef
+     * next to the element with the given name
+     * The loaded component receives
+     * injection normally as a hosted view.
+     */
+     loadIntoLocation(typeOrBinding: Type | Binding, hostLocation: ElementRef, anchorName: string, bindings?: ResolvedBinding[]): Promise<ComponentRef>;
+    
+
+    /**
+     * Loads a component next to the provided ElementRef. The loaded component receives
+     * injection normally as a hosted view.
+     */
+     loadNextToLocation(typeOrBinding: Type | Binding, location: ElementRef, bindings?: ResolvedBinding[]): Promise<ComponentRef>;
+  }
+  
+  class ComponentRef {
+    
+     location: ElementRef;
+    
+     instance: any;
+    
+     dispose: Function;
+    
+     hostView: ViewRef;
+  }
+  
+
+  /**
+   * A wrapper around zones that lets you schedule tasks after it has executed a task.
+   * 
+   * The wrapper maintains an "inner" and an "mount" `Zone`. The application code will executes
+   * in the "inner" zone unless `runOutsideAngular` is explicitely called.
+   * 
+   * A typical application will create a singleton `NgZone`. The outer `Zone` is a fork of the root
+   * `Zone`. The default `onTurnDone` runs the Angular change detection.
+   */
+  class NgZone {
+    
+
+    /**
+     * Sets the zone hook that is called just before Angular event turn starts.
+     * It is called once per browser event.
+     */
+     overrideOnTurnStart(onTurnStartFn: Function): void;
+    
+
+    /**
+     * Sets the zone hook that is called immediately after Angular processes
+     * all pending microtasks.
+     */
+     overrideOnTurnDone(onTurnDoneFn: Function): void;
+    
+
+    /**
+     * Sets the zone hook that is called immediately after the last turn in
+     * an event completes. At this point Angular will no longer attempt to
+     * sync the UI. Any changes to the data model will not be reflected in the
+     * DOM. `onEventDoneFn` is executed outside Angular zone.
+     * 
+     * This hook is useful for validating application state (e.g. in a test).
+     */
+     overrideOnEventDone(onEventDoneFn: Function): void;
+    
+
+    /**
+     * Sets the zone hook that is called when an error is uncaught in the
+     * Angular zone. The first argument is the error. The second argument is
+     * the stack trace.
+     */
+     overrideOnErrorHandler(errorHandlingFn: Function): void;
+    
+
+    /**
+     * Runs `fn` in the inner zone and returns whatever it returns.
+     * 
+     * In a typical app where the inner zone is the Angular zone, this allows one to make use of the
+     * Angular's auto digest mechanism.
+     * 
+     * ```
+     * var zone: NgZone = [ref to the application zone];
+     * 
+     * zone.run(() => {
+     *   // the change detection will run after this function and the microtasks it enqueues have
+     * executed.
+     * });
+     * ```
+     */
+     run(fn: () => any): any;
+    
+
+    /**
+     * Runs `fn` in the outer zone and returns whatever it returns.
+     * 
+     * In a typical app where the inner zone is the Angular zone, this allows one to escape Angular's
+     * auto-digest mechanism.
+     * 
+     * ```
+     * var zone: NgZone = [ref to the application zone];
+     * 
+     * zone.runOusideAngular(() => {
+     *   element.onClick(() => {
+     *     // Clicking on the element would not trigger the change detection
+     *   });
+     * });
+     * ```
+     */
+     runOutsideAngular(fn: () => any): any;
+  }
+  
+  class Observable {
+    
+     observer(generator: any): Object;
+  }
+  
+
+  /**
+   * Use Rx.Observable but provides an adapter to make it work as specified here:
+   * https://github.com/jhusain/observable-spec
+   * 
+   * Once a reference implementation of the spec is available, switch to it.
+   */
+  class EventEmitter extends Observable {
+    
+     observer(generator: any): Rx.IDisposable;
+    
+     toRx(): Rx.Observable<any>;
+    
+     next(value: any): void;
+    
+     throw(error: any): void;
+    
+     return(value?: any): void;
+  }
+  
+
+  /**
+   * A parameter metadata that specifies a dependency.
+   * 
+   * ```
+   * class AComponent {
+   *   constructor(@Inject(MyService) aService:MyService) {}
+   * }
+   * ```
+   */
+  class InjectMetadata {
+    
+     token: void;
+    
+     toString(): string;
+  }
+  
+
+  /**
+   * A parameter metadata that marks a dependency as optional. {@link Injector} provides `null` if
+   * the dependency is not found.
+   * 
+   * ```
+   * class AComponent {
+   *   constructor(@Optional() aService:MyService) {
+   *     this.aService = aService;
+   *   }
+   * }
+   * ```
+   */
+  class OptionalMetadata {
+    
+     toString(): string;
+  }
+  
+
+  /**
+   * A marker metadata that marks a class as available to `Injector` for creation. Used by tooling
+   * for generating constructor stubs.
+   * 
+   * ```
+   * class NeedsService {
+   *   constructor(svc:UsefulService) {}
+   * }
+   * 
+   * @Injectable
+   * class UsefulService {}
+   * ```
+   */
+  class InjectableMetadata {
+  }
+  
+
+  /**
+   * Specifies how injector should resolve a dependency.
+   * 
+   * See {@link Self}, {@link Ancestor}, {@link Unbounded}.
+   */
+  class VisibilityMetadata {
+    
+     crossBoundaries: boolean;
+    
+     includeSelf: boolean;
+    
+     toString(): string;
+  }
+  
+
+  /**
+   * Specifies that an injector should retrieve a dependency from itself.
+   * 
+   * ## Example
+   * 
+   * ```
+   * class Dependency {
+   * }
+   * 
+   * class NeedsDependency {
+   *   constructor(public @Self() dependency:Dependency) {}
+   * }
+   * 
+   * var inj = Injector.resolveAndCreate([Dependency, NeedsDependency]);
+   * var nd = inj.get(NeedsDependency);
+   * expect(nd.dependency).toBeAnInstanceOf(Dependency);
+   * ```
+   */
+  class SelfMetadata extends VisibilityMetadata {
+    
+     toString(): string;
+  }
+  
+
+  /**
+   * Specifies that an injector should retrieve a dependency from any ancestor from the same boundary.
+   * 
+   * ## Example
+   * 
+   * ```
+   * class Dependency {
+   * }
+   * 
+   * class NeedsDependency {
+   *   constructor(public @Ancestor() dependency:Dependency) {}
+   * }
+   * 
+   * var parent = Injector.resolveAndCreate([
+   *   bind(Dependency).toClass(AncestorDependency)
+   * ]);
+   * var child = parent.resolveAndCreateChild([]);
+   * var grandChild = child.resolveAndCreateChild([NeedsDependency, Depedency]);
+   * var nd = grandChild.get(NeedsDependency);
+   * expect(nd.dependency).toBeAnInstanceOf(AncestorDependency);
+   * ```
+   * 
+   * You can make an injector to retrive a dependency either from itself or its ancestor by setting
+   * self to true.
+   * 
+   * ```
+   * class NeedsDependency {
+   *   constructor(public @Ancestor({self:true}) dependency:Dependency) {}
+   * }
+   * ```
+   */
+  class AncestorMetadata extends VisibilityMetadata {
+    
+     toString(): string;
+  }
+  
+
+  /**
+   * Specifies that an injector should retrieve a dependency from any ancestor, crossing boundaries.
+   * 
+   * ## Example
+   * 
+   * ```
+   * class Dependency {
+   * }
+   * 
+   * class NeedsDependency {
+   *   constructor(public @Ancestor() dependency:Dependency) {}
+   * }
+   * 
+   * var parent = Injector.resolveAndCreate([
+   *   bind(Dependency).toClass(AncestorDependency)
+   * ]);
+   * var child = parent.resolveAndCreateChild([]);
+   * var grandChild = child.resolveAndCreateChild([NeedsDependency, Depedency]);
+   * var nd = grandChild.get(NeedsDependency);
+   * expect(nd.dependency).toBeAnInstanceOf(AncestorDependency);
+   * ```
+   * 
+   * You can make an injector to retrive a dependency either from itself or its ancestor by setting
+   * self to true.
+   * 
+   * ```
+   * class NeedsDependency {
+   *   constructor(public @Ancestor({self:true}) dependency:Dependency) {}
+   * }
+   * ```
+   */
+  class UnboundedMetadata extends VisibilityMetadata {
+    
+     toString(): string;
+  }
+  
+
+  /**
+   * `DependencyMetadata is used by the framework to extend DI.
+   * 
+   * Only metadata implementing `DependencyMetadata` are added to the list of dependency
+   * properties.
+   * 
+   * For example:
+   * 
+   * ```
+   * class Exclude extends DependencyMetadata {}
+   * class NotDependencyProperty {}
+   * 
+   * class AComponent {
+   *   constructor(@Exclude @NotDependencyProperty aService:AService) {}
+   * }
+   * ```
+   * 
+   * will create the following dependency:
+   * 
+   * ```
+   * new Dependency(Key.get(AService), [new Exclude()])
+   * ```
+   * 
+   * The framework can use `new Exclude()` to handle the `aService` dependency
+   * in a specific way.
+   */
+  class DependencyMetadata {
+    
+     token: void;
+  }
+  
+  const DEFAULT_VISIBILITY : VisibilityMetadata ;
+  
+
+  /**
+   * Allows to refer to references which are not yet defined.
+   * 
+   * This situation arises when the key which we need te refer to for the purposes of DI is declared,
+   * but not yet defined.
+   * 
+   * ## Example:
+   * 
+   * ```
+   * class Door {
+   *   // Incorrect way to refer to a reference which is defined later.
+   *   // This fails because `Lock` is undefined at this point.
+   *   constructor(lock:Lock) { }
+   * 
+   *   // Correct way to refer to a reference which is defined later.
+   *   // The reference needs to be captured in a closure.
+   *   constructor(@Inject(forwardRef(() => Lock)) lock:Lock) { }
+   * }
+   * 
+   * // Only at this point the lock is defined.
+   * class Lock {
+   * }
+   * ```
+   */
+  function forwardRef(forwardRefFn: ForwardRefFn) : Type ;
+  
+
+  /**
+   * Lazily retrieve the reference value.
+   * 
+   * See: {@link forwardRef}
+   */
+  function resolveForwardRef(type: any) : any ;
+  
+  interface ForwardRefFn {
+    
+     (): any;
+  
+  }
+  
+
+  /**
+   * A dependency injection container used for resolving dependencies.
+   * 
+   * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
+   * constructor dependencies.
+   * In typical use, application code asks for the dependencies in the constructor and they are
+   * resolved by the `Injector`.
+   * 
+   * ## Example:
+   * 
+   * Suppose that we want to inject an `Engine` into class `Car`, we would define it like this:
+   * 
+   * ```javascript
+   * class Engine {
+   * }
+   * 
+   * class Car {
+   *   constructor(@Inject(Engine) engine) {
+   *   }
+   * }
+   * 
+   * ```
+   * 
+   * Next we need to write the code that creates and instantiates the `Injector`. We then ask for the
+   * `root` object, `Car`, so that the `Injector` can recursively build all of that object's
+   * dependencies.
+   * 
+   * ```javascript
+   * main() {
+   *   var injector = Injector.resolveAndCreate([Car, Engine]);
+   * 
+   *   // Get a reference to the `root` object, which will recursively instantiate the tree.
+   *   var car = injector.get(Car);
+   * }
+   * ```
+   * Notice that we don't use the `new` operator because we explicitly want to have the `Injector`
+   * resolve all of the object's dependencies automatically.
+   */
+  class Injector {
+    
+
+    /**
+     * Returns debug information about the injector.
+     * 
+     * This information is included into exceptions thrown by the injector.
+     */
+     debugContext(): any;
+    
+
+    /**
+     * Retrieves an instance from the injector.
+     * 
+     * @param `token`: usually the `Type` of an object. (Same as the token used while setting up a
+     * binding).
+     * @returns an instance represented by the token. Throws if not found.
+     */
+     get(token: any): any;
+    
+
+    /**
+     * Retrieves an instance from the injector.
+     * 
+     * @param `token`: usually a `Type`. (Same as the token used while setting up a binding).
+     * @returns an instance represented by the token. Returns `null` if not found.
+     */
+     getOptional(token: any): any;
+    
+
+    /**
+     * Retrieves an instance from the injector.
+     * 
+     * @param `index`: index of an instance.
+     * @returns an instance represented by the index. Throws if not found.
+     */
+     getAt(index: number): any;
+    
+
+    /**
+     * Direct parent of this injector.
+     */
+     parent: Injector;
+    
+
+    /**
+     * Internal. Do not use.
+     * 
+     * We return `any` not to export the InjectorStrategy type.
+     */
+     internalStrategy: any;
+    
+
+    /**
+     * Creates a child injector and loads a new set of bindings into it.
+     * 
+     * A resolution is a process of flattening multiple nested lists and converting individual
+     * bindings into a list of {@link ResolvedBinding}s. The resolution can be cached by `resolve`
+     * for the {@link Injector} for performance-sensitive code.
+     * 
+     * @param `bindings` can be a list of `Type`, {@link Binding}, {@link ResolvedBinding}, or a
+     * recursive list of more bindings.
+     * @param `depProvider`
+     */
+     resolveAndCreateChild(bindings: List<Type | Binding | List<any>>, depProvider?: DependencyProvider): Injector;
+    
+
+    /**
+     * Creates a child injector and loads a new set of {@link ResolvedBinding}s into it.
+     * 
+     * @param `bindings`: A sparse list of {@link ResolvedBinding}s.
+     * See `resolve` for the {@link Injector}.
+     * @param `depProvider`
+     * @returns a new child {@link Injector}.
+     */
+     createChildFromResolved(bindings: List<ResolvedBinding>, depProvider?: DependencyProvider): Injector;
+    
+     displayName: string;
+    
+     toString(): string;
+  }
+  
+  class ProtoInjector {
+    
+     numberOfBindings: number;
+    
+     getBindingAtIndex(index: number): any;
+  }
+  
+  class BindingWithVisibility {
+    
+     binding: ResolvedBinding;
+    
+     visibility: number;
+    
+     getKeyId(): number;
+  }
+  
+
+  /**
+   * Used to provide dependencies that cannot be easily expressed as bindings.
+   */
+  interface DependencyProvider {
+    
+     getDependency(injector: Injector, binding: ResolvedBinding, dependency: Dependency): any;
+  }
+  
+  const PUBLIC_AND_PRIVATE : number ;
+  
+  const PUBLIC : number ;
+  
+  const PRIVATE : number ;
+  
+  const undefinedValue : Object ;
+  
+
+  /**
+   * Describes how the {@link Injector} should instantiate a given token.
+   * 
+   * See {@link bind}.
+   * 
+   * ## Example
+   * 
+   * ```javascript
+   * var injector = Injector.resolveAndCreate([
+   *   new Binding(String, { toValue: 'Hello' })
+   * ]);
+   * 
+   * expect(injector.get(String)).toEqual('Hello');
+   * ```
+   */
+  class Binding {
+    
+
+    /**
+     * Token used when retrieving this binding. Usually the `Type`.
+     */
+     token: void;
+    
+
+    /**
+     * Binds an interface to an implementation / subclass.
+     * 
+     * ## Example
+     * 
+     * Becuse `toAlias` and `toClass` are often confused, the example contains both use cases for easy
+     * comparison.
+     * 
+     * ```javascript
+     * 
+     * class Vehicle {}
+     * 
+     * class Car extends Vehicle {}
+     * 
+     * var injectorClass = Injector.resolveAndCreate([
+     *   Car,
+     *   new Binding(Vehicle, { toClass: Car })
+     * ]);
+     * var injectorAlias = Injector.resolveAndCreate([
+     *   Car,
+     *   new Binding(Vehicle, { toAlias: Car })
+     * ]);
+     * 
+     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
+     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
+     * 
+     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
+     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
+     * ```
+     */
+     toClass: Type;
+    
+
+    /**
+     * Binds a key to a value.
+     * 
+     * ## Example
+     * 
+     * ```javascript
+     * var injector = Injector.resolveAndCreate([
+     *   new Binding(String, { toValue: 'Hello' })
+     * ]);
+     * 
+     * expect(injector.get(String)).toEqual('Hello');
+     * ```
+     */
+     toValue: void;
+    
+
+    /**
+     * Binds a key to the alias for an existing key.
+     * 
+     * An alias means that {@link Injector} returns the same instance as if the alias token was used.
+     * This is in contrast to `toClass` where a separate instance of `toClass` is returned.
+     * 
+     * ## Example
+     * 
+     * Becuse `toAlias` and `toClass` are often confused the example contains both use cases for easy
+     * comparison.
+     * 
+     * ```javascript
+     * 
+     * class Vehicle {}
+     * 
+     * class Car extends Vehicle {}
+     * 
+     * var injectorAlias = Injector.resolveAndCreate([
+     *   Car,
+     *   new Binding(Vehicle, { toAlias: Car })
+     * ]);
+     * var injectorClass = Injector.resolveAndCreate([
+     *   Car,
+     *   new Binding(Vehicle, { toClass: Car })
+     * ]);
+     * 
+     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
+     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
+     * 
+     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
+     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
+     * ```
+     */
+     toAlias: void;
+    
+
+    /**
+     * Binds a key to a function which computes the value.
+     * 
+     * ## Example
+     * 
+     * ```javascript
+     * var injector = Injector.resolveAndCreate([
+     *   new Binding(Number, { toFactory: () => { return 1+2; }}),
+     *   new Binding(String, { toFactory: (value) => { return "Value: " + value; },
+     *                         dependencies: [Number] })
+     * ]);
+     * 
+     * expect(injector.get(Number)).toEqual(3);
+     * expect(injector.get(String)).toEqual('Value: 3');
+     * ```
+     */
+     toFactory: Function;
+    
+
+    /**
+     * Used in conjunction with `toFactory` and specifies a set of dependencies
+     * (as `token`s) which should be injected into the factory function.
+     * 
+     * ## Example
+     * 
+     * ```javascript
+     * var injector = Injector.resolveAndCreate([
+     *   new Binding(Number, { toFactory: () => { return 1+2; }}),
+     *   new Binding(String, { toFactory: (value) => { return "Value: " + value; },
+     *                         dependencies: [Number] })
+     * ]);
+     * 
+     * expect(injector.get(Number)).toEqual(3);
+     * expect(injector.get(String)).toEqual('Value: 3');
+     * ```
+     */
+     dependencies: List<any>;
+    
+
+    /**
+     * Converts the {@link Binding} into {@link ResolvedBinding}.
+     * 
+     * {@link Injector} internally only uses {@link ResolvedBinding}, {@link Binding} contains
+     * convenience binding syntax.
+     */
+     resolve(): ResolvedBinding;
+  }
+  
+
+  /**
+   * Helper class for the {@link bind} function.
+   */
+  class BindingBuilder {
+    
+     token: void;
+    
+
+    /**
+     * Binds an interface to an implementation / subclass.
+     * 
+     * ## Example
+     * 
+     * Because `toAlias` and `toClass` are often confused, the example contains both use cases for
+     * easy comparison.
+     * 
+     * ```javascript
+     * 
+     * class Vehicle {}
+     * 
+     * class Car extends Vehicle {}
+     * 
+     * var injectorClass = Injector.resolveAndCreate([
+     *   Car,
+     *   bind(Vehicle).toClass(Car)
+     * ]);
+     * var injectorAlias = Injector.resolveAndCreate([
+     *   Car,
+     *   bind(Vehicle).toAlias(Car)
+     * ]);
+     * 
+     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
+     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
+     * 
+     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
+     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
+     * ```
+     */
+     toClass(type: Type): Binding;
+    
+
+    /**
+     * Binds a key to a value.
+     * 
+     * ## Example
+     * 
+     * ```javascript
+     * var injector = Injector.resolveAndCreate([
+     *   bind(String).toValue('Hello')
+     * ]);
+     * 
+     * expect(injector.get(String)).toEqual('Hello');
+     * ```
+     */
+     toValue(value: any): Binding;
+    
+
+    /**
+     * Binds a key to the alias for an existing key.
+     * 
+     * An alias means that we will return the same instance as if the alias token was used. (This is
+     * in contrast to `toClass` where a separate instance of `toClass` will be returned.)
+     * 
+     * ## Example
+     * 
+     * Becuse `toAlias` and `toClass` are often confused, the example contains both use cases for easy
+     * comparison.
+     * 
+     * ```javascript
+     * 
+     * class Vehicle {}
+     * 
+     * class Car extends Vehicle {}
+     * 
+     * var injectorAlias = Injector.resolveAndCreate([
+     *   Car,
+     *   bind(Vehicle).toAlias(Car)
+     * ]);
+     * var injectorClass = Injector.resolveAndCreate([
+     *   Car,
+     *   bind(Vehicle).toClass(Car)
+     * ]);
+     * 
+     * expect(injectorAlias.get(Vehicle)).toBe(injectorAlias.get(Car));
+     * expect(injectorAlias.get(Vehicle) instanceof Car).toBe(true);
+     * 
+     * expect(injectorClass.get(Vehicle)).not.toBe(injectorClass.get(Car));
+     * expect(injectorClass.get(Vehicle) instanceof Car).toBe(true);
+     * ```
+     */
+     toAlias(aliasToken: /*Type*/ any): Binding;
+    
+
+    /**
+     * Binds a key to a function which computes the value.
+     * 
+     * ## Example
+     * 
+     * ```javascript
+     * var injector = Injector.resolveAndCreate([
+     *   bind(Number).toFactory(() => { return 1+2; }),
+     *   bind(String).toFactory((v) => { return "Value: " + v; }, [Number])
+     * ]);
+     * 
+     * expect(injector.get(Number)).toEqual(3);
+     * expect(injector.get(String)).toEqual('Value: 3');
+     * ```
+     */
+     toFactory(factoryFunction: Function, dependencies?: List<any>): Binding;
+  }
+  
+
+  /**
+   * An internal resolved representation of a {@link Binding} used by the {@link Injector}.
+   * 
+   * A {@link Binding} is resolved when it has a factory function. Binding to a class, alias, or
+   * value, are just convenience methods, as {@link Injector} only operates on calling factory
+   * functions.
+   */
+  class ResolvedBinding {
+    
+
+    /**
+     * A key, usually a `Type`.
+     */
+     key: Key;
+    
+
+    /**
+     * Factory function which can return an instance of an object represented by a key.
+     */
+     factory: Function;
+    
+
+    /**
+     * Arguments (dependencies) to the `factory` function.
+     */
+     dependencies: List<Dependency>;
+  }
+  
+
+  /**
+   * @private
+   */
+  class Dependency {
+    
+     key: Key;
+    
+     optional: boolean;
+    
+     visibility: VisibilityMetadata;
+    
+     properties: List<any>;
+  }
+  
+
+  /**
+   * Provides an API for imperatively constructing {@link Binding}s.
+   * 
+   * This is only relevant for JavaScript. See {@link BindingBuilder}.
+   * 
+   * ## Example
+   * 
+   * ```javascript
+   * bind(MyInterface).toClass(MyClass)
+   * 
+   * ```
+   */
+  function bind(token: any) : BindingBuilder ;
+  
+
+  /**
+   * A unique object used for retrieving items from the {@link Injector}.
+   * 
+   * Keys have:
+   * - a system-wide unique `id`.
+   * - a `token`, usually the `Type` of the instance.
+   * 
+   * Keys are used internally by the {@link Injector} because their system-wide unique `id`s allow the
+   * injector to index in arrays rather than looking up items in maps.
+   */
+  interface Key {
+    
+     token: Object;
+    
+     id: number;
+    
+     displayName: string;
+  }
+  
+
+  /**
+   * @private
+   */
+  class KeyRegistry {
+    
+     get(token: Object): Key;
+    
+     numberOfKeys: number;
+  }
+  
+
+  /**
+   * Type literals is a Dart-only feature. This is here only so we can x-compile
+   * to multiple languages.
+   */
+  class TypeLiteral {
+    
+     type: any;
+  }
+  
+
+  /**
+   * Thrown when trying to retrieve a dependency by `Key` from {@link Injector}, but the
+   * {@link Injector} does not have a {@link Binding} for {@link Key}.
+   */
+  class NoBindingError extends AbstractBindingError {
+  }
+  
+
+  /**
+   * Base class for all errors arising from misconfigured bindings.
+   */
+  class AbstractBindingError extends BaseException {
+    
+     name: string;
+    
+     message: string;
+    
+     keys: List<Key>;
+    
+     injectors: List<Injector>;
+    
+     constructResolvingMessage: Function;
+    
+     addKey(injector: Injector, key: Key): void;
+    
+     context: void;
+    
+     toString(): string;
+  }
+  
+
+  /**
+   * Thrown when dependencies form a cycle.
+   * 
+   * ## Example:
+   * 
+   * ```javascript
+   * class A {
+   *   constructor(b:B) {}
+   * }
+   * class B {
+   *   constructor(a:A) {}
+   * }
+   * ```
+   * 
+   * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
+   */
+  class CyclicDependencyError extends AbstractBindingError {
+  }
+  
+
+  /**
+   * Thrown when a constructing type returns with an Error.
+   * 
+   * The `InstantiationError` class contains the original error plus the dependency graph which caused
+   * this object to be instantiated.
+   */
+  class InstantiationError extends AbstractBindingError {
+    
+     causeKey: Key;
+  }
+  
+
+  /**
+   * Thrown when an object other then {@link Binding} (or `Type`) is passed to {@link Injector}
+   * creation.
+   */
+  class InvalidBindingError extends BaseException {
+    
+     message: string;
+    
+     toString(): string;
+  }
+  
+
+  /**
+   * Thrown when the class has no annotation information.
+   * 
+   * Lack of annotation information prevents the {@link Injector} from determining which dependencies
+   * need to be injected into the constructor.
+   */
+  class NoAnnotationError extends BaseException {
+    
+     name: string;
+    
+     message: string;
+    
+     toString(): string;
+  }
+  
+
+  /**
+   * Thrown when getting an object by index.
+   */
+  class OutOfBoundsError extends BaseException {
+    
+     message: string;
+    
+     toString(): string;
+  }
+  
+  class OpaqueToken {
+    
+     toString(): string;
+  }
+  
+
+  /**
+   * Factory for creating {@link InjectMetadata}.
+   */
+  interface InjectFactory {
+    
+     new(token: any): InjectMetadata;
+  
+    
+     (token: any): any;
+  
+  }
+  
+
+  /**
+   * Factory for creating {@link OptionalMetadata}.
+   */
+  interface OptionalFactory {
+    
+     new(): OptionalMetadata;
+  
+    
+     (): any;
+  
+  }
+  
+
+  /**
+   * Factory for creating {@link InjectableMetadata}.
+   */
+  interface InjectableFactory {
+    
+     new(): InjectableMetadata;
+  
+    
+     (): any;
+  
+  }
+  
+
+  /**
+   * Factory for creating {@link SelfMetadata}.
+   */
+  interface SelfFactory {
+    
+     new(): SelfMetadata;
+  
+    
+     (): any;
+  
+  }
+  
+
+  /**
+   * Factory for creating {@link AncestorMetadata}.
+   */
+  interface AncestorFactory {
+    
+     new(visibility?: {self: boolean}): AncestorMetadata;
+  
+    
+     (visibility?: {self: boolean}): any;
+  
+  }
+  
+
+  /**
+   * Factory for creating {@link UnboundedMetadata}.
+   */
+  interface UnboundedFactory {
+    
+     new(visibility?: {self: boolean}): UnboundedMetadata;
+  
+    
+     (visibility?: {self: boolean}): any;
+  
+  }
+  
+
+  /**
+   * Factory for creating {@link InjectMetadata}.
+   */
+  var Inject : InjectFactory ;
+  
+
+  /**
+   * Factory for creating {@link OptionalMetadata}.
+   */
+  var Optional : OptionalFactory ;
+  
+
+  /**
+   * Factory for creating {@link InjectableMetadata}.
+   */
+  var Injectable : InjectableFactory ;
+  
+
+  /**
+   * Factory for creating {@link SelfMetadata}.
+   */
+  var Self : SelfFactory ;
+  
+
+  /**
+   * Factory for creating {@link AncestorMetadata}.
+   */
+  var Ancestor : AncestorFactory ;
+  
+
+  /**
+   * Factory for creating {@link UnboundedMetadata}.
+   */
+  var Unbounded : UnboundedFactory ;
+  
+
+  /**
+   * Omitting from external API doc as this is really an abstract internal concept.
+   */
+  class AbstractControl {
+    
+     validator: Function;
+    
+     value: any;
+    
+     status: string;
+    
+     valid: boolean;
+    
+     errors: StringMap<string, any>;
+    
+     pristine: boolean;
+    
+     dirty: boolean;
+    
+     touched: boolean;
+    
+     untouched: boolean;
+    
+     valueChanges: Observable;
+    
+     markAsTouched(): void;
+    
+     markAsDirty({onlySelf}?: {onlySelf?: boolean}): void;
+    
+     setParent(parent: ControlGroup | ControlArray): void;
+    
+     updateValidity({onlySelf}?: {onlySelf?: boolean}): void;
+    
+     updateValueAndValidity({onlySelf, emitEvent}?: {onlySelf?: boolean, emitEvent?: boolean}): void;
+    
+     find(path: List<string | number>| string): AbstractControl;
+    
+     getError(errorCode: string, path?: List<string>): any;
+    
+     hasError(errorCode: string, path?: List<string>): boolean;
+  }
+  
+
+  /**
+   * Defines a part of a form that cannot be divided into other controls.
+   * 
+   * `Control` is one of the three fundamental building blocks used to define forms in Angular, along
+   * with
+   * {@link ControlGroup} and {@link ControlArray}.
+   */
+  class Control extends AbstractControl {
+    
+     updateValue(value: any, {onlySelf, emitEvent, emitModelToViewChange}?:
+                  {onlySelf?: boolean, emitEvent?: boolean, emitModelToViewChange?: boolean}): void;
+    
+     registerOnChange(fn: Function): void;
+  }
+  
+
+  /**
+   * Defines a part of a form, of fixed length, that can contain other controls.
+   * 
+   * A ControlGroup aggregates the values and errors of each {@link Control} in the group. Thus, if
+   * one of the controls
+   * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,
+   * the entire group
+   * changes as well.
+   * 
+   * `ControlGroup` is one of the three fundamental building blocks used to define forms in Angular,
+   * along with
+   * {@link Control} and {@link ControlArray}. {@link ControlArray} can also contain other controls,
+   * but is of variable
+   * length.
+   */
+  class ControlGroup extends AbstractControl {
+    
+     controls: StringMap<string, AbstractControl>;
+    
+     addControl(name: string, c: AbstractControl): void;
+    
+     removeControl(name: string): void;
+    
+     include(controlName: string): void;
+    
+     exclude(controlName: string): void;
+    
+     contains(controlName: string): boolean;
+  }
+  
+
+  /**
+   * Defines a part of a form, of variable length, that can contain other controls.
+   * 
+   * A `ControlArray` aggregates the values and errors of each {@link Control} in the group. Thus, if
+   * one of the controls
+   * in a group is invalid, the entire group is invalid. Similarly, if a control changes its value,
+   * the entire group
+   * changes as well.
+   * 
+   * `ControlArray` is one of the three fundamental building blocks used to define forms in Angular,
+   * along with {@link Control} and {@link ControlGroup}. {@link ControlGroup} can also contain
+   * other controls, but is of fixed length.
+   */
+  class ControlArray extends AbstractControl {
+    
+     controls: List<AbstractControl>;
+    
+     at(index: number): AbstractControl;
+    
+     push(control: AbstractControl): void;
+    
+     insert(index: number, control: AbstractControl): void;
+    
+     removeAt(index: number): void;
+    
+     length: number;
+  }
+  
+  class AbstractControlDirective {
+    
+     control: AbstractControl;
+    
+     value: any;
+    
+     valid: boolean;
+    
+     errors: StringMap<string, any>;
+    
+     pristine: boolean;
+    
+     dirty: boolean;
+    
+     touched: boolean;
+    
+     untouched: boolean;
+  }
+  
+
+  /**
+   * An interface that {@link NgFormModel} and {@link NgForm} implement.
+   * 
+   * Only used by the forms module.
+   */
+  interface Form {
+    
+     addControl(dir: NgControl): void;
+    
+     removeControl(dir: NgControl): void;
+    
+     getControl(dir: NgControl): Control;
+    
+     addControlGroup(dir: NgControlGroup): void;
+    
+     removeControlGroup(dir: NgControlGroup): void;
+    
+     getControlGroup(dir: NgControlGroup): ControlGroup;
+    
+     updateModel(dir: NgControl, value: any): void;
+  }
+  
+
+  /**
+   * A directive that contains a group of [NgControl].
+   * 
+   * Only used by the forms module.
+   */
+  class ControlContainer extends AbstractControlDirective {
+    
+     name: string;
+    
+     formDirective: Form;
+    
+     path: List<string>;
+  }
+  
+
+  /**
+   * Creates and binds a control with a specified name to a DOM element.
+   * 
+   * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.
+   * 
+   * # Example
+   * 
+   * In this example, we create the login and password controls.
+   * We can work with each control separately: check its validity, get its value, listen to its
+   *  changes.
+   * 
+   *  ```
+   * @Component({selector: "login-comp"})
+   * @View({
+   *      directives: [formDirectives],
+   *      template: `
+   *              <form #f="form" (submit)='onLogIn(f.value)'>
+   *                Login <input type='text' ng-control='login' #l="form">
+   *                <div *ng-if="!l.valid">Login is invalid</div>
+   * 
+   *                Password <input type='password' ng-control='password'>
+   * 
+   *                <button type='submit'>Log in!</button>
+   *              </form>
+   *      `})
+   * class LoginComp {
+   *  onLogIn(value) {
+   *    // value === {login: 'some login', password: 'some password'}
+   *  }
+   * }
+   *  ```
+   * 
+   * We can also use ng-model to bind a domain model to the form.
+   * 
+   *  ```
+   * @Component({selector: "login-comp"})
+   * @View({
+   *      directives: [formDirectives],
+   *      template: `
+   *              <form (submit)='onLogIn()'>
+   *                Login <input type='text' ng-control='login' [(ng-model)]="credentials.login">
+   *                Password <input type='password' ng-control='password'
+   *  [(ng-model)]="credentials.password">
+   *                <button type='submit'>Log in!</button>
+   *              </form>
+   *      `})
+   * class LoginComp {
+   *  credentials: {login:string, password:string};
+   * 
+   *  onLogIn() {
+   *    // this.credentials.login === "some login"
+   *    // this.credentials.password === "some password"
+   *  }
+   * }
+   *  ```
+   */
+  class NgControlName extends NgControl {
+    
+     update: void;
+    
+     model: any;
+    
+     viewModel: any;
+    
+     ngValidators: QueryList<NgValidator>;
+    
+     onChange(c: StringMap<string, any>): void;
+    
+     onDestroy(): void;
+    
+     viewToModelUpdate(newValue: any): void;
+    
+     path: List<string>;
+    
+     formDirective: any;
+    
+     control: Control;
+    
+     validator: Function;
+  }
+  
+
+  /**
+   * Binds an existing control to a DOM element.
+   * 
+   * # Example
+   * 
+   * In this example, we bind the control to an input element. When the value of the input element
+   * changes, the value of
+   * the control will reflect that change. Likewise, if the value of the control changes, the input
+   * element reflects that
+   * change.
+   * 
+   *  ```
+   * @Component({selector: "login-comp"})
+   * @View({
+   *      directives: [formDirectives],
+   *      template: "<input type='text' [ng-form-control]='loginControl'>"
+   *      })
+   * class LoginComp {
+   *  loginControl:Control;
+   * 
+   *  constructor() {
+   *    this.loginControl = new Control('');
+   *  }
+   * }
+   * 
+   *  ```
+   * 
+   * We can also use ng-model to bind a domain model to the form.
+   * 
+   *  ```
+   * @Component({selector: "login-comp"})
+   * @View({
+   *      directives: [formDirectives],
+   *      template: "<input type='text' [ng-form-control]='loginControl' [(ng-model)]='login'>"
+   *      })
+   * class LoginComp {
+   *  loginControl:Control;
+   *  login:string;
+   * 
+   *  constructor() {
+   *    this.loginControl = new Control('');
+   *  }
+   * }
+   *  ```
+   */
+  class NgFormControl extends NgControl {
+    
+     form: Control;
+    
+     update: void;
+    
+     model: any;
+    
+     viewModel: any;
+    
+     ngValidators: QueryList<NgValidator>;
+    
+     onChange(c: StringMap<string, any>): void;
+    
+     path: List<string>;
+    
+     control: Control;
+    
+     validator: Function;
+    
+     viewToModelUpdate(newValue: any): void;
+  }
+  
+
+  /**
+   * Binds a domain model to the form.
+   * 
+   * # Example
+   *  ```
+   * @Component({selector: "search-comp"})
+   * @View({
+   *      directives: [formDirectives],
+   *      template: `
+   *               <input type='text' [(ng-model)]="searchQuery">
+   *      `})
+   * class SearchComp {
+   *  searchQuery: string;
+   * }
+   *  ```
+   */
+  class NgModel extends NgControl {
+    
+     update: void;
+    
+     model: any;
+    
+     viewModel: any;
+    
+     ngValidators: QueryList<NgValidator>;
+    
+     onChange(c: StringMap<string, any>): void;
+    
+     control: Control;
+    
+     path: List<string>;
+    
+     validator: Function;
+    
+     viewToModelUpdate(newValue: any): void;
+  }
+  
+
+  /**
+   * An abstract class that all control directive extend.
+   * 
+   * It binds a {@link Control} object to a DOM element.
+   */
+  class NgControl extends AbstractControlDirective {
+    
+     name: string;
+    
+     valueAccessor: ControlValueAccessor;
+    
+     validator: Function;
+    
+     path: List<string>;
+    
+     viewToModelUpdate(newValue: any): void;
+  }
+  
+
+  /**
+   * Creates and binds a control group to a DOM element.
+   * 
+   * This directive can only be used as a child of {@link NgForm} or {@link NgFormModel}.
+   * 
+   * # Example
+   * 
+   * In this example, we create the credentials and personal control groups.
+   * We can work with each group separately: check its validity, get its value, listen to its changes.
+   * 
+   *  ```
+   * @Component({selector: "signup-comp"})
+   * @View({
+   *      directives: [formDirectives],
+   *      template: `
+   *              <form #f="form" (submit)='onSignUp(f.value)'>
+   *                <div ng-control-group='credentials' #credentials="form">
+   *                  Login <input type='text' ng-control='login'>
+   *                  Password <input type='password' ng-control='password'>
+   *                </div>
+   *                <div *ng-if="!credentials.valid">Credentials are invalid</div>
+   * 
+   *                <div ng-control-group='personal'>
+   *                  Name <input type='text' ng-control='name'>
+   *                </div>
+   *                <button type='submit'>Sign Up!</button>
+   *              </form>
+   *      `})
+   * class SignupComp {
+   *  onSignUp(value) {
+   *    // value === {personal: {name: 'some name'},
+   *    //  credentials: {login: 'some login', password: 'some password'}}
+   *  }
+   * }
+   * 
+   *  ```
+   */
+  class NgControlGroup extends ControlContainer {
+    
+     onInit(): void;
+    
+     onDestroy(): void;
+    
+     control: ControlGroup;
+    
+     path: List<string>;
+    
+     formDirective: Form;
+  }
+  
+
+  /**
+   * Binds an existing control group to a DOM element.
+   * 
+   * # Example
+   * 
+   * In this example, we bind the control group to the form element, and we bind the login and
+   * password controls to the
+   * login and password elements.
+   * 
+   *  ```
+   * @Component({selector: "login-comp"})
+   * @View({
+   *      directives: [formDirectives],
+   *      template: "<form [ng-form-model]='loginForm'>" +
+   *              "Login <input type='text' ng-control='login'>" +
+   *              "Password <input type='password' ng-control='password'>" +
+   *              "<button (click)="onLogin()">Login</button>" +
+   *              "</form>"
+   *      })
+   * class LoginComp {
+   *  loginForm:ControlGroup;
+   * 
+   *  constructor() {
+   *    this.loginForm = new ControlGroup({
+   *      login: new Control(""),
+   *      password: new Control("")
+   *    });
+   *  }
+   * 
+   *  onLogin() {
+   *    // this.loginForm.value
+   *  }
+   * }
+   * 
+   *  ```
+   * 
+   * We can also use ng-model to bind a domain model to the form.
+   * 
+   *  ```
+   * @Component({selector: "login-comp"})
+   * @View({
+   *      directives: [formDirectives],
+   *      template: "<form [ng-form-model]='loginForm'>" +
+   *              "Login <input type='text' ng-control='login' [(ng-model)]='login'>" +
+   *              "Password <input type='password' ng-control='password' [(ng-model)]='password'>" +
+   *              "<button (click)="onLogin()">Login</button>" +
+   *              "</form>"
+   *      })
+   * class LoginComp {
+   *  credentials:{login:string, password:string}
+   *  loginForm:ControlGroup;
+   * 
+   *  constructor() {
+   *    this.loginForm = new ControlGroup({
+   *      login: new Control(""),
+   *      password: new Control("")
+   *    });
+   *  }
+   * 
+   *  onLogin() {
+   *    // this.credentials.login === 'some login'
+   *    // this.credentials.password === 'some password'
+   *  }
+   * }
+   *  ```
+   */
+  class NgFormModel extends ControlContainer implements Form {
+    
+     form: ControlGroup;
+    
+     directives: List<NgControl>;
+    
+     ngSubmit: void;
+    
+     onChange(_: any): void;
+    
+     formDirective: Form;
+    
+     control: ControlGroup;
+    
+     path: List<string>;
+    
+     addControl(dir: NgControl): void;
+    
+     getControl(dir: NgControl): Control;
+    
+     removeControl(dir: NgControl): void;
+    
+     addControlGroup(dir: NgControlGroup): void;
+    
+     removeControlGroup(dir: NgControlGroup): void;
+    
+     getControlGroup(dir: NgControlGroup): ControlGroup;
+    
+     updateModel(dir: NgControl, value: any): void;
+    
+     onSubmit(): boolean;
+  }
+  
+
+  /**
+   * Creates and binds a form object to a DOM element.
+   * 
+   * # Example
+   * 
+   *  ```
+   * @Component({selector: "signup-comp"})
+   * @View({
+   *      directives: [formDirectives],
+   *      template: `
+   *              <form #f="form" (submit)='onSignUp(f.value)'>
+   *                <div ng-control-group='credentials' #credentials="form">
+   *                  Login <input type='text' ng-control='login'>
+   *                  Password <input type='password' ng-control='password'>
+   *                </div>
+   *                <div *ng-if="!credentials.valid">Credentials are invalid</div>
+   * 
+   *                <div ng-control-group='personal'>
+   *                  Name <input type='text' ng-control='name'>
+   *                </div>
+   *                <button type='submit'>Sign Up!</button>
+   *              </form>
+   *      `})
+   * class SignupComp {
+   *  onSignUp(value) {
+   *    // value === {personal: {name: 'some name'},
+   *    //  credentials: {login: 'some login', password: 'some password'}}
+   *  }
+   * }
+   * 
+   *  ```
+   */
+  class NgForm extends ControlContainer implements Form {
+    
+     form: ControlGroup;
+    
+     ngSubmit: void;
+    
+     formDirective: Form;
+    
+     control: ControlGroup;
+    
+     path: List<string>;
+    
+     controls: StringMap<string, AbstractControl>;
+    
+     addControl(dir: NgControl): void;
+    
+     getControl(dir: NgControl): Control;
+    
+     removeControl(dir: NgControl): void;
+    
+     addControlGroup(dir: NgControlGroup): void;
+    
+     removeControlGroup(dir: NgControlGroup): void;
+    
+     getControlGroup(dir: NgControlGroup): ControlGroup;
+    
+     updateModel(dir: NgControl, value: any): void;
+    
+     onSubmit(): boolean;
+  }
+  
+
+  /**
+   * A bridge between a control and a native element.
+   * 
+   * Please see {@link DefaultValueAccessor} for more information.
+   */
+  interface ControlValueAccessor {
+    
+     writeValue(obj: any): void;
+    
+     registerOnChange(fn: any): void;
+    
+     registerOnTouched(fn: any): void;
+  }
+  
+
+  /**
+   * The default accessor for writing a value and listening to changes that is used by the
+   * {@link NgModel}, {@link NgFormControl}, and {@link NgControlName} directives.
+   * 
+   *  # Example
+   *  ```
+   *  <input type="text" [(ng-model)]="searchQuery">
+   *  ```
+   */
+  class DefaultValueAccessor implements ControlValueAccessor {
+    
+     onChange: void;
+    
+     onTouched: void;
+    
+     cd: NgControl;
+    
+     renderer: Renderer;
+    
+     elementRef: ElementRef;
+    
+     writeValue(value: any): void;
+    
+     ngClassUntouched: boolean;
+    
+     ngClassTouched: boolean;
+    
+     ngClassPristine: boolean;
+    
+     ngClassDirty: boolean;
+    
+     ngClassValid: boolean;
+    
+     ngClassInvalid: boolean;
+    
+     registerOnChange(fn: (_: any) => void): void;
+    
+     registerOnTouched(fn: () => void): void;
+  }
+  
+
+  /**
+   * The accessor for writing a value and listening to changes on a checkbox input element.
+   * 
+   *  # Example
+   *  ```
+   *  <input type="checkbox" [ng-control]="rememberLogin">
+   *  ```
+   */
+  class CheckboxControlValueAccessor implements ControlValueAccessor {
+    
+     onChange: void;
+    
+     onTouched: void;
+    
+     cd: NgControl;
+    
+     renderer: Renderer;
+    
+     elementRef: ElementRef;
+    
+     writeValue(value: any): void;
+    
+     ngClassUntouched: boolean;
+    
+     ngClassTouched: boolean;
+    
+     ngClassPristine: boolean;
+    
+     ngClassDirty: boolean;
+    
+     ngClassValid: boolean;
+    
+     ngClassInvalid: boolean;
+    
+     registerOnChange(fn: (_: any) => {}): void;
+    
+     registerOnTouched(fn: () => {}): void;
+  }
+  
+
+  /**
+   * Marks <option> as dynamic, so Angular can be notified when options change.
+   * 
+   * #Example:
+   * 
+   * ```
+   * <select ng-control="city">
+   *   <option *ng-for="#c of cities" [value]="c"></option>
+   * </select>
+   * ```
+   */
+  class NgSelectOption {
+  }
+  
+
+  /**
+   * The accessor for writing a value and listening to changes on a select element.
+   */
+  class SelectControlValueAccessor implements ControlValueAccessor {
+    
+     value: string;
+    
+     onChange: void;
+    
+     onTouched: void;
+    
+     cd: NgControl;
+    
+     renderer: Renderer;
+    
+     elementRef: ElementRef;
+    
+     writeValue(value: any): void;
+    
+     ngClassUntouched: boolean;
+    
+     ngClassTouched: boolean;
+    
+     ngClassPristine: boolean;
+    
+     ngClassDirty: boolean;
+    
+     ngClassValid: boolean;
+    
+     ngClassInvalid: boolean;
+    
+     registerOnChange(fn: () => any): void;
+    
+     registerOnTouched(fn: () => any): void;
+  }
+  
+
+  /**
+   * A list of all the form directives used as part of a `@View` annotation.
+   * 
+   *  This is a shorthand for importing them each individually.
+   */
+  const formDirectives : List<Type> ;
+  
+
+  /**
+   * Provides a set of validators used by form controls.
+   * 
+   * # Example
+   * 
+   * ```
+   * var loginControl = new Control("", Validators.required)
+   * ```
+   */
+  class Validators {
+  }
+  
+  class NgValidator {
+    
+     validator: Function;
+  }
+  
+  class NgRequiredValidator extends NgValidator {
+    
+     validator: Function;
+  }
+  
+
+  /**
+   * Creates a form object from a user-specified configuration.
+   * 
+   * # Example
+   * 
+   * ```
+   * import {Component, View, bootstrap} from 'angular2/angular2';
+   * import {FormBuilder, Validators, formDirectives, ControlGroup} from 'angular2/forms';
+   * 
+   * @Component({
+   *   selector: 'login-comp',
+   *   viewInjector: [
+   *     FormBuilder
+   *   ]
+   * })
+   * @View({
+   *   template: `
+   *     <form [control-group]="loginForm">
+   *       Login <input control="login">
+   * 
+   *       <div control-group="passwordRetry">
+   *         Password <input type="password" control="password">
+   *         Confirm password <input type="password" control="passwordConfirmation">
+   *       </div>
+   *     </form>
+   *   `,
+   *   directives: [
+   *     formDirectives
+   *   ]
+   * })
+   * class LoginComp {
+   *   loginForm: ControlGroup;
+   * 
+   *   constructor(builder: FormBuilder) {
+   *     this.loginForm = builder.group({
+   *       login: ["", Validators.required],
+   * 
+   *       passwordRetry: builder.group({
+   *         password: ["", Validators.required],
+   *         passwordConfirmation: ["", Validators.required]
+   *       })
+   *     });
+   *   }
+   * }
+   * 
+   * bootstrap(LoginComp)
+   * ```
+   * 
+   * This example creates a {@link ControlGroup} that consists of a `login` {@link Control}, and a
+   * nested
+   * {@link ControlGroup} that defines a `password` and a `passwordConfirmation` {@link Control}:
+   * 
+   * ```
+   *  var loginForm = builder.group({
+   *    login: ["", Validators.required],
+   * 
+   *    passwordRetry: builder.group({
+   *      password: ["", Validators.required],
+   *      passwordConfirmation: ["", Validators.required]
+   *    })
+   *  });
+   * 
+   *  ```
+   */
+  class FormBuilder {
+    
+     group(controlsConfig: StringMap<string, any>, extra?: StringMap<string, any>): ControlGroup;
+    
+     control(value: Object, validator?: Function): Control;
+    
+     array(controlsConfig: List<any>, validator?: Function): ControlArray;
+  }
+  
+  const formInjectables : List<Type> ;
+  
+
+  /**
+   * A collection of the Angular core directives that are likely to be used in each and every Angular
+   * application.
+   * 
+   * This collection can be used to quickly enumerate all the built-in directives in the `@View`
+   * annotation. For example,
+   * instead of writing:
+   * 
+   * ```
+   * import {If, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault} from 'angular2/angular2';
+   * import {OtherDirective} from 'myDirectives';
+   * 
+   * @Component({
+   *  selector: 'my-component'
+   * })
+   * @View({
+   *   templateUrl: 'myComponent.html',
+   *   directives: [If, NgFor, NgSwitch, NgSwitchWhen, NgSwitchDefault, OtherDirective]
+   * })
+   * export class MyComponent {
+   *   ...
+   * }
+   * ```
+   * one could enumerate all the core directives at once:
+   * 
+   * ```
+   * import {coreDirectives} from 'angular2/angular2';
+   * import {OtherDirective} from 'myDirectives';
+   * 
+   * @Component({
+   *  selector: 'my-component'
+   * })
+   * @View({
+   *   templateUrl: 'myComponent.html',
+   *   directives: [coreDirectives, OtherDirective]
+   * })
+   * export class MyComponent {
+   *   ...
+   * }
+   * ```
+   */
+  const coreDirectives : List<Type> ;
+  
+
+  /**
+   * Adds and removes CSS classes based on an {expression} value.
+   * 
+   * The result of expression is used to add and remove CSS classes using the following logic,
+   * based on expression's value type:
+   * - {string} - all the CSS classes (space - separated) are added
+   * - {Array} - all the CSS classes (Array elements) are added
+   * - {Object} - each key corresponds to a CSS class name while values
+   * are interpreted as {boolean} expression. If a given expression
+   * evaluates to {true} a corresponding CSS class is added - otherwise
+   * it is removed.
+   * 
+   * # Example:
+   * 
+   * ```
+   * <div class="message" [class]="{error: errorCount > 0}">
+   *     Please check errors.
+   * </div>
+   * ```
+   */
+  class CSSClass {
+    
+     rawClass: void;
+    
+     onCheck(): void;
+    
+     onDestroy(): void;
+  }
+  
+
+  /**
+   * The `NgFor` directive instantiates a template once per item from an iterable. The context for
+   * each instantiated template inherits from the outer context with the given loop variable set
+   * to the current item from the iterable.
+   * 
+   * It is possible to alias the `index` to a local variable that will be set to the current loop
+   * iteration in the template context.
+   * 
+   * When the contents of the iterator changes, `NgFor` makes the corresponding changes to the DOM:
+   * 
+   * * When an item is added, a new instance of the template is added to the DOM.
+   * * When an item is removed, its template instance is removed from the DOM.
+   * * When items are reordered, their respective templates are reordered in the DOM.
+   * 
+   * # Example
+   * 
+   * ```
+   * <ul>
+   *   <li *ng-for="#error of errors; #i = index">
+   *     Error {{i}} of {{errors.length}}: {{error.message}}
+   *   </li>
+   * </ul>
+   * ```
+   * 
+   * # Syntax
+   * 
+   * - `<li *ng-for="#item of items; #i = index">...</li>`
+   * - `<li template="ng-for #item of items; #i = index">...</li>`
+   * - `<template ng-for #item [ng-for-of]="items" #i="index"><li>...</li></template>`
+   */
+  class NgFor {
+    
+     viewContainer: ViewContainerRef;
+    
+     templateRef: TemplateRef;
+    
+     pipes: Pipes;
+    
+     cdr: ChangeDetectorRef;
+    
+     ngForOf: void;
+    
+     onCheck(): void;
+  }
+  
+  class RecordViewTuple {
+    
+     view: ViewRef;
+    
+     record: any;
+  }
+  
+
+  /**
+   * Removes or recreates a portion of the DOM tree based on an {expression}.
+   * 
+   * If the expression assigned to `ng-if` evaluates to a false value then the element
+   * is removed from the DOM, otherwise a clone of the element is reinserted into the DOM.
+   * 
+   * # Example:
+   * 
+   * ```
+   * <div *ng-if="errorCount > 0" class="error">
+   *   <!-- Error message displayed when the errorCount property on the current context is greater
+   * than 0. -->
+   *   {{errorCount}} errors detected
+   * </div>
+   * ```
+   * 
+   * # Syntax
+   * 
+   * - `<div *ng-if="condition">...</div>`
+   * - `<div template="ng-if condition">...</div>`
+   * - `<template [ng-if]="condition"><div>...</div></template>`
+   */
+  class NgIf {
+    
+     viewContainer: ViewContainerRef;
+    
+     templateRef: TemplateRef;
+    
+     prevCondition: boolean;
+    
+     ngIf: void;
+  }
+  
+
+  /**
+   * The `NgNonBindable` directive tells Angular not to compile or bind the contents of the current
+   * DOM element. This is useful if the element contains what appears to be Angular directives and
+   * bindings but which should be ignored by Angular. This could be the case if you have a site that
+   * displays snippets of code, for instance.
+   * 
+   * Example:
+   * 
+   * ```
+   * <div>Normal: {{1 + 2}}</div> // output "Normal: 3"
+   * <div non-bindable>Ignored: {{1 + 2}}</div> // output "Ignored: {{1 + 2}}"
+   * ```
+   */
+  class NgNonBindable {
+  }
+  
+
+  /**
+   * Adds or removes styles based on an {expression}.
+   * 
+   * When the expression assigned to `ng-style` evaluates to an object, the corresponding element
+   * styles are updated. Style names to update are taken from the object keys and values - from the
+   * corresponding object values.
+   * 
+   * # Example:
+   * 
+   * ```
+   * <div ng-style="{'text-align': alignEpr}"></div>
+   * ```
+   * 
+   * In the above example the `text-align` style will be updated based on the `alignEpr` value
+   * changes.
+   * 
+   * # Syntax
+   * 
+   * - `<div ng-style="{'text-align': alignEpr}"></div>`
+   * - `<div ng-style="styleExp"></div>`
+   */
+  class NgStyle {
+    
+     rawStyle: void;
+    
+     onCheck(): void;
+  }
+  
+  class SwitchView {
+    
+     create(): void;
+    
+     destroy(): void;
+  }
+  
+
+  /**
+   * The `NgSwitch` directive is used to conditionally swap DOM structure on your template based on a
+   * scope expression.
+   * Elements within `NgSwitch` but without `NgSwitchWhen` or `NgSwitchDefault` directives will be
+   * preserved at the location as specified in the template.
+   * 
+   * `NgSwitch` simply chooses nested elements and makes them visible based on which element matches
+   * the value obtained from the evaluated expression. In other words, you define a container element
+   * (where you place the directive), place an expression on the **`[ng-switch]="..."` attribute**),
+   * define any inner elements inside of the directive and place a `[ng-switch-when]` attribute per
+   * element.
+   * The when attribute is used to inform NgSwitch which element to display when the expression is
+   * evaluated. If a matching expression is not found via a when attribute then an element with the
+   * default attribute is displayed.
+   * 
+   * # Example:
+   * 
+   * ```
+   * <ANY [ng-switch]="expression">
+   *   <template [ng-switch-when]="whenExpression1">...</template>
+   *   <template [ng-switch-when]="whenExpression1">...</template>
+   *   <template ng-switch-default>...</template>
+   * </ANY>
+   * ```
+   */
+  class NgSwitch {
+    
+     ngSwitch: void;
+  }
+  
+
+  /**
+   * Defines a case statement as an expression.
+   * 
+   * If multiple `NgSwitchWhen` match the `NgSwitch` value, all of them are displayed.
+   * 
+   * Example:
+   * 
+   * ```
+   * // match against a context variable
+   * <template [ng-switch-when]="contextVariable">...</template>
+   * 
+   * // match against a constant string
+   * <template ng-switch-when="stringValue">...</template>
+   * ```
+   */
+  class NgSwitchWhen {
+    
+     onDestroy(): void;
+    
+     ngSwitchWhen: void;
+  }
+  
+
+  /**
+   * Defines a default case statement.
+   * 
+   * Default case statements are displayed when no `NgSwitchWhen` match the `ng-switch` value.
+   * 
+   * Example:
+   * 
+   * ```
+   * <template ng-switch-default>...</template>
+   * ```
+   */
+  class NgSwitchDefault {
+  }
+  
+
+  /**
+   * Mock Connection to represent a {@link Connection} for tests.
+   */
+  class MockConnection {
+    
+
+    /**
+     * Describes the state of the connection, based on `XMLHttpRequest.readyState`, but with
+     * additional states. For example, state 5 indicates an aborted connection.
+     */
+     readyState: ReadyStates;
+    
+
+    /**
+     * {@link Request} instance used to create the connection.
+     */
+     request: Request;
+    
+
+    /**
+     * {@link EventEmitter} of {@link Response}. Can be subscribed to in order to be notified when a
+     * response is available.
+     */
+     response: EventEmitter;
+    
+
+    /**
+     * Changes the `readyState` of the connection to a custom state of 5 (cancelled).
+     */
+     dispose(): void;
+    
+
+    /**
+     * Sends a mock response to the connection. This response is the value that is emitted to the
+     * {@link EventEmitter} returned by {@link Http}.
+     * 
+     * #Example
+     * 
+     * ```
+     * var connection;
+     * backend.connections.subscribe(c => connection = c);
+     * http.request('data.json').subscribe(res => console.log(res.text()));
+     * connection.mockRespond(new Response('fake response')); //logs 'fake response'
+     * ```
+     */
+     mockRespond(res: Response): void;
+    
+
+    /**
+     * Not yet implemented!
+     * 
+     * Sends the provided {@link Response} to the `downloadObserver` of the `Request`
+     * associated with this connection.
+     */
+     mockDownload(res: Response): void;
+    
+
+    /**
+     * Emits the provided error object as an error to the {@link Response} {@link EventEmitter}
+     * returned
+     * from {@link Http}.
+     */
+     mockError(err?: Error): void;
+  }
+  
+
+  /**
+   * A mock backend for testing the {@link Http} service.
+   * 
+   * This class can be injected in tests, and should be used to override bindings
+   * to other backends, such as {@link XHRBackend}.
+   * 
+   * #Example
+   * 
+   * ```
+   * import {MockBackend, DefaultOptions, Http} from 'angular2/http';
+   * it('should get some data', inject([AsyncTestCompleter], (async) => {
+   *   var connection;
+   *   var injector = Injector.resolveAndCreate([
+   *     MockBackend,
+   *     bind(Http).toFactory((backend, defaultOptions) => {
+   *       return new Http(backend, defaultOptions)
+   *     }, [MockBackend, DefaultOptions])]);
+   *   var http = injector.get(Http);
+   *   var backend = injector.get(MockBackend);
+   *   //Assign any newly-created connection to local variable
+   *   backend.connections.subscribe(c => connection = c);
+   *   http.request('data.json').subscribe((res) => {
+   *     expect(res.text()).toBe('awesome');
+   *     async.done();
+   *   });
+   *   connection.mockRespond(new Response('awesome'));
+   * }));
+   * ```
+   * 
+   * This method only exists in the mock implementation, not in real Backends.
+   */
+  class MockBackend {
+    
+
+    /**
+     * {@link EventEmitter}
+     * of {@link MockConnection} instances that have been created by this backend. Can be subscribed
+     * to in order to respond to connections.
+     * 
+     * #Example
+     * 
+     * ```
+     * import {MockBackend, Http, BaseRequestOptions} from 'angular2/http';
+     * import {Injector} from 'angular2/di';
+     * 
+     * it('should get a response', () => {
+     *   var connection; //this will be set when a new connection is emitted from the backend.
+     *   var text; //this will be set from mock response
+     *   var injector = Injector.resolveAndCreate([
+     *     MockBackend,
+     *     bind(Http).toFactory(backend, options) {
+     *       return new Http(backend, options);
+     *     }, [MockBackend, BaseRequestOptions]]);
+     *   var backend = injector.get(MockBackend);
+     *   var http = injector.get(Http);
+     *   backend.connections.subscribe(c => connection = c);
+     *   http.request('something.json').subscribe(res => {
+     *     text = res.text();
+     *   });
+     *   connection.mockRespond(new Response({body: 'Something'}));
+     *   expect(text).toBe('Something');
+     * });
+     * ```
+     * 
+     * This property only exists in the mock implementation, not in real Backends.
+     */
+     connections: EventEmitter;
+    
+
+    /**
+     * An array representation of `connections`. This array will be updated with each connection that
+     * is created by this backend.
+     * 
+     * This property only exists in the mock implementation, not in real Backends.
+     */
+     connectionsArray: Array<MockConnection>;
+    
+
+    /**
+     * {@link EventEmitter} of {@link MockConnection} instances that haven't yet been resolved (i.e.
+     * with a `readyState`
+     * less than 4). Used internally to verify that no connections are pending via the
+     * `verifyNoPendingRequests` method.
+     * 
+     * This property only exists in the mock implementation, not in real Backends.
+     */
+     pendingConnections: EventEmitter;
+    
+
+    /**
+     * Checks all connections, and raises an exception if any connection has not received a response.
+     * 
+     * This method only exists in the mock implementation, not in real Backends.
+     */
+     verifyNoPendingRequests(): void;
+    
+
+    /**
+     * Can be used in conjunction with `verifyNoPendingRequests` to resolve any not-yet-resolve
+     * connections, if it's expected that there are connections that have not yet received a response.
+     * 
+     * This method only exists in the mock implementation, not in real Backends.
+     */
+     resolveAllConnections(): void;
+    
+
+    /**
+     * Creates a new {@link MockConnection}. This is equivalent to calling `new
+     * MockConnection()`, except that it also will emit the new `Connection` to the `connections`
+     * emitter of this `MockBackend` instance. This method will usually only be used by tests
+     * against the framework itself, not by end-users.
+     */
+     createConnection(req: Request): Connection;
+  }
+  
+
+  /**
+   * Creates `Request` instances from provided values.
+   * 
+   * The Request's interface is inspired by the Request constructor defined in the [Fetch
+   * Spec](https://fetch.spec.whatwg.org/#request-class),
+   * but is considered a static value whose body can be accessed many times. There are other
+   * differences in the implementation, but this is the most significant.
+   */
+  class Request {
+    
+
+    /**
+     * Http method with which to perform the request.
+     * 
+     * Defaults to GET.
+     */
+     method: RequestMethods;
+    
+     mode: RequestModesOpts;
+    
+     credentials: RequestCredentialsOpts;
+    
+
+    /**
+     * Headers object based on the `Headers` class in the [Fetch
+     * Spec](https://fetch.spec.whatwg.org/#headers-class). {@link Headers} class reference.
+     */
+     headers: Headers;
+    
+
+    /**
+     * Url of the remote resource
+     */
+     url: string;
+    
+     cache: RequestCacheOpts;
+    
+
+    /**
+     * Returns the request's body as string, assuming that body exists. If body is undefined, return
+     * empty
+     * string.
+     */
+     text(): String;
+  }
+  
+
+  /**
+   * Creates `Response` instances from provided values.
+   * 
+   * Though this object isn't
+   * usually instantiated by end-users, it is the primary object interacted with when it comes time to
+   * add data to a view.
+   * 
+   * #Example
+   * 
+   * ```
+   * http.request('my-friends.txt').subscribe(response => this.friends = response.text());
+   * ```
+   * 
+   * The Response's interface is inspired by the Response constructor defined in the [Fetch
+   * Spec](https://fetch.spec.whatwg.org/#response-class), but is considered a static value whose body
+   * can be accessed many times. There are other differences in the implementation, but this is the
+   * most significant.
+   */
+  class Response {
+    
+
+    /**
+     * One of "basic", "cors", "default", "error, or "opaque".
+     * 
+     * Defaults to "default".
+     */
+     type: ResponseTypes;
+    
+
+    /**
+     * True if the response's status is within 200-299
+     */
+     ok: boolean;
+    
+
+    /**
+     * URL of response.
+     * 
+     * Defaults to empty string.
+     */
+     url: string;
+    
+
+    /**
+     * Status code returned by server.
+     * 
+     * Defaults to 200.
+     */
+     status: number;
+    
+
+    /**
+     * Text representing the corresponding reason phrase to the `status`, as defined in [ietf rfc 2616
+     * section 6.1.1](https://tools.ietf.org/html/rfc2616#section-6.1.1)
+     * 
+     * Defaults to "OK"
+     */
+     statusText: string;
+    
+
+    /**
+     * Non-standard property
+     * 
+     * Denotes how many of the response body's bytes have been loaded, for example if the response is
+     * the result of a progress event.
+     */
+     bytesLoaded: number;
+    
+
+    /**
+     * Non-standard property
+     * 
+     * Denotes how many bytes are expected in the final response body.
+     */
+     totalBytes: number;
+    
+
+    /**
+     * Headers object based on the `Headers` class in the [Fetch
+     * Spec](https://fetch.spec.whatwg.org/#headers-class).
+     */
+     headers: Headers;
+    
+
+    /**
+     * Not yet implemented
+     */
+     blob(): any;
+    
+
+    /**
+     * Attempts to return body as parsed `JSON` object, or raises an exception.
+     */
+     json(): Object;
+    
+
+    /**
+     * Returns the body as a string, presuming `toString()` can be called on the response body.
+     */
+     text(): string;
+    
+
+    /**
+     * Not yet implemented
+     */
+     arrayBuffer(): any;
+  }
+  
+
+  /**
+   * Interface for options to construct a Request, based on
+   * [RequestInit](https://fetch.spec.whatwg.org/#requestinit) from the Fetch spec.
+   */
+  interface IRequestOptions {
+    
+     url?: string;
+    
+     method?: RequestMethods;
+    
+     headers?: Headers;
+    
+     body?: string;
+    
+     mode?: RequestModesOpts;
+    
+     credentials?: RequestCredentialsOpts;
+    
+     cache?: RequestCacheOpts;
+  }
+  
+
+  /**
+   * Interface for options to construct a Response, based on
+   * [ResponseInit](https://fetch.spec.whatwg.org/#responseinit) from the Fetch spec.
+   */
+  interface IResponseOptions {
+    
+     body?: string | Object | FormData;
+    
+     status?: number;
+    
+     statusText?: string;
+    
+     headers?: Headers;
+    
+     type?: ResponseTypes;
+    
+     url?: string;
+  }
+  
+
+  /**
+   * Abstract class from which real connections are derived.
+   */
+  class Connection {
+    
+     readyState: ReadyStates;
+    
+     request: Request;
+    
+     response: EventEmitter;
+    
+     dispose(): void;
+  }
+  
+
+  /**
+   * Abstract class from which real backends are derived.
+   * 
+   * The primary purpose of a `ConnectionBackend` is to create new connections to fulfill a given
+   * {@link Request}.
+   */
+  class ConnectionBackend {
+    
+     createConnection(request: any): Connection;
+  }
+  
+
+  /**
+   * Injectable version of {@link RequestOptions}, with overridable default values.
+   * 
+   * #Example
+   * 
+   * ```
+   * import {Http, BaseRequestOptions, Request} from 'angular2/http';
+   * ...
+   * class MyComponent {
+   *   constructor(baseRequestOptions:BaseRequestOptions, http:Http) {
+   *     var options = baseRequestOptions.merge({body: 'foobar', url: 'https://foo'});
+   *     var request = new Request(options);
+   *     http.request(request).subscribe(res => this.bars = res.json());
+   *   }
+   * }
+   * 
+   * ```
+   */
+  class BaseRequestOptions extends RequestOptions {
+  }
+  
+
+  /**
+   * Creates a request options object similar to the `RequestInit` description
+   * in the [Fetch
+   * Spec](https://fetch.spec.whatwg.org/#requestinit) to be optionally provided when instantiating a
+   * {@link Request}.
+   * 
+   * All values are null by default.
+   */
+  class RequestOptions implements IRequestOptions {
+    
+
+    /**
+     * Http method with which to execute the request.
+     * 
+     * Defaults to "GET".
+     */
+     method: RequestMethods;
+    
+
+    /**
+     * Headers object based on the `Headers` class in the [Fetch
+     * Spec](https://fetch.spec.whatwg.org/#headers-class).
+     */
+     headers: Headers;
+    
+
+    /**
+     * Body to be used when creating the request.
+     */
+     body: string;
+    
+     mode: RequestModesOpts;
+    
+     credentials: RequestCredentialsOpts;
+    
+     cache: RequestCacheOpts;
+    
+     url: string;
+    
+
+    /**
+     * Creates a copy of the `RequestOptions` instance, using the optional input as values to override
+     * existing values.
+     */
+     merge(options?: IRequestOptions): RequestOptions;
+  }
+  
+
+  /**
+   * Injectable version of {@link ResponseOptions}, with overridable default values.
+   */
+  class BaseResponseOptions extends ResponseOptions {
+    
+     body: string | Object | ArrayBuffer | JSON | FormData | Blob;
+    
+     status: number;
+    
+     headers: Headers;
+    
+     statusText: string;
+    
+     type: ResponseTypes;
+    
+     url: string;
+  }
+  
+
+  /**
+   * Creates a response options object similar to the
+   * [ResponseInit](https://fetch.spec.whatwg.org/#responseinit) description
+   * in the Fetch
+   * Spec to be optionally provided when instantiating a
+   * {@link Response}.
+   * 
+   * All values are null by default.
+   */
+  class ResponseOptions implements IResponseOptions {
+    
+     body: string | Object;
+    
+     status: number;
+    
+     headers: Headers;
+    
+     statusText: string;
+    
+     type: ResponseTypes;
+    
+     url: string;
+    
+     merge(options?: IResponseOptions): ResponseOptions;
+  }
+  
+
+  /**
+   * Creates {@link XHRConnection} instances.
+   * 
+   * This class would typically not be used by end users, but could be
+   * overridden if a different backend implementation should be used,
+   * such as in a node backend.
+   * 
+   * #Example
+   * 
+   * ```
+   * import {Http, MyNodeBackend, httpInjectables, BaseRequestOptions} from 'angular2/http';
+   * @Component({
+   *   viewInjector: [
+   *     httpInjectables,
+   *     bind(Http).toFactory((backend, options) => {
+   *       return new Http(backend, options);
+   *     }, [MyNodeBackend, BaseRequestOptions])]
+   * })
+   * class MyComponent {
+   *   constructor(http:Http) {
+   *     http('people.json').subscribe(res => this.people = res.json());
+   *   }
+   * }
+   * ```
+   */
+  class XHRBackend implements ConnectionBackend {
+    
+     createConnection(request: Request): XHRConnection;
+  }
+  
+
+  /**
+   * Creates connections using `XMLHttpRequest`. Given a fully-qualified
+   * request, an `XHRConnection` will immediately create an `XMLHttpRequest` object and send the
+   * request.
+   * 
+   * This class would typically not be created or interacted with directly inside applications, though
+   * the {@link MockConnection} may be interacted with in tests.
+   */
+  class XHRConnection implements Connection {
+    
+     request: Request;
+    
+
+    /**
+     * Response {@link EventEmitter} which emits a single {@link Response} value on load event of
+     * `XMLHttpRequest`.
+     */
+     response: EventEmitter;
+    
+     readyState: ReadyStates;
+    
+
+    /**
+     * Calls abort on the underlying XMLHttpRequest.
+     */
+     dispose(): void;
+  }
+  
+  class JSONPBackend implements ConnectionBackend {
+    
+     createConnection(request: Request): JSONPConnection;
+  }
+  
+  class JSONPConnection implements Connection {
+    
+     readyState: ReadyStates;
+    
+     request: Request;
+    
+     response: EventEmitter;
+    
+     baseResponseOptions: ResponseOptions;
+    
+     finished(data?: any): void;
+    
+     dispose(): void;
+  }
+  
+
+  /**
+   * Performs http requests using `XMLHttpRequest` as the default backend.
+   * 
+   * `Http` is available as an injectable class, with methods to perform http requests. Calling
+   * `request` returns an {@link EventEmitter} which will emit a single {@link Response} when a
+   * response is received.
+   * 
+   * 
+   * ## Breaking Change
+   * 
+   * Previously, methods of `Http` would return an RxJS Observable directly. For now,
+   * the `toRx()` method of {@link EventEmitter} needs to be called in order to get the RxJS
+   * Subject. `EventEmitter` does not provide combinators like `map`, and has different semantics for
+   * subscribing/observing. This is temporary; the result of all `Http` method calls will be either an
+   * Observable
+   * or Dart Stream when [issue #2794](https://github.com/angular/angular/issues/2794) is resolved.
+   * 
+   * #Example
+   * 
+   * ```
+   * import {Http, httpInjectables} from 'angular2/http';
+   * @Component({selector: 'http-app', viewInjector: [httpInjectables]})
+   * @View({templateUrl: 'people.html'})
+   * class PeopleComponent {
+   *   constructor(http: Http) {
+   *     http.get('people.json')
+   *       //Get the RxJS Subject
+   *       .toRx()
+   *       // Call map on the response observable to get the parsed people object
+   *       .map(res => res.json())
+   *       // Subscribe to the observable to get the parsed people object and attach it to the
+   *       // component
+   *       .subscribe(people => this.people = people);
+   *   }
+   * }
+   * ```
+   * 
+   * To use the {@link EventEmitter} returned by `Http`, simply pass a generator (See "interface
+   * Generator" in the Async Generator spec: https://github.com/jhusain/asyncgenerator) to the
+   * `observer` method of the returned emitter, with optional methods of `next`, `throw`, and `return`.
+   * 
+   * #Example
+   * 
+   * ```
+   * http.get('people.json').observer({next: (value) => this.people = people});
+   * ```
+   * 
+   * The default construct used to perform requests, `XMLHttpRequest`, is abstracted as a "Backend" (
+   * {@link XHRBackend} in this case), which could be mocked with dependency injection by replacing
+   * the {@link XHRBackend} binding, as in the following example:
+   * 
+   * #Example
+   * 
+   * ```
+   * import {MockBackend, BaseRequestOptions, Http} from 'angular2/http';
+   * var injector = Injector.resolveAndCreate([
+   *   BaseRequestOptions,
+   *   MockBackend,
+   *   bind(Http).toFactory(
+   *       function(backend, defaultOptions) {
+   *         return new Http(backend, defaultOptions);
+   *       },
+   *       [MockBackend, BaseRequestOptions])
+   * ]);
+   * var http = injector.get(Http);
+   * http.get('request-from-mock-backend.json').toRx().subscribe((res:Response) => doSomething(res));
+   * ```
+   */
+  class Http {
+    
+
+    /**
+     * Performs any type of http request. First argument is required, and can either be a url or
+     * a {@link Request} instance. If the first argument is a url, an optional {@link RequestOptions}
+     * object can be provided as the 2nd argument. The options object will be merged with the values
+     * of {@link BaseRequestOptions} before performing the request.
+     */
+     request(url: string | Request, options?: IRequestOptions): EventEmitter;
+    
+
+    /**
+     * Performs a request with `get` http method.
+     */
+     get(url: string, options?: IRequestOptions): EventEmitter;
+    
+
+    /**
+     * Performs a request with `post` http method.
+     */
+     post(url: string, body: string, options?: IRequestOptions): EventEmitter;
+    
+
+    /**
+     * Performs a request with `put` http method.
+     */
+     put(url: string, body: string, options?: IRequestOptions): EventEmitter;
+    
+
+    /**
+     * Performs a request with `delete` http method.
+     */
+     delete(url: string, options?: IRequestOptions): EventEmitter;
+    
+
+    /**
+     * Performs a request with `patch` http method.
+     */
+     patch(url: string, body: string, options?: IRequestOptions): EventEmitter;
+    
+
+    /**
+     * Performs a request with `head` http method.
+     */
+     head(url: string, options?: IRequestOptions): EventEmitter;
+  }
+  
+  class Jsonp extends Http {
+    
+
+    /**
+     * Performs any type of http request. First argument is required, and can either be a url or
+     * a {@link Request} instance. If the first argument is a url, an optional {@link RequestOptions}
+     * object can be provided as the 2nd argument. The options object will be merged with the values
+     * of {@link BaseRequestOptions} before performing the request.
+     */
+     request(url: string | Request, options?: IRequestOptions): EventEmitter;
+  }
+  
+
+  /**
+   * Polyfill for [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers), as
+   * specified in the [Fetch Spec](https://fetch.spec.whatwg.org/#headers-class). The only known
+   * difference from the spec is the lack of an `entries` method.
+   */
+  class Headers {
+    
+
+    /**
+     * Appends a header to existing list of header values for a given header name.
+     */
+     append(name: string, value: string): void;
+    
+
+    /**
+     * Deletes all header values for the given name.
+     */
+     delete(name: string): void;
+    
+     forEach(fn: Function): void;
+    
+
+    /**
+     * Returns first header that matches given name.
+     */
+     get(header: string): string;
+    
+
+    /**
+     * Check for existence of header by given name.
+     */
+     has(header: string): boolean;
+    
+
+    /**
+     * Provides names of set headers
+     */
+     keys(): List<string>;
+    
+
+    /**
+     * Sets or overrides header value for given name.
+     */
+     set(header: string, value: string | List<string>): void;
+    
+
+    /**
+     * Returns values of all headers.
+     */
+     values(): List<List<string>>;
+    
+
+    /**
+     * Returns list of header values for a given name.
+     */
+     getAll(header: string): Array<string>;
+    
+
+    /**
+     * This method is not implemented.
+     */
+     entries(): void;
+  }
+  
+
+  /**
+   * Acceptable response types to be associated with a {@link Response}, based on
+   * [ResponseType](https://fetch.spec.whatwg.org/#responsetype) from the Fetch spec.
+   */
+  enum ResponseTypes {
+    Basic,
+    Cors,
+    Default,
+    Error,
+    Opaque
+  }
+  
+
+  /**
+   * All possible states in which a connection can be, based on
+   * [States](http://www.w3.org/TR/XMLHttpRequest/#states) from the `XMLHttpRequest` spec, but with an
+   * additional "CANCELLED" state.
+   */
+  enum ReadyStates {
+    UNSENT,
+    OPEN,
+    HEADERS_RECEIVED,
+    LOADING,
+    DONE,
+    CANCELLED
+  }
+  
+
+  /**
+   * Supported http methods.
+   */
+  enum RequestMethods {
+    GET,
+    POST,
+    PUT,
+    DELETE,
+    OPTIONS,
+    HEAD,
+    PATCH
+  }
+  
+
+  /**
+   * Acceptable credentials option to be associated with a {@link Request}, based on
+   * [RequestCredentials](https://fetch.spec.whatwg.org/#requestcredentials) from the Fetch spec.
+   */
+  enum RequestCredentialsOpts {
+    Omit,
+    SameOrigin,
+    Include
+  }
+  
+
+  /**
+   * Acceptable cache option to be associated with a {@link Request}, based on
+   * [RequestCache](https://fetch.spec.whatwg.org/#requestcache) from the Fetch spec.
+   */
+  enum RequestCacheOpts {
+    Default,
+    NoStore,
+    Reload,
+    NoCache,
+    ForceCache,
+    OnlyIfCached
+  }
+  
+
+  /**
+   * Acceptable origin modes to be associated with a {@link Request}, based on
+   * [RequestMode](https://fetch.spec.whatwg.org/#requestmode) from the Fetch spec.
+   */
+  enum RequestModesOpts {
+    Cors,
+    NoCors,
+    SameOrigin
+  }
+  
+
+  /**
+   * Map-like representation of url search parameters, based on
+   * [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) in the url living standard.
+   */
+  class URLSearchParams {
+    
+     paramsMap: Map<string, List<string>>;
+    
+     rawParams: string;
+    
+     has(param: string): boolean;
+    
+     get(param: string): string;
+    
+     getAll(param: string): List<string>;
+    
+     append(param: string, val: string): void;
+    
+     toString(): string;
+    
+     delete(param: string): void;
+  }
+  
+
+  /**
+   * Provides a basic set of injectables to use the {@link Http} service in any application.
+   * 
+   * #Example
+   * 
+   * ```
+   * import {httpInjectables, Http} from 'angular2/http';
+   * @Component({selector: 'http-app', viewInjector: [httpInjectables]})
+   * @View({template: '{{data}}'})
+   * class MyApp {
+   *   constructor(http:Http) {
+   *     http.request('data.txt').subscribe(res => this.data = res.text());
+   *   }
+   * }
+   * ```
+   */
+  var httpInjectables : List<any> ;
+  
+  var jsonpInjectables : List<any> ;
+  
+  var ApplicationRef: InjectableReference;
+  
+  var Compiler: InjectableReference;
+  
+  var AppViewManager: InjectableReference;
+  
+  var ProtoViewRef: InjectableReference;
+  
+  var Key: InjectableReference;
+  
+}
+
+
+
+declare module "angular2/angular2" {
+  export = ng;
+}
diff --git a/typings/es6-promise/es6-promise.d.ts b/typings/es6-promise/es6-promise.d.ts
new file mode 100644
index 0000000..86c8227
--- /dev/null
+++ b/typings/es6-promise/es6-promise.d.ts
@@ -0,0 +1,73 @@
+// Type definitions for es6-promise
+// Project: https://github.com/jakearchibald/ES6-Promise
+// Definitions by: François de Campredon <https://github.com/fdecampredon/>, vvakame <https://github.com/vvakame>
+// Definitions: https://github.com/borisyankov/DefinitelyTyped
+
+interface Thenable<R> {
+    then<U>(onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Thenable<U>;
+    then<U>(onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void): Thenable<U>;
+}
+
+declare class Promise<R> implements Thenable<R> {
+	/**
+	 * If you call resolve in the body of the callback passed to the constructor,
+	 * your promise is fulfilled with result object passed to resolve.
+	 * If you call reject your promise is rejected with the object passed to resolve.
+	 * For consistency and debugging (eg stack traces), obj should be an instanceof Error.
+	 * Any errors thrown in the constructor callback will be implicitly passed to reject().
+	 */
+	constructor(callback: (resolve : (value?: R | Thenable<R>) => void, reject: (error?: any) => void) => void);
+
+	/**
+	 * onFulfilled is called when/if "promise" resolves. onRejected is called when/if "promise" rejects.
+	 * Both are optional, if either/both are omitted the next onFulfilled/onRejected in the chain is called.
+	 * Both callbacks have a single parameter , the fulfillment value or rejection reason.
+	 * "then" returns a new promise equivalent to the value you return from onFulfilled/onRejected after being passed through Promise.resolve.
+	 * If an error is thrown in the callback, the returned promise rejects with that error.
+	 *
+	 * @param onFulfilled called when/if "promise" resolves
+	 * @param onRejected called when/if "promise" rejects
+	 */
+    then<U>(onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => U | Thenable<U>): Promise<U>;
+    then<U>(onFulfilled?: (value: R) => U | Thenable<U>, onRejected?: (error: any) => void): Promise<U>;
+
+	/**
+	 * Sugar for promise.then(undefined, onRejected)
+	 *
+	 * @param onRejected called when/if "promise" rejects
+	 */
+	catch<U>(onRejected?: (error: any) => U | Thenable<U>): Promise<U>;
+}
+
+declare module Promise {
+	/**
+	 * Make a new promise from the thenable.
+	 * A thenable is promise-like in as far as it has a "then" method.
+	 */
+	function resolve<R>(value?: R | Thenable<R>): Promise<R>;
+
+	/**
+	 * Make a promise that rejects to obj. For consistency and debugging (eg stack traces), obj should be an instanceof Error
+	 */
+	function reject(error: any): Promise<any>;
+
+	/**
+	 * Make a promise that fulfills when every item in the array fulfills, and rejects if (and when) any item rejects.
+	 * the array passed to all can be a mixture of promise-like objects and other objects.
+	 * The fulfillment value is an array (in order) of fulfillment values. The rejection value is the first rejection value.
+	 */
+	function all<R>(promises: (R | Thenable<R>)[]): Promise<R[]>;
+
+	/**
+	 * Make a Promise that fulfills when any item fulfills, and rejects if any item rejects.
+	 */
+	function race<R>(promises: (R | Thenable<R>)[]): Promise<R>;
+}
+
+declare module 'es6-promise' {
+	var foo: typeof Promise; // Temp variable to reference Promise in local context
+	module rsvp {
+		export var Promise: typeof foo;
+	}
+	export = rsvp;
+}
diff --git a/typings/meteor/meteor.d.ts b/typings/meteor/meteor.d.ts
new file mode 100644
index 0000000..ed0c97b
--- /dev/null
+++ b/typings/meteor/meteor.d.ts
@@ -0,0 +1,781 @@
+// Type definitions for Meteor 1.1.0.1
+// Project: http://www.meteor.com/
+// Definitions by: Dave Allen <https://github.com/fullflavedave>
+// Definitions: https://github.com/borisyankov/DefinitelyTyped
+
+/**
+ * These are the modules and interfaces that can't be automatically generated from the Meteor data.js file
+ */
+
+interface EJSONable {
+	[key: string]: number | string | boolean | Object | number[] | string[] | Object[] | Date | Uint8Array | EJSON.CustomType;
+}
+interface JSONable {
+	[key: string]: number | string | boolean | Object | number[] | string[] | Object[];
+}
+interface EJSON extends EJSONable {}
+
+declare module Match {
+	var Any:any;
+	var String:any;
+	var Integer:any;
+	var Boolean:any;
+	var undefined:any;
+	//function null();  // not allowed in TypeScript
+	var Object:any;
+	function Optional(pattern:any):boolean;
+	function ObjectIncluding(dico:any):boolean;
+	function OneOf(...patterns:any[]):any;
+	function Where(condition:any):any;
+}
+
+declare module Meteor {
+	/** Start definitions for Template **/
+	interface Event {
+		type:string;
+		target:HTMLElement;
+		currentTarget:HTMLElement;
+		which: number;
+		stopPropagation():void;
+		stopImmediatePropagation():void;
+		preventDefault():void;
+		isPropagationStopped():boolean;
+		isImmediatePropagationStopped():boolean;
+		isDefaultPrevented():boolean;
+	}
+
+	interface EventHandlerFunction extends Function {
+		(event?:Meteor.Event):void;
+	}
+
+	interface EventMap {
+		[id:string]:Meteor.EventHandlerFunction;
+	}
+	/** End definitions for Template **/
+
+	interface LoginWithExternalServiceOptions {
+		requestPermissions?: string[];
+		requestOfflineToken?: Boolean;
+		forceApprovalPrompt?: Boolean;
+		userEmail?: string;
+		loginStyle?: string;
+	}
+
+	function loginWithMeteorDeveloperAccount(options?: Meteor.LoginWithExternalServiceOptions, callback?: Function): void;
+	function loginWithFacebook(options?: Meteor.LoginWithExternalServiceOptions, callback?: Function): void;
+	function loginWithGithub(options?: Meteor.LoginWithExternalServiceOptions, callback?: Function): void;
+	function loginWithGoogle(options?: Meteor.LoginWithExternalServiceOptions, callback?: Function): void;
+	function loginWithMeetup(options?: Meteor.LoginWithExternalServiceOptions, callback?: Function): void;
+	function loginWithTwitter(options?: Meteor.LoginWithExternalServiceOptions, callback?: Function): void;
+	function loginWithWeibo(options?: Meteor.LoginWithExternalServiceOptions, callback?: Function): void;
+
+	interface UserEmail {
+		address:string;
+		verified:boolean;
+	}
+
+	interface User {
+		_id?:string;
+		username?:string;
+		emails?:Meteor.UserEmail[];
+		createdAt?: number;
+		profile?: any;
+		services?: any;
+	}
+
+	interface SubscriptionHandle {
+		stop(): void;
+		ready(): boolean;
+	}
+
+	interface Tinytest {
+		add(name:string, func:Function):any;
+		addAsync(name:string, func:Function):any;
+	}
+
+	enum StatusEnum {
+		connected,
+		connecting,
+		failed,
+		waiting,
+		offline
+	}
+
+	interface LiveQueryHandle {
+		stop(): void;
+	}
+
+	interface EmailFields {
+		subject?: Function;
+		text?: Function;
+	}
+
+	interface EmailTemplates {
+		from: string;
+		siteName: string;
+		resetPassword: Meteor.EmailFields;
+		enrollAccount:  Meteor.EmailFields;
+		verifyEmail:  Meteor.EmailFields;
+	}
+
+	interface Error {
+		error: number;
+		reason?: string;
+		details?: string;
+	}
+
+	interface Connection {
+		id: string;
+		close: Function;
+		onClose: Function;
+		clientAddress: string;
+		httpHeaders: Object;
+	}
+}
+
+declare module Mongo {
+	interface Selector extends Object {}
+	interface Modifier {}
+	interface SortSpecifier {}
+	interface FieldSpecifier {
+		[id: string]: Number;
+	}
+	enum IdGenerationEnum {
+		STRING,
+		MONGO
+	}
+	interface AllowDenyOptions {
+		insert?: (userId:string, doc:any) => boolean;
+		update?: (userId:string, doc:any, fieldNames:string[], modifier:any) => boolean;
+		remove?: (userId:string, doc:any) => boolean;
+		fetch?: string[];
+		transform?: Function;
+	}
+}
+
+declare module HTTP {
+
+	interface HTTPRequest {
+		content?:string;
+		data?:any;
+		query?:string;
+		params?:{[id:string]:string};
+		auth?:string;
+		headers?:{[id:string]:string};
+		timeout?:number;
+		followRedirects?:boolean;
+	}
+
+	interface HTTPResponse {
+		statusCode?:number;
+		headers?:{[id:string]: string};
+		content?:string;
+		data?:any;
+	}
+
+	function call(method: string, url: string, options?: HTTP.HTTPRequest, asyncCallback?:Function):HTTP.HTTPResponse;
+	function del(url: string, callOptions?: HTTP.HTTPRequest, asyncCallback?: Function): HTTP.HTTPResponse;
+	function get(url: string, callOptions?: HTTP.HTTPRequest, asyncCallback?: Function): HTTP.HTTPResponse;
+	function post(url: string, callOptions?: HTTP.HTTPRequest, asyncCallback?: Function): HTTP.HTTPResponse;
+	function put(url: string, callOptions?: HTTP.HTTPRequest, asyncCallback?: Function): HTTP.HTTPResponse;
+
+}
+
+declare module Email {
+	interface EmailMessage {
+		from: string;
+		to: string|string[];
+		cc?: string|string[];
+		bcc?: string|string[];
+		replyTo?: string|string[];
+		subject: string;
+		text?: string;
+		html?: string;
+		headers?: {[id: string]: string};
+	}
+}
+
+declare module DDP {
+	interface DDPStatic {
+		subscribe(name:string, ...rest:any[]):void;
+		call(method:string, ...parameters:any[]):void;
+		apply(method:string, ...parameters:any[]):void;
+		methods(IMeteorMethodsDictionary:any):any;
+		status():DDPStatus;
+		reconnect():void;
+		disconnect():void;
+		onReconnect():void;
+	}
+
+	interface DDPStatus {
+		connected: boolean;
+		status: Meteor.StatusEnum;
+		retryCount: number;
+		//To turn this into an interval until the next reconnection, use retryTime - (new Date()).getTime()
+		retryTime?: number;
+		reason?: string;
+	}
+}
+
+declare module Random {
+	function id(numberOfChars?: number): string;
+	function secret(numberOfChars?: number): string;
+	function fraction():number;
+	function hexString(numberOfDigits:number):string; // @param numberOfDigits, @returns a random hex string of the given length
+	function choice(array:any[]):string; // @param array, @return a random element in array
+	function choice(str:string):string; // @param str, @return a random char in str
+}
+
+declare module Blaze {
+	interface View {
+		name: string;
+		parentView: Blaze.View;
+		isCreated: boolean;
+		isRendered: boolean;
+		isDestroyed: boolean;
+		renderCount: number;
+		autorun(runFunc: Function): void;
+		onViewCreated(func: Function): void;
+		onViewReady(func: Function): void;
+		onViewDestroyed(func: Function): void;
+		firstNode(): Node;
+		lastNode(): Node;
+		template: Blaze.Template;
+		templateInstance(): any;
+	}
+	interface Template {
+		viewName: string;
+		renderFunction: Function;
+		constructView(): Blaze.View;
+	}
+}
+
+declare module BrowserPolicy {
+
+	interface framing {
+		disallow():void;
+		restrictToOrigin(origin:string):void;
+		allowAll():void;
+	}
+	interface content {
+		allowEval():void;
+		allowInlineStyles():void;
+		allowInlineScripts():void;
+		allowSameOriginForAll():void;
+		allowDataUrlForAll():void;
+		allowOriginForAll(origin:string):void;
+		allowImageOrigin(origin:string):void;
+		allowFrameOrigin(origin:string):void;
+		allowContentTypeSniffing():void;
+		allowAllContentOrigin():void;
+		allowAllContentDataUrl():void;
+		allowAllContentSameOrigin():void;
+
+		disallowAll():void;
+		disallowInlineStyles():void;
+		disallowEval():void;
+		disallowInlineScripts():void;
+		disallowFont():void;
+		disallowObject():void;
+		disallowAllContent():void;
+		//TODO: add the basic content types
+		// allow<content type>Origin(origin)
+		// allow<content type>DataUrl()
+		// allow<content type>SameOrigin()
+		// disallow<content type>()
+	}
+}
+
+declare module Tracker {
+	export var ComputationFunction: (computation: Tracker.Computation) => void;
+
+}
+
+declare var IterationCallback: <T>(doc: T, index: number, cursor: Mongo.Cursor<T>) => void;
+
+/**
+ * These modules and interfaces are automatically generated from the Meteor api.js file
+ */
+declare module Accounts {
+	function changePassword(oldPassword: string, newPassword: string, callback?: Function): void;
+	function config(options: {
+		sendVerificationEmail?: boolean;
+		forbidClientAccountCreation?: boolean;
+		restrictCreationByEmailDomain?: string | Function;
+		loginExpirationInDays?: number;
+		oauthSecretKey?: string;
+	}): void;
+	function createUser(options: {
+		username?: string;
+		email?: string;
+		password?: string;
+		profile?: Object;
+	}, callback?: Function): string;
+	var emailTemplates: Meteor.EmailTemplates;
+	function forgotPassword(options: {
+		email?: string;
+	}, callback?: Function): void;
+	function onCreateUser(func: Function): void;
+	function onEmailVerificationLink(callback: Function): void;
+	function onEnrollmentLink(callback: Function): void;
+	function onLogin(func: Function): {stop: Function};
+	function onLoginFailure(func: Function): {stop: Function};
+	function onResetPasswordLink(callback: Function): void;
+	function resetPassword(token: string, newPassword: string, callback?: Function): void;
+	function sendEnrollmentEmail(userId: string, email?: string): void;
+	function sendResetPasswordEmail(userId: string, email?: string): void;
+	function sendVerificationEmail(userId: string, email?: string): void;
+	function setPassword(userId: string, newPassword: string, options?: {
+		logout?: Object;
+	}): void;
+	var ui: {
+		config(options: {
+			requestPermissions?: Object;
+			requestOfflineToken?: Object;
+			forceApprovalPrompt?: Object;
+			passwordSignupFields?: string;
+		}): void;
+	};
+	function validateLoginAttempt(func: Function): {stop: Function};
+	function validateNewUser(func: Function): void;
+	function verifyEmail(token: string, callback?: Function): void;
+}
+
+declare module App {
+	function accessRule(domainRule: string, options?: {
+		launchExternal?: boolean;
+	}):any; /** TODO: add return value **/
+function configurePlugin(pluginName: string, config: Object): void;
+	function icons(icons: Object): void;
+	function info(options: {
+		id?: string;
+		version?: string;
+		name?: string;
+		description?: string;
+		author?: string;
+		email?: string;
+		website?: string;
+	}): void;
+	function launchScreens(launchScreens: Object): void;
+	function setPreference(name: string, value: string): void;
+}
+
+declare module Assets {
+	function getBinary(assetPath: string, asyncCallback?: Function): EJSON;
+	function getText(assetPath: string, asyncCallback?: Function): string;
+}
+
+declare module Blaze {
+	function Each(argFunc: Function, contentFunc: Function, elseFunc?: Function): Blaze.View;
+	function If(conditionFunc: Function, contentFunc: Function, elseFunc?: Function): Blaze.View;
+	var Template: TemplateStatic;
+	interface TemplateStatic {
+		new(viewName?: string, renderFunction?: Function): Template;
+		// It should be [templateName: string]: TemplateInstance but this is not possible -- user will need to cast to TemplateInstance
+		[templateName: string]: any | Template; // added "any" to make it work
+		head: Template;
+		find(selector:string):Blaze.Template;
+		findAll(selector:string):Blaze.Template[];
+		$:any;
+	}
+	interface Template {
+	}
+
+	var TemplateInstance: TemplateInstanceStatic;
+	interface TemplateInstanceStatic {
+		new(view: Blaze.View): TemplateInstance;
+	}
+	interface TemplateInstance {
+		$(selector: string): any;
+		autorun(runFunc: Function): Object;
+		data: Object;
+		find(selector?: string): Blaze.TemplateInstance;
+		findAll(selector: string): Blaze.TemplateInstance[];
+		firstNode: Object;
+		lastNode: Object;
+		subscribe(name: string, ...args: any[]): Meteor.SubscriptionHandle;
+		subscriptionsReady(): boolean;
+		view: Object;
+	}
+
+	function Unless(conditionFunc: Function, contentFunc: Function, elseFunc?: Function): Blaze.View;
+	var View: ViewStatic;
+	interface ViewStatic {
+		new(name?: string, renderFunction?: Function): View;
+	}
+	interface View {
+	}
+
+	function With(data: Object | Function, contentFunc: Function): Blaze.View;
+	var currentView: Blaze.View;
+	function getData(elementOrView?: HTMLElement | Blaze.View): Object;
+	function getView(element?: HTMLElement): Blaze.View;
+	function isTemplate(value: any): boolean;
+	function remove(renderedView: Blaze.View): void;
+	function render(templateOrView: Template | Blaze.View, parentNode: Node, nextNode?: Node, parentView?: Blaze.View): Blaze.View;
+	function renderWithData(templateOrView: Template | Blaze.View, data: Object | Function, parentNode: Node, nextNode?: Node, parentView?: Blaze.View): Blaze.View;
+	function toHTML(templateOrView: Template | Blaze.View): string;
+	function toHTMLWithData(templateOrView: Template | Blaze.View, data: Object | Function): string;
+}
+
+declare module Cordova {
+	function depends(dependencies:{[id:string]:string}): void;
+}
+
+declare module DDP {
+	function connect(url: string): DDP.DDPStatic;
+}
+
+declare module EJSON {
+	var CustomType: CustomTypeStatic;
+	interface CustomTypeStatic {
+		new(): CustomType;
+	}
+	interface CustomType {
+		clone(): EJSON.CustomType;
+		equals(other: Object): boolean;
+		toJSONValue(): JSON;
+		typeName(): string;
+	}
+
+	function addType(name: string, factory: (val: EJSONable) => JSONable): void;
+	function clone<T>(val:T): T;
+	function equals(a: EJSON, b: EJSON, options?: {
+		keyOrderSensitive?: boolean;
+	}): boolean;
+	function fromJSONValue(val: JSON): any;
+	function isBinary(x: Object): boolean;
+	var newBinary: any;
+	function parse(str: string): EJSON;
+	function stringify(val: EJSON, options?: {
+		indent?: boolean | number | string;
+		canonical?: boolean;
+	}): string;
+	function toJSONValue(val: EJSON): JSON;
+}
+
+declare module Match {
+	function test(value: any, pattern: any): boolean;
+}
+
+declare module Meteor {
+	var Error: ErrorStatic;
+	interface ErrorStatic {
+		new(error: string, reason?: string, details?: string): Error;
+	}
+	interface Error {
+	}
+
+	function absoluteUrl(path?: string, options?: {
+		secure?: boolean;
+		replaceLocalhost?: boolean;
+		rootUrl?: string;
+	}): string;
+	function apply(name: string, args: EJSONable[], options?: {
+		wait?: boolean;
+		onResultReceived?: Function;
+	}, asyncCallback?: Function): any;
+	function call(name: string, ...args: any[]): any;
+	function clearInterval(id: number): void;
+	function clearTimeout(id: number): void;
+	function disconnect(): void;
+	var isClient: boolean;
+	var isCordova: boolean;
+	var isServer: boolean;
+	function loggingIn(): boolean;
+	function loginWith<ExternalService>(options?: {
+		requestPermissions?: string[];
+		requestOfflineToken?: boolean;
+		forceApprovalPrompt?: boolean;
+		userEmail?: string;
+		loginStyle?: string;
+	}, callback?: Function): void;
+	function loginWithPassword(user: Object | string, password: string, callback?: Function): void;
+	function logout(callback?: Function): void;
+	function logoutOtherClients(callback?: Function): void;
+	function methods(methods: Object): void;
+	function onConnection(callback: Function): void;
+	function publish(name: string, func: Function): void;
+	function reconnect(): void;
+	var release: string;
+	function setInterval(func: Function, delay: number): number;
+	function setTimeout(func: Function, delay: number): number;
+	var settings: {[id:string]: any};
+	function startup(func: Function): void;
+	function status(): Meteor.StatusEnum;
+	function subscribe(name: string, ...args: any[]): Meteor.SubscriptionHandle;
+	function user(): Meteor.User;
+	function userId(): string;
+	var users: Mongo.Collection<User>;
+	function wrapAsync(func: Function, context?: Object): any;
+}
+
+declare module Mongo {
+	var Collection: CollectionStatic;
+	interface CollectionStatic {
+		new<T>(name: string, options?: {
+			connection?: Object;
+			idGeneration?: string;
+			transform?: Function;
+		}): Collection<T>;
+	}
+	interface Collection<T> {
+		allow(options: {
+			insert?: (userId:string, doc:any) => boolean;
+			update?: (userId:string, doc:any, fieldNames:string[], modifier:any) => boolean;
+			remove?: (userId:string, doc:any) => boolean;
+			fetch?: string[];
+			transform?: Function;
+		}): boolean;
+		deny(options: {
+			insert?: (userId:string, doc:any) => boolean;
+			update?: (userId:string, doc:any, fieldNames:string[], modifier:any) => boolean;
+			remove?: (userId:string, doc:any) => boolean;
+			fetch?: string[];
+			transform?: Function;
+		}): boolean;
+		find(selector?: Mongo.Selector, options?: {
+			sort?: Mongo.SortSpecifier;
+			skip?: number;
+			limit?: number;
+			fields?: Mongo.FieldSpecifier;
+			reactive?: boolean;
+			transform?: Function;
+		}): Mongo.Cursor<T>;
+		findOne(selector?: Mongo.Selector, options?: {
+			sort?: Mongo.SortSpecifier;
+			skip?: number;
+			fields?: Mongo.FieldSpecifier;
+			reactive?: boolean;
+			transform?: Function;
+		}): T;
+		insert(doc: Object, callback?: Function): string;
+		remove(selector: Mongo.Selector, callback?: Function): void;
+		update(selector: Mongo.Selector, modifier: Mongo.Modifier, options?: {
+			multi?: boolean;
+			upsert?: boolean;
+		}, callback?: Function): number;
+		upsert(selector: Mongo.Selector, modifier: Mongo.Modifier, options?: {
+			multi?: boolean;
+		}, callback?: Function): {numberAffected?: number; insertedId?: string;};
+		_ensureIndex(indexName: string, options?: {[key: string]: any}): void;
+	}
+
+	var Cursor: CursorStatic;
+	interface CursorStatic {
+		new<T>(): Cursor<T>;
+	}
+	interface Cursor<T> {
+		count(): number;
+		fetch(): Array<T>;
+		forEach(callback: <T>(doc: T, index: number, cursor: Mongo.Cursor<T>) => void, thisArg?: any): void;
+		map(callback: <T>(doc: T, index: number, cursor: Mongo.Cursor<T>) => void, thisArg?: any): Array<T>;
+		observe(callbacks: Object): Meteor.LiveQueryHandle;
+		observeChanges(callbacks: Object): Meteor.LiveQueryHandle;
+	}
+
+	var ObjectID: ObjectIDStatic;
+	interface ObjectIDStatic {
+		new(hexString: string): ObjectID;
+	}
+	interface ObjectID {
+	}
+
+}
+
+declare module Npm {
+	function depends(dependencies:{[id:string]:string}): void;
+	function require(name: string): any;
+}
+
+declare module Package {
+	function describe(options: {
+		summary?: string;
+		version?: string;
+		name?: string;
+		git?: string;
+		documentation?: string;
+	}): void;
+	function onTest(func: Function): void;
+	function onUse(func: Function): void;
+	function registerBuildPlugin(options?: {
+		name?: string;
+		use?: string | string[];
+		sources?: string[];
+		npmDependencies?: Object;
+	}): void;
+}
+
+declare module Tracker {
+	function Computation(): void;
+	interface Computation {
+		firstRun: boolean;
+		invalidate(): void;
+		invalidated: boolean;
+		onInvalidate(callback: Function): void;
+		stop(): void;
+		stopped: boolean;
+	}
+
+	var Dependency: DependencyStatic;
+	interface DependencyStatic {
+		new(): Dependency;
+	}
+	interface Dependency {
+		changed(): void;
+		depend(fromComputation?: Tracker.Computation): boolean;
+		hasDependents(): boolean;
+	}
+
+	var active: boolean;
+	function afterFlush(callback: Function): void;
+	function autorun(runFunc: (computation: Tracker.Computation) => void, options?: {
+		onError?: Function;
+	}): Tracker.Computation;
+	var currentComputation: Tracker.Computation;
+	function flush(): void;
+	function nonreactive(func: Function): void;
+	function onInvalidate(callback: Function): void;
+}
+
+declare module Session {
+	function equals(key: string, value: string | number | boolean | any /** Null **/ | any /** Undefined **/): boolean;
+	function get(key: string): any;
+	function set(key: string, value: EJSONable | any /** Undefined **/): void;
+	function setDefault(key: string, value: EJSONable | any /** Undefined **/): void;
+}
+
+declare module HTTP {
+	function call(method: string, url: string, options?: {
+		content?: string;
+		data?: Object;
+		query?: string;
+		params?: Object;
+		auth?: string;
+		headers?: Object;
+		timeout?: number;
+		followRedirects?: boolean;
+		npmRequestOptions?: Object;
+	}, asyncCallback?: Function): HTTP.HTTPResponse;
+	function del(url: string, callOptions?: Object, asyncCallback?: Function): HTTP.HTTPResponse;
+	function get(url: string, callOptions?: Object, asyncCallback?: Function): HTTP.HTTPResponse;
+	function post(url: string, callOptions?: Object, asyncCallback?: Function): HTTP.HTTPResponse;
+	function put(url: string, callOptions?: Object, asyncCallback?: Function): HTTP.HTTPResponse;
+}
+
+declare module Email {
+	function send(options: {
+		from?: string;
+		to?: string | string[];
+		cc?: string | string[];
+		bcc?: string | string[];
+		replyTo?: string | string[];
+		subject?: string;
+		text?: string;
+		html?: string;
+		headers?: Object;
+		attachments?: Object[];
+	}): void;
+}
+
+declare var CompileStep: CompileStepStatic;
+interface CompileStepStatic {
+	new(): CompileStep;
+}
+interface CompileStep {
+	addAsset(options: {
+	}, path: string, data: any /** Buffer **/ | string): any; /** TODO: add return value **/
+	addHtml(options: {
+		section?: string;
+		data?: string;
+	}): any; /** TODO: add return value **/
+	addJavaScript(options: {
+		path?: string;
+		data?: string;
+		sourcePath?: string;
+	}): any; /** TODO: add return value **/
+	addStylesheet(options: {
+	}, path: string, data: string, sourceMap: string): any; /** TODO: add return value **/
+	arch: any; /** TODO: add return value **/
+	declaredExports: any; /** TODO: add return value **/
+	error(options: {
+	}, message: string, sourcePath?: string, line?: number, func?: string): any; /** TODO: add return value **/
+	fileOptions: any; /** TODO: add return value **/
+	fullInputPath: any; /** TODO: add return value **/
+	inputPath: any; /** TODO: add return value **/
+	inputSize: any; /** TODO: add return value **/
+	packageName: any; /** TODO: add return value **/
+	pathForSourceMap: any; /** TODO: add return value **/
+	read(n?: number): any;
+	rootOutputPath: any; /** TODO: add return value **/
+}
+
+declare var PackageAPI: PackageAPIStatic;
+interface PackageAPIStatic {
+	new(): PackageAPI;
+}
+interface PackageAPI {
+	addFiles(filename: string | string[], architecture?: string): void;
+	export(exportedObject: string, architecture?: string): void;
+	imply(packageSpecs: string | string[]): void;
+	use(packageNames: string | string[], architecture?: string, options?: {
+		weak?: boolean;
+		unordered?: boolean;
+	}): void;
+	versionsFrom(meteorRelease: string | string[]): void;
+}
+
+declare var ReactiveVar: ReactiveVarStatic;
+interface ReactiveVarStatic {
+	new<T>(initialValue: T, equalsFunc?: Function): ReactiveVar<T>;
+}
+interface ReactiveVar<T> {
+	get(): T;
+	set(newValue: T): void;
+}
+
+declare var Subscription: SubscriptionStatic;
+interface SubscriptionStatic {
+	new(): Subscription;
+}
+interface Subscription {
+	added(collection: string, id: string, fields: Object): void;
+	changed(collection: string, id: string, fields: Object): void;
+	connection: Meteor.Connection;
+	error(error: Error): void;
+	onStop(func: Function): void;
+	ready(): void;
+	removed(collection: string, id: string): void;
+	stop(): void;
+	userId: string;
+}
+
+declare var Template: TemplateStatic;
+interface TemplateStatic {
+	new(): Template;
+	// It should be [templateName: string]: TemplateInstance but this is not possible -- user will need to cast to TemplateInstance
+	[templateName: string]: any | Template; // added "any" to make it work
+	head: Template;
+	find(selector:string):Blaze.Template;
+	findAll(selector:string):Blaze.Template[];
+	$:any;
+	body: Template;
+	currentData(): {};
+	instance(): Blaze.TemplateInstance;
+	parentData(numLevels?: number): {};
+	registerHelper(name: string, helperFunction: Function): void;
+}
+interface Template {
+	created: Function;
+	destroyed: Function;
+	events(eventMap: {[actions: string]: Function}): void;
+	helpers(helpers:{[id:string]: any}): void;
+	onCreated: Function;
+	onDestroyed: Function;
+	onRendered: Function;
+	rendered: Function;
+}
+
+declare function MethodInvocation(options: {
+}): any; /** TODO: add return value **/
+declare function check(value: any, pattern: any): void;
diff --git a/typings/rx/rx-lite.d.ts b/typings/rx/rx-lite.d.ts
new file mode 100644
index 0000000..84f9914
--- /dev/null
+++ b/typings/rx/rx-lite.d.ts
@@ -0,0 +1,647 @@
+﻿// DefinitelyTyped: partial
+
+// This file contains common part of defintions for rx.d.ts and rx.lite.d.ts
+// Do not include the file separately.
+
+declare module Rx {
+	export module internals {
+		function isEqual(left: any, right: any): boolean;
+		function addRef<T>(xs: Observable<T>, r: { getDisposable(): IDisposable; }): Observable<T>;
+
+		// Priority Queue for Scheduling
+		export class PriorityQueue<TTime> {
+			constructor(capacity: number);
+
+			length: number;
+
+			isHigherPriority(left: number, right: number): boolean;
+			percolate(index: number): void;
+			heapify(index: number): void;
+			peek(): ScheduledItem<TTime>;
+			removeAt(index: number): void;
+			dequeue(): ScheduledItem<TTime>;
+			enqueue(item: ScheduledItem<TTime>): void;
+			remove(item: ScheduledItem<TTime>): boolean;
+
+			static count: number;
+		}
+
+		export class ScheduledItem<TTime> {
+			constructor(scheduler: IScheduler, state: any, action: (scheduler: IScheduler, state: any) => IDisposable, dueTime: TTime, comparer?: (x: TTime, y: TTime) => number);
+
+			scheduler: IScheduler;
+			state: TTime;
+			action: (scheduler: IScheduler, state: any) => IDisposable;
+			dueTime: TTime;
+			comparer: (x: TTime, y: TTime) => number;
+			disposable: SingleAssignmentDisposable;
+
+			invoke(): void;
+			compareTo(other: ScheduledItem<TTime>): number;
+			isCancelled(): boolean;
+			invokeCore(): IDisposable;
+		}
+	}
+
+	export module config {
+		export var Promise: { new <T>(resolver: (resolvePromise: (value: T) => void, rejectPromise: (reason: any) => void) => void): IPromise<T>; };
+	}
+
+	export module helpers {
+		function noop(): void;
+		function notDefined(value: any): boolean;
+		function isScheduler(value: any): boolean;
+		function identity<T>(value: T): T;
+		function defaultNow(): number;
+		function defaultComparer(left: any, right: any): boolean;
+		function defaultSubComparer(left: any, right: any): number;
+		function defaultKeySerializer(key: any): string;
+		function defaultError(err: any): void;
+		function isPromise(p: any): boolean;
+		function asArray<T>(...args: T[]): T[];
+		function not(value: any): boolean;
+		function isFunction(value: any): boolean;
+	}
+
+	export interface IDisposable {
+		dispose(): void;
+	}
+
+	export class CompositeDisposable implements IDisposable {
+		constructor (...disposables: IDisposable[]);
+		constructor (disposables: IDisposable[]);
+
+		isDisposed: boolean;
+		length: number;
+
+		dispose(): void;
+		add(item: IDisposable): void;
+		remove(item: IDisposable): boolean;
+		toArray(): IDisposable[];
+	}
+
+	export class Disposable implements IDisposable {
+		constructor(action: () => void);
+
+		static create(action: () => void): IDisposable;
+		static empty: IDisposable;
+
+		dispose(): void;
+	}
+
+	// Single assignment
+	export class SingleAssignmentDisposable implements IDisposable {
+		constructor();
+
+		isDisposed: boolean;
+		current: IDisposable;
+
+		dispose(): void ;
+		getDisposable(): IDisposable;
+		setDisposable(value: IDisposable): void ;
+	}
+
+	// SerialDisposable it's an alias of SingleAssignmentDisposable
+	export class SerialDisposable extends SingleAssignmentDisposable {
+		constructor();
+	}
+
+	export class RefCountDisposable implements IDisposable {
+		constructor(disposable: IDisposable);
+
+		dispose(): void;
+
+		isDisposed: boolean;
+		getDisposable(): IDisposable;
+	}
+
+	export interface IScheduler {
+		now(): number;
+
+		schedule(action: () => void): IDisposable;
+		scheduleWithState<TState>(state: TState, action: (scheduler: IScheduler, state: TState) => IDisposable): IDisposable;
+		scheduleWithAbsolute(dueTime: number, action: () => void): IDisposable;
+		scheduleWithAbsoluteAndState<TState>(state: TState, dueTime: number, action: (scheduler: IScheduler, state: TState) =>IDisposable): IDisposable;
+		scheduleWithRelative(dueTime: number, action: () => void): IDisposable;
+		scheduleWithRelativeAndState<TState>(state: TState, dueTime: number, action: (scheduler: IScheduler, state: TState) =>IDisposable): IDisposable;
+
+		scheduleRecursive(action: (action: () =>void ) =>void ): IDisposable;
+		scheduleRecursiveWithState<TState>(state: TState, action: (state: TState, action: (state: TState) =>void ) =>void ): IDisposable;
+		scheduleRecursiveWithAbsolute(dueTime: number, action: (action: (dueTime: number) => void) => void): IDisposable;
+		scheduleRecursiveWithAbsoluteAndState<TState>(state: TState, dueTime: number, action: (state: TState, action: (state: TState, dueTime: number) => void) => void): IDisposable;
+		scheduleRecursiveWithRelative(dueTime: number, action: (action: (dueTime: number) =>void ) =>void ): IDisposable;
+		scheduleRecursiveWithRelativeAndState<TState>(state: TState, dueTime: number, action: (state: TState, action: (state: TState, dueTime: number) =>void ) =>void ): IDisposable;
+
+		schedulePeriodic(period: number, action: () => void): IDisposable;
+		schedulePeriodicWithState<TState>(state: TState, period: number, action: (state: TState) => TState): IDisposable;
+	}
+
+	export interface Scheduler extends IScheduler {
+	}
+
+	export interface SchedulerStatic {
+		new (
+			now: () => number,
+			schedule: (state: any, action: (scheduler: IScheduler, state: any) => IDisposable) => IDisposable,
+			scheduleRelative: (state: any, dueTime: number, action: (scheduler: IScheduler, state: any) => IDisposable) => IDisposable,
+			scheduleAbsolute: (state: any, dueTime: number, action: (scheduler: IScheduler, state: any) => IDisposable) => IDisposable): Scheduler;
+
+		normalize(timeSpan: number): number;
+
+		immediate: IScheduler;
+		currentThread: ICurrentThreadScheduler;
+                default: IScheduler; // alias for Scheduler.timeout
+		timeout: IScheduler;
+	}
+
+	export var Scheduler: SchedulerStatic;
+
+	// Current Thread IScheduler
+	interface ICurrentThreadScheduler extends IScheduler {
+		scheduleRequired(): boolean;
+	}
+
+	// Notifications
+	export class Notification<T> {
+		accept(observer: IObserver<T>): void;
+		accept<TResult>(onNext: (value: T) => TResult, onError?: (exception: any) => TResult, onCompleted?: () => TResult): TResult;
+		toObservable(scheduler?: IScheduler): Observable<T>;
+		hasValue: boolean;
+		equals(other: Notification<T>): boolean;
+		kind: string;
+		value: T;
+		exception: any;
+
+		static createOnNext<T>(value: T): Notification<T>;
+		static createOnError<T>(exception: any): Notification<T>;
+		static createOnCompleted<T>(): Notification<T>;
+	}
+
+	/**
+	 * Promise A+
+	 */
+	export interface IPromise<T> {
+		then<R>(onFulfilled: (value: T) => IPromise<R>, onRejected: (reason: any) => IPromise<R>): IPromise<R>;
+		then<R>(onFulfilled: (value: T) => IPromise<R>, onRejected?: (reason: any) => R): IPromise<R>;
+		then<R>(onFulfilled: (value: T) => R, onRejected: (reason: any) => IPromise<R>): IPromise<R>;
+		then<R>(onFulfilled?: (value: T) => R, onRejected?: (reason: any) => R): IPromise<R>;
+	}
+
+	// Observer
+	export interface IObserver<T> {
+		onNext(value: T): void;
+		onError(exception: any): void;
+		onCompleted(): void;
+	}
+
+	export interface Observer<T> extends IObserver<T> {
+		toNotifier(): (notification: Notification<T>) => void;
+		asObserver(): Observer<T>;
+	}
+
+	interface ObserverStatic {
+		create<T>(onNext?: (value: T) => void, onError?: (exception: any) => void, onCompleted?: () => void): Observer<T>;
+		fromNotifier<T>(handler: (notification: Notification<T>, thisArg?: any) => void): Observer<T>;
+	}
+
+	export var Observer: ObserverStatic;
+
+	export interface IObservable<T> {
+		subscribe(observer: Observer<T>): IDisposable;
+		subscribe(onNext?: (value: T) => void, onError?: (exception: any) => void, onCompleted?: () => void): IDisposable;
+
+		subscribeOnNext(onNext: (value: T) => void, thisArg?: any): IDisposable;
+		subscribeOnError(onError: (exception: any) => void, thisArg?: any): IDisposable;
+		subscribeOnCompleted(onCompleted: () => void, thisArg?: any): IDisposable;
+	}
+
+	export interface Observable<T> extends IObservable<T> {
+		forEach(onNext?: (value: T) => void, onError?: (exception: any) => void, onCompleted?: () => void): IDisposable;	// alias for subscribe
+		toArray(): Observable<T[]>;
+
+		catch(handler: (exception: any) => Observable<T>): Observable<T>;
+		catchException(handler: (exception: any) => Observable<T>): Observable<T>;	// alias for catch
+		catch(handler: (exception: any) => IPromise<T>): Observable<T>;
+		catchException(handler: (exception: any) => IPromise<T>): Observable<T>;	// alias for catch
+		catch(second: Observable<T>): Observable<T>;
+		catchException(second: Observable<T>): Observable<T>;	// alias for catch
+		combineLatest<T2, TResult>(second: Observable<T2>, resultSelector: (v1: T, v2: T2) => TResult): Observable<TResult>;
+		combineLatest<T2, TResult>(second: IPromise<T2>, resultSelector: (v1: T, v2: T2) => TResult): Observable<TResult>;
+		combineLatest<T2, T3, TResult>(second: Observable<T2>, third: Observable<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		combineLatest<T2, T3, TResult>(second: Observable<T2>, third: IPromise<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		combineLatest<T2, T3, TResult>(second: IPromise<T2>, third: Observable<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		combineLatest<T2, T3, TResult>(second: IPromise<T2>, third: IPromise<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		combineLatest<T2, T3, T4, TResult>(second: Observable<T2>, third: Observable<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T2, T3, T4, TResult>(second: Observable<T2>, third: Observable<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T2, T3, T4, TResult>(second: Observable<T2>, third: IPromise<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T2, T3, T4, TResult>(second: Observable<T2>, third: IPromise<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T2, T3, T4, TResult>(second: IPromise<T2>, third: Observable<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T2, T3, T4, TResult>(second: IPromise<T2>, third: Observable<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T2, T3, T4, TResult>(second: IPromise<T2>, third: IPromise<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T2, T3, T4, TResult>(second: IPromise<T2>, third: IPromise<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T2, T3, T4, T5, TResult>(second: Observable<T2>, third: Observable<T3>, fourth: Observable<T4>, fifth: Observable<T5>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => TResult): Observable<TResult>;
+		combineLatest<TOther, TResult>(souces: Observable<TOther>[], resultSelector: (firstValue: T, ...otherValues: TOther[]) => TResult): Observable<TResult>;
+		combineLatest<TOther, TResult>(souces: IPromise<TOther>[], resultSelector: (firstValue: T, ...otherValues: TOther[]) => TResult): Observable<TResult>;
+		concat(...sources: Observable<T>[]): Observable<T>;
+		concat(...sources: IPromise<T>[]): Observable<T>;
+		concat(sources: Observable<T>[]): Observable<T>;
+		concat(sources: IPromise<T>[]): Observable<T>;
+		concatAll(): T;
+		concatObservable(): T;	// alias for concatAll
+		concatMap<T2, R>(selector: (value: T, index: number) => Observable<T2>, resultSelector: (value1: T, value2: T2, index: number) => R): Observable<R>;	// alias for selectConcat
+		concatMap<T2, R>(selector: (value: T, index: number) => IPromise<T2>, resultSelector: (value1: T, value2: T2, index: number) => R): Observable<R>;	// alias for selectConcat
+		concatMap<R>(selector: (value: T, index: number) => Observable<R>): Observable<R>;	// alias for selectConcat
+		concatMap<R>(selector: (value: T, index: number) => IPromise<R>): Observable<R>;	// alias for selectConcat
+		concatMap<R>(sequence: Observable<R>): Observable<R>;	// alias for selectConcat
+		merge(maxConcurrent: number): T;
+		merge(other: Observable<T>): Observable<T>;
+		merge(other: IPromise<T>): Observable<T>;
+		mergeAll(): T;
+		mergeObservable(): T;	// alias for mergeAll
+		skipUntil<T2>(other: Observable<T2>): Observable<T>;
+		skipUntil<T2>(other: IPromise<T2>): Observable<T>;
+		switch(): T;
+		switchLatest(): T;	// alias for switch
+		takeUntil<T2>(other: Observable<T2>): Observable<T>;
+		takeUntil<T2>(other: IPromise<T2>): Observable<T>;
+		zip<T2, TResult>(second: Observable<T2>, resultSelector: (v1: T, v2: T2) => TResult): Observable<TResult>;
+		zip<T2, TResult>(second: IPromise<T2>, resultSelector: (v1: T, v2: T2) => TResult): Observable<TResult>;
+		zip<T2, T3, TResult>(second: Observable<T2>, third: Observable<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		zip<T2, T3, TResult>(second: Observable<T2>, third: IPromise<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		zip<T2, T3, TResult>(second: IPromise<T2>, third: Observable<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		zip<T2, T3, TResult>(second: IPromise<T2>, third: IPromise<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		zip<T2, T3, T4, TResult>(second: Observable<T2>, third: Observable<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		zip<T2, T3, T4, TResult>(second: Observable<T2>, third: Observable<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		zip<T2, T3, T4, TResult>(second: Observable<T2>, third: IPromise<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		zip<T2, T3, T4, TResult>(second: Observable<T2>, third: IPromise<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		zip<T2, T3, T4, TResult>(second: IPromise<T2>, third: Observable<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		zip<T2, T3, T4, TResult>(second: IPromise<T2>, third: Observable<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		zip<T2, T3, T4, TResult>(second: IPromise<T2>, third: IPromise<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		zip<T2, T3, T4, TResult>(second: IPromise<T2>, third: IPromise<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		zip<T2, T3, T4, T5, TResult>(second: Observable<T2>, third: Observable<T3>, fourth: Observable<T4>, fifth: Observable<T5>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => TResult): Observable<TResult>;
+		zip<TOther, TResult>(second: Observable<TOther>[], resultSelector: (left: T, ...right: TOther[]) => TResult): Observable<TResult>;
+		zip<TOther, TResult>(second: IPromise<TOther>[], resultSelector: (left: T, ...right: TOther[]) => TResult): Observable<TResult>;
+
+		asObservable(): Observable<T>;
+		dematerialize<TOrigin>(): Observable<TOrigin>;
+		distinctUntilChanged(skipParameter: boolean, comparer: (x: T, y: T) => boolean): Observable<T>;
+		distinctUntilChanged<TValue>(keySelector?: (value: T) => TValue, comparer?: (x: TValue, y: TValue) => boolean): Observable<T>;
+		do(observer: Observer<T>): Observable<T>;
+		doAction(observer: Observer<T>): Observable<T>;	// alias for do
+		tap(observer: Observer<T>): Observable<T>;	// alias for do
+		do(onNext?: (value: T) => void, onError?: (exception: any) => void, onCompleted?: () => void): Observable<T>;
+		doAction(onNext?: (value: T) => void, onError?: (exception: any) => void, onCompleted?: () => void): Observable<T>;	// alias for do
+		tap(onNext?: (value: T) => void, onError?: (exception: any) => void, onCompleted?: () => void): Observable<T>;	// alias for do
+		
+		doOnNext(onNext: (value: T) => void, thisArg?: any): Observable<T>;
+		doOnError(onError: (exception: any) => void, thisArg?: any): Observable<T>;
+		doOnCompleted(onCompleted: () => void, thisArg?: any): Observable<T>;
+		tapOnNext(onNext: (value: T) => void, thisArg?: any): Observable<T>;
+		tapOnError(onError: (exception: any) => void, thisArg?: any): Observable<T>;
+		tapOnCompleted(onCompleted: () => void, thisArg?: any): Observable<T>;
+
+		finally(action: () => void): Observable<T>;
+		finallyAction(action: () => void): Observable<T>;	// alias for finally
+		ignoreElements(): Observable<T>;
+		materialize(): Observable<Notification<T>>;
+		repeat(repeatCount?: number): Observable<T>;
+		retry(retryCount?: number): Observable<T>;
+		scan<TAcc>(seed: TAcc, accumulator: (acc: TAcc, value: T) => TAcc): Observable<TAcc>;
+		scan(accumulator: (acc: T, value: T) => T): Observable<T>;
+		skipLast(count: number): Observable<T>;
+		startWith(...values: T[]): Observable<T>;
+		startWith(scheduler: IScheduler, ...values: T[]): Observable<T>;
+		takeLast(count: number): Observable<T>;
+		takeLastBuffer(count: number): Observable<T[]>;
+
+		select<TResult>(selector: (value: T, index: number, source: Observable<T>) => TResult, thisArg?: any): Observable<TResult>;
+		map<TResult>(selector: (value: T, index: number, source: Observable<T>) => TResult, thisArg?: any): Observable<TResult>;	// alias for select
+		pluck<TResult>(prop: string): Observable<TResult>;
+		selectMany<TOther, TResult>(selector: (value: T) => Observable<TOther>, resultSelector: (item: T, other: TOther) => TResult): Observable<TResult>;
+		selectMany<TOther, TResult>(selector: (value: T) => IPromise<TOther>, resultSelector: (item: T, other: TOther) => TResult): Observable<TResult>;
+		selectMany<TResult>(selector: (value: T) => Observable<TResult>): Observable<TResult>;
+		selectMany<TResult>(selector: (value: T) => IPromise<TResult>): Observable<TResult>;
+		selectMany<TResult>(other: Observable<TResult>): Observable<TResult>;
+		selectMany<TResult>(other: IPromise<TResult>): Observable<TResult>;
+		flatMap<TOther, TResult>(selector: (value: T) => Observable<TOther>, resultSelector: (item: T, other: TOther) => TResult): Observable<TResult>;	// alias for selectMany
+		flatMap<TOther, TResult>(selector: (value: T) => IPromise<TOther>, resultSelector: (item: T, other: TOther) => TResult): Observable<TResult>;	// alias for selectMany
+		flatMap<TResult>(selector: (value: T) => Observable<TResult>): Observable<TResult>;	// alias for selectMany
+		flatMap<TResult>(selector: (value: T) => IPromise<TResult>): Observable<TResult>;	// alias for selectMany
+		flatMap<TResult>(other: Observable<TResult>): Observable<TResult>;	// alias for selectMany
+		flatMap<TResult>(other: IPromise<TResult>): Observable<TResult>;	// alias for selectMany
+
+		selectConcat<T2, R>(selector: (value: T, index: number) => Observable<T2>, resultSelector: (value1: T, value2: T2, index: number) => R): Observable<R>;
+		selectConcat<T2, R>(selector: (value: T, index: number) => IPromise<T2>, resultSelector: (value1: T, value2: T2, index: number) => R): Observable<R>;
+		selectConcat<R>(selector: (value: T, index: number) => Observable<R>): Observable<R>;
+		selectConcat<R>(selector: (value: T, index: number) => IPromise<R>): Observable<R>;
+		selectConcat<R>(sequence: Observable<R>): Observable<R>;
+
+		/**
+		*  Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element's index and then 
+		*  transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
+		* @param selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
+		* @param [thisArg] Object to use as this when executing callback.
+		* @returns An observable sequence whose elements are the result of invoking the transform function on each element of source producing an Observable of Observable sequences 
+		*  and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
+		*/
+		selectSwitch<TResult>(selector: (value: T, index: number, source: Observable<T>) => Observable<TResult>, thisArg?: any): Observable<TResult>;
+		/**
+		*  Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element's index and then 
+		*  transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
+		* @param selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
+		* @param [thisArg] Object to use as this when executing callback.
+		* @returns An observable sequence whose elements are the result of invoking the transform function on each element of source producing an Observable of Observable sequences 
+		*  and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
+		*/
+		flatMapLatest<TResult>(selector: (value: T, index: number, source: Observable<T>) => Observable<TResult>, thisArg?: any): Observable<TResult>;	// alias for selectSwitch
+		/**
+		*  Projects each element of an observable sequence into a new sequence of observable sequences by incorporating the element's index and then 
+		*  transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
+		* @param selector A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
+		* @param [thisArg] Object to use as this when executing callback.
+		* @since 2.2.28
+		* @returns An observable sequence whose elements are the result of invoking the transform function on each element of source producing an Observable of Observable sequences 
+		*  and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
+		*/
+		switchMap<TResult>(selector: (value: T, index: number, source: Observable<T>) => TResult, thisArg?: any): Observable<TResult>;	// alias for selectSwitch
+
+		skip(count: number): Observable<T>;
+		skipWhile(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<T>;
+		take(count: number, scheduler?: IScheduler): Observable<T>;
+		takeWhile(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<T>;
+		where(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<T>;
+		filter(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): Observable<T>; // alias for where
+
+		/**
+		* Converts an existing observable sequence to an ES6 Compatible Promise
+		* @example
+		* var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);
+		* @param promiseCtor The constructor of the promise.
+		* @returns An ES6 compatible promise with the last value from the observable sequence.
+		*/
+		toPromise<TPromise extends IPromise<T>>(promiseCtor: { new (resolver: (resolvePromise: (value: T) => void, rejectPromise: (reason: any) => void) => void): TPromise; }): TPromise;
+		/**
+		* Converts an existing observable sequence to an ES6 Compatible Promise
+		* @example
+		* var promise = Rx.Observable.return(42).toPromise(RSVP.Promise);
+		* 
+		* // With config
+		* Rx.config.Promise = RSVP.Promise;
+		* var promise = Rx.Observable.return(42).toPromise();
+		* @param [promiseCtor] The constructor of the promise. If not provided, it looks for it in Rx.config.Promise.
+		* @returns An ES6 compatible promise with the last value from the observable sequence.
+		*/
+		toPromise(promiseCtor?: { new (resolver: (resolvePromise: (value: T) => void, rejectPromise: (reason: any) => void) => void): IPromise<T>; }): IPromise<T>;
+
+		// Experimental Flattening
+
+		/**
+		* Performs a exclusive waiting for the first to finish before subscribing to another observable.
+		* Observables that come in between subscriptions will be dropped on the floor.
+		* Can be applied on `Observable<Observable<R>>` or `Observable<IPromise<R>>`.
+		* @since 2.2.28
+		* @returns A exclusive observable with only the results that happen when subscribed.
+		*/
+		exclusive<R>(): Observable<R>;
+
+		/**
+		* Performs a exclusive map waiting for the first to finish before subscribing to another observable.
+		* Observables that come in between subscriptions will be dropped on the floor.
+		* Can be applied on `Observable<Observable<I>>` or `Observable<IPromise<I>>`.
+		* @since 2.2.28
+		* @param selector Selector to invoke for every item in the current subscription.
+		* @param [thisArg] An optional context to invoke with the selector parameter.
+		* @returns {An exclusive observable with only the results that happen when subscribed.
+		*/
+		exclusiveMap<I, R>(selector: (value: I, index: number, source: Observable<I>) => R, thisArg?: any): Observable<R>;
+	}
+
+	interface ObservableStatic {
+		create<T>(subscribe: (observer: Observer<T>) => IDisposable): Observable<T>;
+		create<T>(subscribe: (observer: Observer<T>) => () => void): Observable<T>;
+		create<T>(subscribe: (observer: Observer<T>) => void): Observable<T>;
+		createWithDisposable<T>(subscribe: (observer: Observer<T>) => IDisposable): Observable<T>;
+		defer<T>(observableFactory: () => Observable<T>): Observable<T>;
+		defer<T>(observableFactory: () => IPromise<T>): Observable<T>;
+		empty<T>(scheduler?: IScheduler): Observable<T>;
+
+		/**
+		* This method creates a new Observable sequence from an array object.
+		* @param array An array-like or iterable object to convert to an Observable sequence.
+		* @param mapFn Map function to call on every element of the array.
+		* @param [thisArg] The context to use calling the mapFn if provided.
+		* @param [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
+		*/
+		from<T, TResult>(array: T[], mapFn: (value: T, index: number) => TResult, thisArg?: any, scheduler?: IScheduler): Observable<TResult>;
+		/**
+		* This method creates a new Observable sequence from an array object.
+		* @param array An array-like or iterable object to convert to an Observable sequence.
+		* @param [mapFn] Map function to call on every element of the array.
+		* @param [thisArg] The context to use calling the mapFn if provided.
+		* @param [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
+		*/
+		from<T>(array: T[], mapFn?: (value: T, index: number) => T, thisArg?: any, scheduler?: IScheduler): Observable<T>;
+
+		/**
+		* This method creates a new Observable sequence from an array-like object.
+		* @param array An array-like or iterable object to convert to an Observable sequence.
+		* @param mapFn Map function to call on every element of the array.
+		* @param [thisArg] The context to use calling the mapFn if provided.
+		* @param [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
+		*/
+		from<T, TResult>(array: { length: number;[index: number]: T; }, mapFn: (value: T, index: number) => TResult, thisArg?: any, scheduler?: IScheduler): Observable<TResult>;
+		/**
+		* This method creates a new Observable sequence from an array-like object.
+		* @param array An array-like or iterable object to convert to an Observable sequence.
+		* @param [mapFn] Map function to call on every element of the array.
+		* @param [thisArg] The context to use calling the mapFn if provided.
+		* @param [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
+		*/
+		from<T>(array: { length: number;[index: number]: T; }, mapFn?: (value: T, index: number) => T, thisArg?: any, scheduler?: IScheduler): Observable<T>;
+
+		/**
+		* This method creates a new Observable sequence from an array-like or iterable object.
+		* @param array An array-like or iterable object to convert to an Observable sequence.
+		* @param [mapFn] Map function to call on every element of the array.
+		* @param [thisArg] The context to use calling the mapFn if provided.
+		* @param [scheduler] Optional scheduler to use for scheduling.  If not provided, defaults to Scheduler.currentThread.
+		*/
+		from<T>(iterable: any, mapFn?: (value: any, index: number) => T, thisArg?: any, scheduler?: IScheduler): Observable<T>;
+
+		fromArray<T>(array: T[], scheduler?: IScheduler): Observable<T>;
+		fromArray<T>(array: { length: number;[index: number]: T; }, scheduler?: IScheduler): Observable<T>;
+
+		/**
+		*  Converts an iterable into an Observable sequence
+		*  
+		* @example
+		*  var res = Rx.Observable.fromIterable(new Map());
+		*  var res = Rx.Observable.fromIterable(function* () { yield 42; });
+		*  var res = Rx.Observable.fromIterable(new Set(), Rx.Scheduler.timeout);
+		* @param generator Generator to convert from.
+		* @param [scheduler] Scheduler to run the enumeration of the input sequence on.
+		* @returns The observable sequence whose elements are pulled from the given generator sequence.
+		*/
+		fromIterable<T>(generator: () => { next(): { done: boolean; value?: T; }; }, scheduler?: IScheduler): Observable<T>;
+
+		/**
+		*  Converts an iterable into an Observable sequence
+		*  
+		* @example
+		*  var res = Rx.Observable.fromIterable(new Map());
+		*  var res = Rx.Observable.fromIterable(new Set(), Rx.Scheduler.timeout);
+		* @param iterable Iterable to convert from.
+		* @param [scheduler] Scheduler to run the enumeration of the input sequence on.
+		* @returns The observable sequence whose elements are pulled from the given generator sequence.
+		*/
+		fromIterable<T>(iterable: {}, scheduler?: IScheduler): Observable<T>;	// todo: can't describe ES6 Iterable via TypeScript type system
+		generate<TState, TResult>(initialState: TState, condition: (state: TState) => boolean, iterate: (state: TState) => TState, resultSelector: (state: TState) => TResult, scheduler?: IScheduler): Observable<TResult>;
+		never<T>(): Observable<T>;
+
+		/**
+		*  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments.
+		* 
+		* @example
+		*  var res = Rx.Observable.of(1, 2, 3);
+		* @since 2.2.28
+		* @returns The observable sequence whose elements are pulled from the given arguments.
+		*/
+		of<T>(...values: T[]): Observable<T>;
+
+		/**
+		*  This method creates a new Observable instance with a variable number of arguments, regardless of number or type of the arguments. 
+		* @example
+		*  var res = Rx.Observable.ofWithScheduler(Rx.Scheduler.timeout, 1, 2, 3);
+		* @since 2.2.28
+		* @param [scheduler] A scheduler to use for scheduling the arguments.
+		* @returns The observable sequence whose elements are pulled from the given arguments.
+		*/
+		ofWithScheduler<T>(scheduler?: IScheduler, ...values: T[]): Observable<T>;
+		range(start: number, count: number, scheduler?: IScheduler): Observable<number>;
+		repeat<T>(value: T, repeatCount?: number, scheduler?: IScheduler): Observable<T>;
+		return<T>(value: T, scheduler?: IScheduler): Observable<T>;
+		/**
+		 * @since 2.2.28
+		 */
+		just<T>(value: T, scheduler?: IScheduler): Observable<T>;	// alias for return
+		returnValue<T>(value: T, scheduler?: IScheduler): Observable<T>;	// alias for return
+		throw<T>(exception: Error, scheduler?: IScheduler): Observable<T>;
+		throw<T>(exception: any, scheduler?: IScheduler): Observable<T>;
+		throwException<T>(exception: Error, scheduler?: IScheduler): Observable<T>;	// alias for throw
+		throwException<T>(exception: any, scheduler?: IScheduler): Observable<T>;	// alias for throw
+		throwError<T>(error: Error, scheduler?: IScheduler): Observable<T>;	// alias for throw
+		throwError<T>(error: any, scheduler?: IScheduler): Observable<T>;	// alias for throw
+
+		catch<T>(sources: Observable<T>[]): Observable<T>;
+		catch<T>(sources: IPromise<T>[]): Observable<T>;
+		catchException<T>(sources: Observable<T>[]): Observable<T>;	// alias for catch
+		catchException<T>(sources: IPromise<T>[]): Observable<T>;	// alias for catch
+		catchError<T>(sources: Observable<T>[]): Observable<T>;	// alias for catch
+		catchError<T>(sources: IPromise<T>[]): Observable<T>;	// alias for catch
+		catch<T>(...sources: Observable<T>[]): Observable<T>;
+		catch<T>(...sources: IPromise<T>[]): Observable<T>;
+		catchException<T>(...sources: Observable<T>[]): Observable<T>;	// alias for catch
+		catchException<T>(...sources: IPromise<T>[]): Observable<T>;	// alias for catch
+		catchError<T>(...sources: Observable<T>[]): Observable<T>;	// alias for catch
+		catchError<T>(...sources: IPromise<T>[]): Observable<T>;	// alias for catch
+
+		combineLatest<T, T2, TResult>(first: Observable<T>, second: Observable<T2>, resultSelector: (v1: T, v2: T2) => TResult): Observable<TResult>;
+		combineLatest<T, T2, TResult>(first: IPromise<T>, second: Observable<T2>, resultSelector: (v1: T, v2: T2) => TResult): Observable<TResult>;
+		combineLatest<T, T2, TResult>(first: Observable<T>, second: IPromise<T2>, resultSelector: (v1: T, v2: T2) => TResult): Observable<TResult>;
+		combineLatest<T, T2, TResult>(first: IPromise<T>, second: IPromise<T2>, resultSelector: (v1: T, v2: T2) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, TResult>(first: Observable<T>, second: Observable<T2>, third: Observable<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, TResult>(first: Observable<T>, second: Observable<T2>, third: IPromise<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, TResult>(first: Observable<T>, second: IPromise<T2>, third: Observable<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, TResult>(first: Observable<T>, second: IPromise<T2>, third: IPromise<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, TResult>(first: IPromise<T>, second: Observable<T2>, third: Observable<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, TResult>(first: IPromise<T>, second: Observable<T2>, third: IPromise<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, TResult>(first: IPromise<T>, second: IPromise<T2>, third: Observable<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, TResult>(first: IPromise<T>, second: IPromise<T2>, third: IPromise<T3>, resultSelector: (v1: T, v2: T2, v3: T3) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: Observable<T>, second: Observable<T2>, third: Observable<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: Observable<T>, second: Observable<T2>, third: Observable<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: Observable<T>, second: Observable<T2>, third: IPromise<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: Observable<T>, second: Observable<T2>, third: IPromise<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: Observable<T>, second: IPromise<T2>, third: Observable<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: Observable<T>, second: IPromise<T2>, third: Observable<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: Observable<T>, second: IPromise<T2>, third: IPromise<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: Observable<T>, second: IPromise<T2>, third: IPromise<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: IPromise<T>, second: Observable<T2>, third: Observable<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: IPromise<T>, second: Observable<T2>, third: Observable<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: IPromise<T>, second: Observable<T2>, third: IPromise<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: IPromise<T>, second: Observable<T2>, third: IPromise<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: IPromise<T>, second: IPromise<T2>, third: Observable<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: IPromise<T>, second: IPromise<T2>, third: Observable<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: IPromise<T>, second: IPromise<T2>, third: IPromise<T3>, fourth: Observable<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, TResult>(first: IPromise<T>, second: IPromise<T2>, third: IPromise<T3>, fourth: IPromise<T4>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4) => TResult): Observable<TResult>;
+		combineLatest<T, T2, T3, T4, T5, TResult>(first: Observable<T>, second: Observable<T2>, third: Observable<T3>, fourth: Observable<T4>, fifth: Observable<T5>, resultSelector: (v1: T, v2: T2, v3: T3, v4: T4, v5: T5) => TResult): Observable<TResult>;
+		combineLatest<TOther, TResult>(souces: Observable<TOther>[], resultSelector: (...otherValues: TOther[]) => TResult): Observable<TResult>;
+		combineLatest<TOther, TResult>(souces: IPromise<TOther>[], resultSelector: (...otherValues: TOther[]) => TResult): Observable<TResult>;
+
+		concat<T>(...sources: Observable<T>[]): Observable<T>;
+		concat<T>(...sources: IPromise<T>[]): Observable<T>;
+		concat<T>(sources: Observable<T>[]): Observable<T>;
+		concat<T>(sources: IPromise<T>[]): Observable<T>;
+		merge<T>(...sources: Observable<T>[]): Observable<T>;
+		merge<T>(...sources: IPromise<T>[]): Observable<T>;
+		merge<T>(sources: Observable<T>[]): Observable<T>;
+		merge<T>(sources: IPromise<T>[]): Observable<T>;
+		merge<T>(scheduler: IScheduler, ...sources: Observable<T>[]): Observable<T>;
+		merge<T>(scheduler: IScheduler, ...sources: IPromise<T>[]): Observable<T>;
+		merge<T>(scheduler: IScheduler, sources: Observable<T>[]): Observable<T>;
+		merge<T>(scheduler: IScheduler, sources: IPromise<T>[]): Observable<T>;
+
+		pairs<T>(obj: { [key: string]: T }, scheduler?: IScheduler): Observable<[string, T]>;
+
+		zip<T1, T2, TResult>(first: Observable<T1>, sources: Observable<T2>[], resultSelector: (item1: T1, ...right: T2[]) => TResult): Observable<TResult>;
+		zip<T1, T2, TResult>(first: Observable<T1>, sources: IPromise<T2>[], resultSelector: (item1: T1, ...right: T2[]) => TResult): Observable<TResult>;
+		zip<T1, T2, TResult>(source1: Observable<T1>, source2: Observable<T2>, resultSelector: (item1: T1, item2: T2) => TResult): Observable<TResult>;
+		zip<T1, T2, TResult>(source1: Observable<T1>, source2: IPromise<T2>, resultSelector: (item1: T1, item2: T2) => TResult): Observable<TResult>;
+		zip<T1, T2, T3, TResult>(source1: Observable<T1>, source2: Observable<T2>, source3: Observable<T3>, resultSelector: (item1: T1, item2: T2, item3: T3) => TResult): Observable<TResult>;
+		zip<T1, T2, T3, TResult>(source1: Observable<T1>, source2: Observable<T2>, source3: IPromise<T3>, resultSelector: (item1: T1, item2: T2, item3: T3) => TResult): Observable<TResult>;
+		zip<T1, T2, T3, TResult>(source1: Observable<T1>, source2: IPromise<T2>, source3: Observable<T3>, resultSelector: (item1: T1, item2: T2, item3: T3) => TResult): Observable<TResult>;
+		zip<T1, T2, T3, TResult>(source1: Observable<T1>, source2: IPromise<T2>, source3: IPromise<T3>, resultSelector: (item1: T1, item2: T2, item3: T3) => TResult): Observable<TResult>;
+		zip<T1, T2, T3, T4, TResult>(source1: Observable<T1>, source2: Observable<T2>, source3: Observable<T3>, source4: Observable<T4>, resultSelector: (item1: T1, item2: T2, item3: T3, item4: T4) => TResult): Observable<TResult>;
+		zip<T1, T2, T3, T4, TResult>(source1: Observable<T1>, source2: Observable<T2>, source3: Observable<T3>, source4: IPromise<T4>, resultSelector: (item1: T1, item2: T2, item3: T3, item4: T4) => TResult): Observable<TResult>;
+		zip<T1, T2, T3, T4, TResult>(source1: Observable<T1>, source2: Observable<T2>, source3: IPromise<T3>, source4: Observable<T4>, resultSelector: (item1: T1, item2: T2, item3: T3, item4: T4) => TResult): Observable<TResult>;
+		zip<T1, T2, T3, T4, TResult>(source1: Observable<T1>, source2: Observable<T2>, source3: IPromise<T3>, source4: IPromise<T4>, resultSelector: (item1: T1, item2: T2, item3: T3, item4: T4) => TResult): Observable<TResult>;
+		zip<T1, T2, T3, T4, TResult>(source1: Observable<T1>, source2: IPromise<T2>, source3: Observable<T3>, source4: Observable<T4>, resultSelector: (item1: T1, item2: T2, item3: T3, item4: T4) => TResult): Observable<TResult>;
+		zip<T1, T2, T3, T4, TResult>(source1: Observable<T1>, source2: IPromise<T2>, source3: Observable<T3>, source4: IPromise<T4>, resultSelector: (item1: T1, item2: T2, item3: T3, item4: T4) => TResult): Observable<TResult>;
+		zip<T1, T2, T3, T4, TResult>(source1: Observable<T1>, source2: IPromise<T2>, source3: IPromise<T3>, source4: Observable<T4>, resultSelector: (item1: T1, item2: T2, item3: T3, item4: T4) => TResult): Observable<TResult>;
+		zip<T1, T2, T3, T4, TResult>(source1: Observable<T1>, source2: IPromise<T2>, source3: IPromise<T3>, source4: IPromise<T4>, resultSelector: (item1: T1, item2: T2, item3: T3, item4: T4) => TResult): Observable<TResult>;
+		zip<T1, T2, T3, T4, T5, TResult>(source1: Observable<T1>, source2: Observable<T2>, source3: Observable<T3>, source4: Observable<T4>, source5: Observable<T5>, resultSelector: (item1: T1, item2: T2, item3: T3, item4: T4, item5: T5) => TResult): Observable<TResult>;
+		zipArray<T>(...sources: Observable<T>[]): Observable<T[]>;
+		zipArray<T>(sources: Observable<T>[]): Observable<T[]>;
+
+		/**
+		* Converts a Promise to an Observable sequence
+		* @param promise An ES6 Compliant promise.
+		* @returns An Observable sequence which wraps the existing promise success and failure.
+		*/
+		fromPromise<T>(promise: IPromise<T>): Observable<T>;
+	}
+
+	export var Observable: ObservableStatic;
+
+	interface ISubject<T> extends Observable<T>, Observer<T>, IDisposable {
+		hasObservers(): boolean;
+	}
+
+	export interface Subject<T> extends ISubject<T> {
+	}
+
+	interface SubjectStatic {
+		new <T>(): Subject<T>;
+		create<T>(observer?: Observer<T>, observable?: Observable<T>): ISubject<T>;
+	}
+
+	export var Subject: SubjectStatic;
+
+	export interface AsyncSubject<T> extends Subject<T> {
+	}
+
+	interface AsyncSubjectStatic {
+		new <T>(): AsyncSubject<T>;
+	}
+
+	export var AsyncSubject: AsyncSubjectStatic;
+}
diff --git a/typings/rx/rx.d.ts b/typings/rx/rx.d.ts
new file mode 100644
index 0000000..f1dc527
--- /dev/null
+++ b/typings/rx/rx.d.ts
@@ -0,0 +1,67 @@
+﻿// Type definitions for RxJS v2.2.28
+// Project: http://rx.codeplex.com/
+// Definitions by: gsino <http://www.codeplex.com/site/users/view/gsino>, Igor Oleinikov <https://github.com/Igorbek>
+// Definitions: https://github.com/borisyankov/DefinitelyTyped
+
+///<reference path="rx-lite.d.ts"/>
+
+declare module Rx {
+    export interface IScheduler {
+		catch(handler: (exception: any) => boolean): IScheduler;
+		catchException(handler: (exception: any) => boolean): IScheduler;
+	}
+
+    // Observer
+	export interface Observer<T> {
+		checked(): Observer<any>;
+	}
+
+	interface ObserverStatic {
+		/**
+		* Schedules the invocation of observer methods on the given scheduler.
+		* @param scheduler Scheduler to schedule observer messages on.
+		* @returns Observer whose messages are scheduled on the given scheduler.
+		*/
+		notifyOn<T>(scheduler: IScheduler): Observer<T>;
+	}
+
+	export interface Observable<T> {
+		observeOn(scheduler: IScheduler): Observable<T>;
+		subscribeOn(scheduler: IScheduler): Observable<T>;
+
+		amb(rightSource: Observable<T>): Observable<T>;
+		amb(rightSource: IPromise<T>): Observable<T>;
+		onErrorResumeNext(second: Observable<T>): Observable<T>;
+		onErrorResumeNext(second: IPromise<T>): Observable<T>;
+		bufferWithCount(count: number, skip?: number): Observable<T[]>;
+		windowWithCount(count: number, skip?: number): Observable<Observable<T>>;
+		defaultIfEmpty(defaultValue?: T): Observable<T>;
+		distinct(skipParameter: boolean, valueSerializer: (value: T) => string): Observable<T>;
+		distinct<TKey>(keySelector?: (value: T) => TKey, keySerializer?: (key: TKey) => string): Observable<T>;
+		groupBy<TKey, TElement>(keySelector: (value: T) => TKey, skipElementSelector?: boolean, keySerializer?: (key: TKey) => string): Observable<GroupedObservable<TKey, T>>;
+		groupBy<TKey, TElement>(keySelector: (value: T) => TKey, elementSelector: (value: T) => TElement, keySerializer?: (key: TKey) => string): Observable<GroupedObservable<TKey, T>>;
+		groupByUntil<TKey, TDuration>(keySelector: (value: T) => TKey, skipElementSelector: boolean, durationSelector: (group: GroupedObservable<TKey, T>) => Observable<TDuration>, keySerializer?: (key: TKey) => string): Observable<GroupedObservable<TKey, T>>;
+		groupByUntil<TKey, TElement, TDuration>(keySelector: (value: T) => TKey, elementSelector: (value: T) => TElement, durationSelector: (group: GroupedObservable<TKey, TElement>) => Observable<TDuration>, keySerializer?: (key: TKey) => string): Observable<GroupedObservable<TKey, TElement>>;
+	}
+
+	interface ObservableStatic {
+		using<TSource, TResource extends IDisposable>(resourceFactory: () => TResource, observableFactory: (resource: TResource) => Observable<TSource>): Observable<TSource>;
+		amb<T>(...sources: Observable<T>[]): Observable<T>;
+		amb<T>(...sources: IPromise<T>[]): Observable<T>;
+		amb<T>(sources: Observable<T>[]): Observable<T>;
+		amb<T>(sources: IPromise<T>[]): Observable<T>;
+		onErrorResumeNext<T>(...sources: Observable<T>[]): Observable<T>;
+		onErrorResumeNext<T>(...sources: IPromise<T>[]): Observable<T>;
+		onErrorResumeNext<T>(sources: Observable<T>[]): Observable<T>;
+		onErrorResumeNext<T>(sources: IPromise<T>[]): Observable<T>;
+	}
+
+	interface GroupedObservable<TKey, TElement> extends Observable<TElement> {
+		key: TKey;
+		underlyingObservable: Observable<TElement>;
+	}
+}
+
+declare module "rx" {
+    export = Rx
+}
-- 
2.3.5


From 9b2539d02842290930ebc80ab24b153727cd85c0 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 13:27:31 +0900
Subject: [PATCH 62/95] Step 7.8: give Parties a type of Mongo.Collection

---
 typings/socially/socially.d.ts | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/typings/socially/socially.d.ts b/typings/socially/socially.d.ts
index a01ea81..b85433f 100644
--- a/typings/socially/socially.d.ts
+++ b/typings/socially/socially.d.ts
@@ -1,4 +1,4 @@
-declare var Parties;
+declare var Parties:Mongo.Collection;
 
 interface IParty {
   _id?: string;
-- 
2.3.5


From 9eb96417e952492fe817ef8de9e776c87eafabfb Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 13:28:11 +0900
Subject: [PATCH 63/95] Step 7.9: Provide Parties a generic type of IParty

---
 typings/socially/socially.d.ts | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/typings/socially/socially.d.ts b/typings/socially/socially.d.ts
index b85433f..34bb272 100644
--- a/typings/socially/socially.d.ts
+++ b/typings/socially/socially.d.ts
@@ -1,4 +1,4 @@
-declare var Parties:Mongo.Collection;
+declare var Parties:Mongo.Collection<IParty>;
 
 interface IParty {
   _id?: string;
-- 
2.3.5


From e519f8632ad12f3b0aa9421c40df1025d3f9a303 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 13:33:18 +0900
Subject: [PATCH 64/95] Step 7.10: implement typescript features. multiple
 files.

---
 .meteor/packages                    | 6 +++++-
 client/parties-form/parties-form.ts | 3 ++-
 client/parties-list/parties-list.ts | 2 +-
 typings/socially/socially.d.ts      | 2 ++
 4 files changed, 10 insertions(+), 3 deletions(-)

diff --git a/.meteor/packages b/.meteor/packages
index 3babd15..db55abd 100644
--- a/.meteor/packages
+++ b/.meteor/packages
@@ -6,7 +6,11 @@
 
 meteor-platform
 autopublish
-insecure
+
 shmck:angular2
 netanelgilad:angular2-typescript
 shmck:angular2-router
+
+# Accounts
+accounts-password
+accounts-ui
diff --git a/client/parties-form/parties-form.ts b/client/parties-form/parties-form.ts
index ca69373..4612ef2 100644
--- a/client/parties-form/parties-form.ts
+++ b/client/parties-form/parties-form.ts
@@ -9,13 +9,14 @@ import {FORM_DIRECTIVES, Control, ControlGroup, Validators} from 'angular2/angul
   directives: [FORM_DIRECTIVES]
 })
 export class PartiesForm {
+  partiesForm: ControlGroup;
   constructor() {
     this.partiesForm = new ControlGroup({
       name: new Control('', Validators.required),
       description: new Control('', Validators.required)
     });
   }
-  add(party) {
+  add(party:IParty) {
     // validate if the form is valid
     if (this.partiesForm.valid) {
 
diff --git a/client/parties-list/parties-list.ts b/client/parties-list/parties-list.ts
index c80ee8c..b69936b 100644
--- a/client/parties-list/parties-list.ts
+++ b/client/parties-list/parties-list.ts
@@ -16,7 +16,7 @@ export class PartiesList {
       this.parties = Parties.find().fetch();
     }));
   }
-  remove(party) {
+  remove(party:IParty) {
     Parties.remove(party._id);
   }
 }
\ No newline at end of file
diff --git a/typings/socially/socially.d.ts b/typings/socially/socially.d.ts
index 34bb272..6f0d6d3 100644
--- a/typings/socially/socially.d.ts
+++ b/typings/socially/socially.d.ts
@@ -1,4 +1,6 @@
 declare var Parties:Mongo.Collection<IParty>;
+declare var _;
+declare var zone;
 
 interface IParty {
   _id?: string;
-- 
2.3.5


From 15bb1533bd4b3b68ca7f056171fd0d3822710956 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 13:36:43 +0900
Subject: [PATCH 65/95] Step 8.2: Add loginButtons template to index.html

---
 client/index.html | 1 +
 1 file changed, 1 insertion(+)

diff --git a/client/index.html b/client/index.html
index 9956097..5f1d6b8 100644
--- a/client/index.html
+++ b/client/index.html
@@ -2,6 +2,7 @@
   <base href="/">
 </head>
 <body>
+  {{> loginButtons}}
   <app></app>
   <script>System.import("client/app");</script>
 </body>
\ No newline at end of file
-- 
2.3.5


From c088fc0e2d84a944eaa941396d435286989956e5 Mon Sep 17 00:00:00 2001
From: ShMcK <me@shmck.com>
Date: Thu, 27 Aug 2015 13:39:21 +0900
Subject: [PATCH 66/95] Step 8.3: Create security rules for insert, update &
 removing Parties

---
 model/parties.ts | 17 ++++++++++++++++-
 1 file changed, 16 insertions(+), 1 deletion(-)

diff --git a/model/parties.ts b/model/parties.ts
index f9329b3..80c4772 100644
--- a/model/parties.ts
+++ b/model/parties.ts
@@ -1 +1,16 @@
-Parties = new Mongo.Collection('parties');
\ No newline at end of file
+Parties = new Mongo.Collection('parties');
+
+Parties.allow({
+  insert: function (party:IParty) {
+    var userId = Meteor.userId();
+    return userId && party.owner === userId;
+  },
+  update: function (party:IParty, fields, modifier) {
+    var userId = Meteor.userId();
+    return userId && party.owner === userId;
+  },
+  remove: function (party:IParty) {
+    var userId = Meteor.userId();
+    return userId && party.owner === userId;
+  }
+});
\ No newline at end of file
-- 
2.3.5


From 8bad32e81c9c6939d6d4aec7d9b7975c99184649 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Fri, 4 Sep 2015 18:15:34 +0900
Subject: [PATCH 67/95] Step 8.4: Add owner to IParty interface

---
 typings/socially/socially.d.ts | 1 +
 1 file changed, 1 insertion(+)

diff --git a/typings/socially/socially.d.ts b/typings/socially/socially.d.ts
index 6f0d6d3..cfadbb5 100644
--- a/typings/socially/socially.d.ts
+++ b/typings/socially/socially.d.ts
@@ -6,4 +6,5 @@ interface IParty {
   _id?: string;
   name: string;
   description: string;
+  owner: string;
 }
\ No newline at end of file
-- 
2.3.5


From d4ad89e72804c675ecb47a5c4173057407d7d424 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Fri, 4 Sep 2015 18:16:45 +0900
Subject: [PATCH 68/95] Step 8.5: add owner to PartiesForm add method

---
 client/parties-form/parties-form.ts | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/client/parties-form/parties-form.ts b/client/parties-form/parties-form.ts
index 4612ef2..698630f 100644
--- a/client/parties-form/parties-form.ts
+++ b/client/parties-form/parties-form.ts
@@ -23,7 +23,8 @@ export class PartiesForm {
       // insert parties (insecure way)
       Parties.insert({
         name: party.name,
-        description: party.description
+        description: party.description,
+        owner: Meteor.userId()
       });
 
       //reset input values to empty strings
-- 
2.3.5


From 4f2fa4e1a113882dff09c0e1352bb3aa43409d30 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Fri, 4 Sep 2015 18:18:01 +0900
Subject: [PATCH 69/95] Step 8.6: Add owner to PartyDetails save method

---
 client/party-details/party-details.ts | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index e641735..90b93ba 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -24,7 +24,8 @@ export class PartyDetails {
       _.isString(party.description) && party.description.length) {
       Parties.update(party._id, {
         name: party.name,
-        description: party.description
+        description: party.description,
+        owner: Meteor.userId()
       });
       this.resetToParty = _.clone(party);
     }
-- 
2.3.5


From f91cb3d30108629b8cc58449b5bcc4a1c9bb237f Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Fri, 4 Sep 2015 18:22:04 +0900
Subject: [PATCH 70/95] Step 8.7: PartyService init

---
 client/lib/party-service.ts | 5 +++++
 1 file changed, 5 insertions(+)
 create mode 100644 client/lib/party-service.ts

diff --git a/client/lib/party-service.ts b/client/lib/party-service.ts
new file mode 100644
index 0000000..3a9b75f
--- /dev/null
+++ b/client/lib/party-service.ts
@@ -0,0 +1,5 @@
+export class PartyService {
+  add(party) { }
+  update (party) { }
+  remove(partyId) { }
+}
\ No newline at end of file
-- 
2.3.5


From 16258bda630881edc079960bd55b47f220345c6c Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Fri, 4 Sep 2015 18:22:39 +0900
Subject: [PATCH 71/95] Step 8.8: Add types to PartyService

---
 client/lib/party-service.ts | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/client/lib/party-service.ts b/client/lib/party-service.ts
index 3a9b75f..6743c35 100644
--- a/client/lib/party-service.ts
+++ b/client/lib/party-service.ts
@@ -1,5 +1,5 @@
 export class PartyService {
-  add(party) { }
-  update (party) { }
-  remove(partyId) { }
+  add(party:IParty) { }
+  update (party:IParty) { }
+  remove(partyId:string) { }
 }
\ No newline at end of file
-- 
2.3.5


From 7a729d2feb54aefee48e2645c2fcc8582e12dfd9 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Fri, 4 Sep 2015 18:24:10 +0900
Subject: [PATCH 72/95] Step 8.9: create getPartyObject in PartyService

---
 client/lib/party-service.ts | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/client/lib/party-service.ts b/client/lib/party-service.ts
index 6743c35..8852856 100644
--- a/client/lib/party-service.ts
+++ b/client/lib/party-service.ts
@@ -2,4 +2,11 @@ export class PartyService {
   add(party:IParty) { }
   update (party:IParty) { }
   remove(partyId:string) { }
+  getPartyObject(party:IParty) {
+    return {
+      name: party.name,
+      description: party.description,
+      user: Meteor.userId()
+    };
+  }
 }
\ No newline at end of file
-- 
2.3.5


From a532820803c1f0e2949760f886714743189e1a3d Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Fri, 4 Sep 2015 18:25:09 +0900
Subject: [PATCH 73/95] Step 8.10: create add, update, & remove methods on
 PartyService

---
 client/lib/party-service.ts | 12 +++++++++---
 1 file changed, 9 insertions(+), 3 deletions(-)

diff --git a/client/lib/party-service.ts b/client/lib/party-service.ts
index 8852856..40535a3 100644
--- a/client/lib/party-service.ts
+++ b/client/lib/party-service.ts
@@ -1,7 +1,13 @@
 export class PartyService {
-  add(party:IParty) { }
-  update (party:IParty) { }
-  remove(partyId:string) { }
+  add(party:IParty) {
+    Parties.insert(this.getPartyObject(party));
+  }
+  update (party:IParty) {
+    Parties.update(party._id, this.getPartyObject(party));
+  }
+  remove(partyId:string) {
+    Parties.remove(partyId);
+  }
   getPartyObject(party:IParty) {
     return {
       name: party.name,
-- 
2.3.5


From 4579acb097fbbb69c8d2021e76f951f65a982fc8 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Tue, 8 Sep 2015 15:48:47 +0900
Subject: [PATCH 74/95] Step 8.11: modify PartiesList to use
 PartyService.remove

---
 client/parties-list/parties-list.ts | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/client/parties-list/parties-list.ts b/client/parties-list/parties-list.ts
index b69936b..8c93a3e 100644
--- a/client/parties-list/parties-list.ts
+++ b/client/parties-list/parties-list.ts
@@ -1,9 +1,11 @@
-import {Component, View, NgFor, bootstrap} from 'angular2/angular2';
+import {Component, View, NgFor, Inject, bootstrap} from 'angular2/angular2';
 import {RouterLink} from 'angular2/router';
 import {PartiesForm} from 'client/parties-form/parties-form';
+import {PartyService} from 'client/lib/party-service';
 
 @Component({
-  selector: 'parties-list'
+  selector: 'parties-list',
+  viewBindings: [PartyService]
 })
 @View({
   templateUrl: 'client/parties-list/parties-list.ng.html',
@@ -11,12 +13,14 @@ import {PartiesForm} from 'client/parties-form/parties-form';
 })
 export class PartiesList {
   parties: IParty[];
-  constructor () {
+  partyService:PartyService;
+  constructor (@Inject(PartyService) partyService:PartyService) {
+    this.partyService = partyService;
     Tracker.autorun(zone.bind(() => {
       this.parties = Parties.find().fetch();
     }));
   }
   remove(party:IParty) {
-    Parties.remove(party._id);
+    this.partyService.remove(party._id);
   }
 }
\ No newline at end of file
-- 
2.3.5


From b60da24690362f0edc48d700ab3acc21d4b742db Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Tue, 8 Sep 2015 15:52:41 +0900
Subject: [PATCH 75/95] Step 8.12: mody PartyDetails to use PartyService.update

---
 client/party-details/party-details.ts | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index 90b93ba..77fd85d 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -1,9 +1,11 @@
 import {Component, View, Inject} from 'angular2/angular2';
 import {RouteParams, RouterLink} from 'angular2/router';
 import {FORM_DIRECTIVES} from 'angular2/angular2';
+import {PartyService} from 'client/lib/party-service';
 
 @Component({
-  selector: 'party-details'
+  selector: 'party-details',
+  viewBindings: [PartyService]
 })
 @View({
   templateUrl: 'client/party-details/party-details.ng.html',
@@ -13,7 +15,10 @@ export class PartyDetails {
   partyId: string;
   party: IParty;
   resetToParty: IParty;
-  constructor(@Inject(RouteParams) routeParams:RouteParams) {
+  partyService:PartyService;
+  constructor(@Inject(RouteParams) routeParams:RouteParams,
+  @Inject(PartyService) partyService:PartyService) {
+    this.partyService = partyService;
     this.partyId = routeParams.params.partyId;
   }
   save(event) {
@@ -22,11 +27,7 @@ export class PartyDetails {
 
     if (_.isString(party.name) && party.name.length &&
       _.isString(party.description) && party.description.length) {
-      Parties.update(party._id, {
-        name: party.name,
-        description: party.description,
-        owner: Meteor.userId()
-      });
+      this.partyService.update(party);
       this.resetToParty = _.clone(party);
     }
   }
-- 
2.3.5


From a40f2cbfb42aa3e332506a7e6fd2da944f86e586 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Tue, 8 Sep 2015 15:58:43 +0900
Subject: [PATCH 76/95] Step 8.13: modify PartiesForm to use PartyService.add

---
 client/parties-form/parties-form.ts | 13 ++++++-------
 1 file changed, 6 insertions(+), 7 deletions(-)

diff --git a/client/parties-form/parties-form.ts b/client/parties-form/parties-form.ts
index 698630f..1fa8f5a 100644
--- a/client/parties-form/parties-form.ts
+++ b/client/parties-form/parties-form.ts
@@ -1,5 +1,6 @@
-import {Component, View} from 'angular2/angular2';
+import {Component, View, Inject} from 'angular2/angular2';
 import {FORM_DIRECTIVES, Control, ControlGroup, Validators} from 'angular2/angular2';
+import {PartyService} from 'client/lib/party-service';
 
 @Component({
   selector: 'parties-form'
@@ -10,7 +11,9 @@ import {FORM_DIRECTIVES, Control, ControlGroup, Validators} from 'angular2/angul
 })
 export class PartiesForm {
   partiesForm: ControlGroup;
-  constructor() {
+  partyService: PartyService;
+  constructor(@Inject(PartyService) partyService:PartyService) {
+    this.partyService = partyService;
     this.partiesForm = new ControlGroup({
       name: new Control('', Validators.required),
       description: new Control('', Validators.required)
@@ -21,11 +24,7 @@ export class PartiesForm {
     if (this.partiesForm.valid) {
 
       // insert parties (insecure way)
-      Parties.insert({
-        name: party.name,
-        description: party.description,
-        owner: Meteor.userId()
-      });
+     this.partyService.add(party);
 
       //reset input values to empty strings
       this.partiesForm.controls.name.updateValue('');
-- 
2.3.5


From a3b756205408add90c837f75bab346d6500d9c8b Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Tue, 8 Sep 2015 16:00:13 +0900
Subject: [PATCH 77/95] Step 8.14: add accounts-facebook, accounts-twitter
 packages

---
 .meteor/packages | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/.meteor/packages b/.meteor/packages
index db55abd..41f772f 100644
--- a/.meteor/packages
+++ b/.meteor/packages
@@ -14,3 +14,5 @@ shmck:angular2-router
 # Accounts
 accounts-password
 accounts-ui
+accounts-facebook
+accounts-twitter
-- 
2.3.5


From e2b7f0766fd5eaa320343bb68e547ba25f40e2d9 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Tue, 8 Sep 2015 16:01:03 +0900
Subject: [PATCH 78/95] update package versions

---
 .meteor/versions | 20 +++++++++++++++++++-
 1 file changed, 19 insertions(+), 1 deletion(-)

diff --git a/.meteor/versions b/.meteor/versions
index 9f1d2ad..f856bcb 100644
--- a/.meteor/versions
+++ b/.meteor/versions
@@ -1,3 +1,10 @@
+accounts-base@1.2.0
+accounts-facebook@1.0.4
+accounts-oauth@1.1.5
+accounts-password@1.1.1
+accounts-twitter@1.0.4
+accounts-ui@1.1.5
+accounts-ui-unstyled@1.1.7
 autopublish@1.0.3
 autoupdate@1.2.1
 base64@1.0.3
@@ -10,17 +17,20 @@ check@1.0.5
 ddp@1.1.0
 deps@1.0.7
 ejson@1.0.6
+email@1.0.6
+facebook@1.2.1
 fastclick@1.0.3
 geojson-utils@1.0.3
 html-tools@1.0.4
 htmljs@1.0.4
 http@1.1.0
 id-map@1.0.3
-insecure@1.0.3
 jquery@1.11.3_2
 json@1.0.3
 launch-screen@1.0.2
+less@1.0.14
 livedata@1.0.13
+localstorage@1.0.3
 logging@1.0.7
 meteor@1.1.6
 meteor-platform@1.2.2
@@ -29,6 +39,10 @@ minimongo@1.0.8
 mobile-status-bar@1.0.3
 mongo@1.1.0
 netanelgilad:angular2-typescript@0.0.3
+npm-bcrypt@0.7.8_2
+oauth@1.1.4
+oauth1@1.1.4
+oauth2@1.1.3
 observe-sequence@1.0.6
 ordered-dict@1.0.3
 random@1.0.3
@@ -37,13 +51,17 @@ reactive-var@1.0.5
 reload@1.1.3
 retry@1.0.3
 routepolicy@1.0.5
+service-configuration@1.0.4
 session@1.1.0
+sha@1.0.3
 shmck:angular2@2.0.6
 shmck:angular2-router@2.0.5
 spacebars@1.0.6
 spacebars-compiler@1.0.6
+srp@1.0.3
 templating@1.1.1
 tracker@1.0.7
+twitter@1.1.4
 ui@1.0.6
 underscore@1.0.3
 url@1.0.4
-- 
2.3.5


From 38be0a48a1d9081eed41d32329ee9a6426508726 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Tue, 8 Sep 2015 16:02:09 +0900
Subject: [PATCH 79/95] Step 8.15: Add canActivate to PartyDetails to verify
 user is logged in

---
 client/party-details/party-details.ts | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index 77fd85d..788119f 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -35,6 +35,9 @@ export class PartyDetails {
     event.preventDefault();
     this.party = this.resetToParty;
   }
+  canActivate() {
+    return Meteor.userId();
+  }
   onActivate() {
     this.party = Parties.find(this.partyId).fetch()[0];
     if (this.party) {
-- 
2.3.5


From d2271007ce20ec4884426d2e32f30b94f634dd4b Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Tue, 8 Sep 2015 16:05:07 +0900
Subject: [PATCH 80/95] Step 8.16: User login alert during canActivate failure

---
 client/party-details/party-details.ts | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index 788119f..d6f2511 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -36,6 +36,10 @@ export class PartyDetails {
     this.party = this.resetToParty;
   }
   canActivate() {
+    if (!Meteor.userId()) {
+      alert('Please login first');
+      return false;
+    }
     return Meteor.userId();
   }
   onActivate() {
-- 
2.3.5


From c5f86448f987d6d36b786c0ffbe6d7bd567ca881 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:02:42 +0900
Subject: [PATCH 81/95] Step 9.1: remove autopublish package

---
 .meteor/packages | 1 -
 1 file changed, 1 deletion(-)

diff --git a/.meteor/packages b/.meteor/packages
index 41f772f..260111e 100644
--- a/.meteor/packages
+++ b/.meteor/packages
@@ -5,7 +5,6 @@
 # but you can also edit it by hand.
 
 meteor-platform
-autopublish
 
 shmck:angular2
 netanelgilad:angular2-typescript
-- 
2.3.5


From 687d2d06cefb185f96e12630cc23f37804c22748 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Fri, 11 Sep 2015 08:14:04 +0900
Subject: [PATCH 82/95] update package versions after autopublish removed

---
 .meteor/versions | 1 -
 1 file changed, 1 deletion(-)

diff --git a/.meteor/versions b/.meteor/versions
index f856bcb..ecd3042 100644
--- a/.meteor/versions
+++ b/.meteor/versions
@@ -5,7 +5,6 @@ accounts-password@1.1.1
 accounts-twitter@1.0.4
 accounts-ui@1.1.5
 accounts-ui-unstyled@1.1.7
-autopublish@1.0.3
 autoupdate@1.2.1
 base64@1.0.3
 binary-heap@1.0.3
-- 
2.3.5


From ae8ab1e43c8684198ea9fa06b71616bd22b4aece Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:03:54 +0900
Subject: [PATCH 83/95] Step 9.2: Publish parties collection

---
 server/parties.ts | 3 +++
 1 file changed, 3 insertions(+)
 create mode 100644 server/parties.ts

diff --git a/server/parties.ts b/server/parties.ts
new file mode 100644
index 0000000..6c7413f
--- /dev/null
+++ b/server/parties.ts
@@ -0,0 +1,3 @@
+Meteor.publish('parties', function () {
+  return Parties.find();
+});
\ No newline at end of file
-- 
2.3.5


From cbdee533e67be8a41c7f709fd9bff8f6a2ee356d Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:04:53 +0900
Subject: [PATCH 84/95] Step 9.3: subscribe to parties colleciton in
 PartiesList

---
 client/parties-list/parties-list.ts | 1 +
 1 file changed, 1 insertion(+)

diff --git a/client/parties-list/parties-list.ts b/client/parties-list/parties-list.ts
index 8c93a3e..6faed45 100644
--- a/client/parties-list/parties-list.ts
+++ b/client/parties-list/parties-list.ts
@@ -15,6 +15,7 @@ export class PartiesList {
   parties: IParty[];
   partyService:PartyService;
   constructor (@Inject(PartyService) partyService:PartyService) {
+    Meteor.subscribe('parties');
     this.partyService = partyService;
     Tracker.autorun(zone.bind(() => {
       this.parties = Parties.find().fetch();
-- 
2.3.5


From b8ea70a4a0e0cf338049e5564fb5ffbfa82eda86 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:06:14 +0900
Subject: [PATCH 85/95] Step 9.4: publish only parties that are public or owned
 by the user

---
 server/parties.ts | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/server/parties.ts b/server/parties.ts
index 6c7413f..63ea457 100644
--- a/server/parties.ts
+++ b/server/parties.ts
@@ -1,3 +1,13 @@
 Meteor.publish('parties', function () {
-  return Parties.find();
+  return Parties.find({
+    $or:[
+      {$and:[
+        {"isPublic": true},
+        {"isPublic": {$exists: true}}
+      ]},
+      {$and:[
+        {owner: this.userId},
+        {owner: {$exists: true}}
+      ]}
+    ]});
 });
\ No newline at end of file
-- 
2.3.5


From fdb52e004b7718d2b9a8612ff9ce243008781e93 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:07:25 +0900
Subject: [PATCH 86/95] Step 9.5: load initial parties with owner and isPublic
 values

---
 server/loadParties.ts | 24 ++++++++++++++++--------
 1 file changed, 16 insertions(+), 8 deletions(-)

diff --git a/server/loadParties.ts b/server/loadParties.ts
index 9dd05e7..554afb8 100644
--- a/server/loadParties.ts
+++ b/server/loadParties.ts
@@ -1,14 +1,22 @@
 Meteor.startup(function () {
   if (Parties.find().count() === 0) {
 
-    var parties:IParty[] = [
-      {'name': 'Dubstep-Free Zone',
-        'description': 'Can we please just for an evening not listen to dubstep.'},
-      {'name': 'All dubstep all the time',
-        'description': 'Get it on!'},
-      {'name': 'Savage lounging',
-        'description': 'Leisure suit required. And only fiercest manners.'}
-    ];
+    var parties:IParty[] = [{
+      name: 'Dubstep-Free Zone',
+      description: 'Can we please just for an evening not listen to dubstep.',
+      owner: 'anonymous',
+      isPublic: true
+    }, {
+      name: 'All dubstep all the time',
+      description: 'Get it on!',
+      owner: 'anonymous',
+      isPublic: true
+    }, {
+      name: 'Savage lounging',
+      description: 'Leisure suit required. And only fiercest manners.',
+      owner: 'anonymous',
+      isPublic: false
+    }];
 
     for (var i = 0; i < parties.length; i++)
       Parties.insert(parties[i]);
-- 
2.3.5


From a084395415b1afff0c6d2a389769285d52280476 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:09:10 +0900
Subject: [PATCH 87/95] Step 9.6: Add isPublic value to IParty interface

---
 typings/socially/socially.d.ts | 1 +
 1 file changed, 1 insertion(+)

diff --git a/typings/socially/socially.d.ts b/typings/socially/socially.d.ts
index cfadbb5..9337c78 100644
--- a/typings/socially/socially.d.ts
+++ b/typings/socially/socially.d.ts
@@ -7,4 +7,5 @@ interface IParty {
   name: string;
   description: string;
   owner: string;
+  isPublic: boolean;
 }
\ No newline at end of file
-- 
2.3.5


From 0aa5818bc402264a585433ed817ea72362b57f4c Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:09:53 +0900
Subject: [PATCH 88/95] Step 9.7: Subscribe to parties in PartyDetails

---
 client/party-details/party-details.ts | 1 +
 1 file changed, 1 insertion(+)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index d6f2511..d3801d9 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -43,6 +43,7 @@ export class PartyDetails {
     return Meteor.userId();
   }
   onActivate() {
+    Meteor.subscribe('parties', this.partyId);
     this.party = Parties.find(this.partyId).fetch()[0];
     if (this.party) {
       console.log('loading...');
-- 
2.3.5


From 2aa53603b9f1b694f63bc6837616420cc2828b2a Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:10:44 +0900
Subject: [PATCH 89/95] Step 9.8: add isPublic to PartiesForm form

---
 client/parties-form/parties-form.ts | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/client/parties-form/parties-form.ts b/client/parties-form/parties-form.ts
index 1fa8f5a..aa065a1 100644
--- a/client/parties-form/parties-form.ts
+++ b/client/parties-form/parties-form.ts
@@ -16,7 +16,8 @@ export class PartiesForm {
     this.partyService = partyService;
     this.partiesForm = new ControlGroup({
       name: new Control('', Validators.required),
-      description: new Control('', Validators.required)
+      description: new Control('', Validators.required),
+      isPublic: new Control(false)
     });
   }
   add(party:IParty) {
-- 
2.3.5


From a754312e9794cb31cb0a2b521e498c8bf9e75816 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:11:24 +0900
Subject: [PATCH 90/95] Step 9.9: add isPublic to parties-form template

---
 client/parties-form/parties-form.ng.html | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/client/parties-form/parties-form.ng.html b/client/parties-form/parties-form.ng.html
index 15b84df..1f2781f 100644
--- a/client/parties-form/parties-form.ng.html
+++ b/client/parties-form/parties-form.ng.html
@@ -3,5 +3,7 @@
   <input type="text" ng-control="name">
   <label>Description</label>
   <input type="text" ng-control="description">
+  <label>Public</label>
+  <input type="checkbox" ng-control="isPublic">
   <button>Add</button>
 </form>
\ No newline at end of file
-- 
2.3.5


From 3b1947f2bbc6d76c967a827cf9fc1613f11df17e Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:12:31 +0900
Subject: [PATCH 91/95] Step 9.10: add isPublic to party-details template form

---
 client/party-details/party-details.ng.html | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/client/party-details/party-details.ng.html b/client/party-details/party-details.ng.html
index ae6bfb6..1b4092a 100644
--- a/client/party-details/party-details.ng.html
+++ b/client/party-details/party-details.ng.html
@@ -5,6 +5,9 @@
   <label>Description</label>
   <input type="text" [(ng-model)]="party.description">
 
+  <label>Is public</label>
+  <input type="checkbox" [(ng-model)]="party.isPublic">
+
   <button type="submit">Save</button>
   <button (click)="reset($event)">Reset form</button>
   <button [router-link]="['/parties-list']">Cancel</button>
-- 
2.3.5


From eb86feb85fba8e89f68f6ac626b1a91a1dc516a9 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:13:32 +0900
Subject: [PATCH 92/95] Step 9.11: Publish email and profile fields of users

---
 server/users.ts | 3 +++
 1 file changed, 3 insertions(+)
 create mode 100644 server/users.ts

diff --git a/server/users.ts b/server/users.ts
new file mode 100644
index 0000000..f5becea
--- /dev/null
+++ b/server/users.ts
@@ -0,0 +1,3 @@
+Meteor.publish("users", function () {
+  return Meteor.users.find({}, {fields: {emails: 1, profile: 1}});
+});
\ No newline at end of file
-- 
2.3.5


From ffb04b11d0cc7eb1fe9a5c97a82041036fd1ca67 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:14:51 +0900
Subject: [PATCH 93/95] Step 9.12: subscribe to users in PartyDetails

---
 client/party-details/party-details.ts | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index d3801d9..e31fa5e 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -43,6 +43,8 @@ export class PartyDetails {
     return Meteor.userId();
   }
   onActivate() {
+    Meteor.subscribe('users');
+    this.users = Meteor.users();
     Meteor.subscribe('parties', this.partyId);
     this.party = Parties.find(this.partyId).fetch()[0];
     if (this.party) {
-- 
2.3.5


From 5b842f81a76112ea2d03ccc37f91fd4eb5230e3d Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:16:00 +0900
Subject: [PATCH 94/95] Step 9.13: load NgFor into PartyDetails

---
 client/party-details/party-details.ts | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/client/party-details/party-details.ts b/client/party-details/party-details.ts
index e31fa5e..5dd6a0c 100644
--- a/client/party-details/party-details.ts
+++ b/client/party-details/party-details.ts
@@ -1,4 +1,4 @@
-import {Component, View, Inject} from 'angular2/angular2';
+import {Component, View, Inject, NgFor} from 'angular2/angular2';
 import {RouteParams, RouterLink} from 'angular2/router';
 import {FORM_DIRECTIVES} from 'angular2/angular2';
 import {PartyService} from 'client/lib/party-service';
@@ -9,7 +9,7 @@ import {PartyService} from 'client/lib/party-service';
 })
 @View({
   templateUrl: 'client/party-details/party-details.ng.html',
-  directives: [RouterLink, FORM_DIRECTIVES]
+  directives: [RouterLink, FORM_DIRECTIVES, NgFor]
 })
 export class PartyDetails {
   partyId: string;
-- 
2.3.5


From 16ef5168590801464c25f2338e6a00a4d073caa7 Mon Sep 17 00:00:00 2001
From: ShMcK <shawn.j.mckay@gmail.com>
Date: Thu, 10 Sep 2015 16:17:19 +0900
Subject: [PATCH 95/95] Step 9.14: load list of users in party-details
 template, wrap in a div

---
 client/party-details/party-details.ng.html | 31 +++++++++++++++++++-----------
 1 file changed, 20 insertions(+), 11 deletions(-)

diff --git a/client/party-details/party-details.ng.html b/client/party-details/party-details.ng.html
index 1b4092a..b5e816f 100644
--- a/client/party-details/party-details.ng.html
+++ b/client/party-details/party-details.ng.html
@@ -1,14 +1,23 @@
-<form (submit)="save($event)">
-  <label>Name</label>
-  <input type="text" [(ng-model)]="party.name">
+<div>
+  <form (submit)="save($event)">
+    <label>Name</label>
+    <input type="text" [(ng-model)]="party.name">
 
-  <label>Description</label>
-  <input type="text" [(ng-model)]="party.description">
+    <label>Description</label>
+    <input type="text" [(ng-model)]="party.description">
 
-  <label>Is public</label>
-  <input type="checkbox" [(ng-model)]="party.isPublic">
+    <label>Is public</label>
+    <input type="checkbox" [(ng-model)]="party.isPublic">
 
-  <button type="submit">Save</button>
-  <button (click)="reset($event)">Reset form</button>
-  <button [router-link]="['/parties-list']">Cancel</button>
-</form>
\ No newline at end of file
+    <button type="submit">Save</button>
+    <button (click)="reset($event)">Reset form</button>
+    <button [router-link]="['/parties-list']">Cancel</button>
+  </form>
+
+  <ul>
+    Users:
+    <li *ng-for="#user of users">
+      <div>{{ user.emails[0].address }}</div>
+    </li>
+  </ul>
+</div>
\ No newline at end of file
-- 
2.3.5

